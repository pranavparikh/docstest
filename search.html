<!DOCTYPE html>
<html>
<head>
	<title>Test Armada</title>
	<link rel="stylesheet" type="text/css" href="/css/normalize.css">
	<link rel="stylesheet" type="text/css" href="/css/common.css">
	<link rel="stylesheet" type="text/css" href="/css/header.css">
	<link rel="stylesheet" type="text/css" href="/css/home.css">
	<link rel="stylesheet" type="text/css" href="/css/doc.css">
	<link rel="stylesheet" type="text/css" href="/css/training.css">
	<link rel="stylesheet" type="text/css" href="/css/faq.css">
	<link rel="stylesheet" type="text/css" href="/css/contact.css">
	<link rel="stylesheet" type="text/css" href="/css/search.css">
	<link rel="stylesheet" type="text/css" href="/css/custom.css">
	<link rel="stylesheet" type="text/css" href="/css/slick.css">
	<link rel="stylesheet" type="text/css" href="/css/prism.css">
	<link rel="stylesheet" type="text/css" href="/css/responsive.css">
</head>
<body>
	
	<header>
		<a href="/">
			<img src="/documentation/images/ta-logo.png" class="logo" alt="Main Brand Logo"
				 srcset="/documentation/images/ta-logo@2x.png 2x, /documentation/images/ta-logo@3x.png 3x">
		</a>
		<form action="/search" method="get">
			<input type="text" id="search-box" name="query" placeholder="Search" class="search-box">
			<div class="select-box">
				<select name="fleet" id="fleet-box" onchange="document.getElementById('search-box').focus();">
					<option value="all">All Fleets</option>
					
					<option value="Performance Testing">Performance Testing</option>
					
					<option value="Functional Testing">Functional Testing</option>
					
					<option value="Mocking">Mocking</option>
					
					<option value="Data Insights">Data Insights</option>
					
				</select>
			</div>
		</form>
		<div class="nav-links">
			<div class="nav-links__fleets">
				<a class="nav-links__fleets-btn">
					Fleets <img src="/images/arrow-down-icon.png" class="arrow-down-icon"
								srcset="/images/arrow-down-icon@2x.png 2x,
										/images/arrow-down-icon@3x.png 3x">
				</a>
				<div class="nav-links__fleets-content">
					<a href="/">
						All Fleets
					</a>
					
					<a href="/Performance Testing/">
						Performance Testing
					</a>
					
					<a href="/Functional Testing/">
						Functional Testing
					</a>
					
					<a href="/Mocking/">
						Mocking
					</a>
					
					<a href="/Data Insights/">
						Data Insights
					</a>
					
				</div>
			</div>
			
			
			<a href="/faq" class="nav-links__main-links">FAQ</a>
			
			
			
			<a href="https://gecgithub01.walmart.com/otto/" target="_blank" class="nav-links__main-links">GitHub</a>
			
		</div>
	</header>

	<div class="container">
		<div class="inner-container">

  <div class="breadcrumb">
    <p>
      <a class="breadcrumb__link" href="/">Home</a>
      <img src="/images/arrow-right-icon.png" srcset="/images/arrow-right-icon@2x.png 2x,
              /images/arrow-right-icon@3x.png 3x" class="arrow-right-icon">
      <span class="breadcrumb__current-page">Search Results</span>
    </p>
  </div>

  <div class="search-content">
    <h2 id="result-count">Searching...</h2>
    <p id="not-found-message">This means that we either couldn't find a match for your searched query in our documentation or it's a very common term that returned too many results. Please refine your search query and try again.</p>
    <div id="search-results"></div>
    <div id="pagination" class="pagination"></div>
  </div>

</div>

<script>
  window.store = {
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-401-state": {
        "title": "State",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExercise1. What is state?State allows you to maintain state of your server, for example if a user is logged in or logged out. The mock server internally uses Hapi node server, which helps you return the state of the current application state. Within any response handler, use this.state('varName') to access an object stored in the state and this.state('varName', 'varValue') where varValue can be any type of object you want to set the state.2. How to set a state in mock server?shifu.route({  path: '/api/login',  label: 'LogIn',  method: 'POST',  handler: function(request, reply) {    // now you can use this.state('loggedIn') in any route handler to see if the user has logged in    this.state('loggedIn', true);    reply().code(204);  }});",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 401/State"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-401-starting-https-server-with-mock-server": {
        "title": "Starting HTTPS server with Mock Server",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExercise1. Updating run-mock-server-console.js to enable HTTPSrequire('./endpoints');var fs = require('fs');var shifu = require('shifu'); shifu.start({  host: &quot;localhost&quot;,    mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  httpsPort: 4444,  project: 'HelloShifu'});The default port for HTTPS is 44442. Starting mock server with HTTPS enabledOnce you add the above code, the mock server will provide the HTTPS and HTTPS support by default. Hence when the mock server starts up, you will see both the ports open. Note that the mock server auto generates the certificates (key.pem and cert.pem). If you want to provide your own key and certificate, you can provide it under the mocked data directory.",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 401/Starting HTTPS server with Mock Server"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-401-rest-apis": {
        "title": "Rest APIs",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExercise1. Set VariantMethod    : POSTSyntax    : {host}:{port}/_admin/api/route/{routeId}Rest API  : curl -H &quot;Content-Type: application/json&quot; -X POST -d '{&quot;variant&quot;:&quot;preorder&quot;}' http://localhost:8000/_admin/api/route/getCollection?returnConfig=trueshifu.route({    id: 'getCollection',    label: 'Get Collection',    path: '/product/grouping/api/collection/{collectionId}',     variantLabel: 'default',    handler: function(req, reply) {        var response = getResponseData('/product/grouping/api/collection', 'default');        reply(response);    }}).variant({    id: 'preorder',    label: 'Get Pre-order Collection',    handler: function (req, reply) {        reply({message: 'hello pre-order'});    }});To get the config back as a response, add query parameter returnConfig=true as shown in example above2. Set Mock IdMethod    : GETSyntax    : {host}:{port}/_admin/api/shifu/setMockId/{mockid}/{sessionid}Rest API  : curl http://localhost:8000/_admin/api/shifu/setMockId/1234/default3. Get Mock IdMethod    : GETSyntax    : {host}:{port}/_admin/api/shifu/getMockId/{sessionid}Rest API  : curl http://localhost:8000/_admin/api/shifu/getMockId/default4. Reset Mock IdMethod    : GETSyntax    : {host}:{port}/_admin/api/shifu/resetMockId/{sessionid}Rest API  : curl http://localhost:8000/_admin/api/shifu/resetMockId/default5. Get Url CountMethod    : GETSyntax    : {host}:{port}/_admin/api/shifu/getURLCount/{sessionid}Rest API  : curl http://localhost:8000/_admin/api/shifu/getURLCount/default6. Reset Url CountMethod    : GETSyntax    : {host}:{port}/_admin/api/shifu/resetURLCount/{sessionid}Rest API  : curl http://localhost:8000/_admin/api/shifu/resetURLCount/default7. Re-set the state of Mock ServerMethod    : POSTSyntax    : {host}:{port}/_admin/api/state/resetRest API  : curl -X POST http://localhost:8000/_admin/api/state/reset8. Register SessionMethod    : GETSyntax    : {host}:{port}/_admin/api/shifu/registerSessionRest API  : curl http://localhost:8000/_admin/api/shifu/registerSession9. Get SessionsMethod    : GETSyntax    : {host}:{port}/_admin/api/shifu/getSessionsRest API  : curl http://localhost:8000/_admin/api/shifu/getSessions10. Check SessionMethod    : GETSyntax    : {host}:{port}/_admin/api/shifu/checkSession/{sessionid}Rest API  : curl http://localhost:8000/_admin/api/shifu/checkSession/{sessionid}11. Close SessionMethod    : GETSyntax    : {host}:{port}/_admin/api/shifu/closeSession/{sessionid}Rest API  : curl http://localhost:8000/_admin/api/shifu/closeSession/{sessionid}",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 401/Rest APIs"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-401-mocking-utility-methods": {
        "title": "Mocking Utility Methods",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExercise1. RespondWithFile Utilityshifu.route({  id: 'message',  label: 'hello message',  path: '/message',   handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }})Setting Codeshifu.route({    id: 'message',    label: 'hello message',    path: '/message',    handler: function(req, reply) {        shifu.util.respondWithFile(this, reply, {code: 400});    }})Custom File Locationshifu.route({    id: 'message',    label: 'hello message',    path: '/message',    handler: function(req, reply) {        shifu.util.respondWithFile(this, reply, {code: 400, filePath: '../mocked-data/fileName.json'});    }})Setting Headersshifu.route({id: 'message',label: 'hello message',path: '/message',handler: function(req, reply) {    var myHeaders = {        header1: 'test1',        header2: 'test2',        header3: true    };    shifu.util.respondWithFile(this, reply, {code: 400, filePath: '../mocked-data/fileName.json', headers: myHeaders});}});Setting Cookiesshifu.route({id: 'message',label: 'hello message',path: '/message',handler: function(req, reply) {    var myHeaders = {        header1: 'test1',        header2: 'test2',        header3: true    };    var cookies = [        {name: 'com.wm.customer', value: 'vz7.0b5c56'},        {name: 'CID', value: 'SmockedCID', options: {domain: 'domain', path: '/'}},        {name: 'anotherCookie', value: 'cookieValue'}    ];    shifu.util.respondWithFile(this, reply, {code: 400, filePath: '../mocked-data/fileName.json', headers: myHeaders, cookies: cookies});}});Setting Delayshifu.route({    id: 'message',    label: 'hello message',    path: '/message',    handler: function(req, reply) {        var myHeaders = {            header1: 'test1',            header2: 'test2',            header3: true        };        var cookies = [            {name: 'com.wm.customer', value: 'vz7.0b5c56'},            {name: 'CID', value: 'SmockedCID', options: {domain: 'domain', path: '/'}},            {name: 'anotherCookie', value: 'cookieValue'}        ];        shifu.util.respondWithFile(this, reply, {code: 400, filePath: '../mocked-data/fileName.json', headers: myHeaders, cookies: cookies, delay: 1000});    }});Modifying Static JSON responseIf you have many variants for a REST end point and the mocked data for all variants can use the same JSON response with few changes to the values, than this feature is what you need. This feature allows you to dynamically change a JSON file before sending the response back from the mock server for the request. It removes the need of having one to one mapping of static JSON files with each variants.// Static Response JSON File{    &quot;id&quot;: &quot;1234&quot;,    &quot;name&quot;: &quot;toothpaste&quot;,    &quot;details&quot;: [        {            &quot;flavor&quot;: &quot;Mint 1&quot;,            &quot;Size&quot;: &quot;10&quot;,            &quot;Size_Type&quot;: &quot;ounce&quot;        },        {            &quot;flavor&quot;: &quot;Mint&quot;,            &quot;Size&quot;: &quot;10&quot;,            &quot;Size_Type&quot;: &quot;ounce&quot;        }    ]}// Sample code for substituting id from 1234 to 7777 and flavor from Mint to Mint 2 for second array element in routesshifu.route({    id: 'Get Collection',    label: 'Get Collections',    path: '/product/grouping/api/collection/{collectionId}',    handler: function(req, reply) {        var dataToChange = {            'id': '7777',            'details[1].flavor': 'Mint 2'        }        shifu.util.respondWithFile(this, reply, {transpose: dataToChange});     }});// Dynamic Response JSON File returned from Mock service{    &quot;id&quot;: &quot;7777&quot;,    &quot;name&quot;: &quot;toothpaste&quot;,    &quot;details&quot;: [        {            &quot;flavor&quot;: &quot;Mint 1&quot;,            &quot;Size&quot;: &quot;10&quot;,            &quot;Size_Type&quot;: &quot;ounce&quot;        },        {            &quot;flavor&quot;: &quot;Mint 2&quot;,            &quot;Size&quot;: &quot;10&quot;,            &quot;Size_Type&quot;: &quot;ounce&quot;        }    ]}2. Logging utilityShifu exposes a logging utility which can be used to log datashifu.log.debug('This is debug Message');shifu.log.info('This is info Message');shifu.log.error('This is error Message');shifu.log.warn('This is warn Message');shifu.log.setLogLevel('debug');shifu.log.getLogLevel();shifu.log.resetLogLevel();// default level is INFO3. Responding with a specific variant in handlers (respondWithMockVariant)This function will respond with a variant on the main route handler. The variant passed in MUST be the variant on existing route.shifu.util.respondWithMockVariant(this, 'variant', reply);The variant passed in MUST be the variant on existing route.shifu.route({    id: 'respondWithVariant',    label: 'Respond With Variant',    path: '/respondWithVariant',    variantLabel: 'Respond With Variant Main Route',    handler: function (req, reply) {        shifu.util.respondWithMockVariant(this, 'variant', reply); // make sure that the variant exist in the same route.    }}).variant({    id: 'variant',    label: 'Respond With Variant Variant Route',    handler: function (req, reply) {        reply({'message': 'I am an example of respond_with_mock_variant instead of response of main route '});    }});4. GetUrlCountTo get URL count for all Rest APIs mocked by mock serverShifu API : shifu.getURLCount(&quot;default&quot;);5. ResetUrlCountTo resets URL count to zeroShifu API : shifu.resetURLCount(&quot;default&quot;);",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 401/Mocking Utility Methods"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-401-exercise": {
        "title": "Exercise",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExerciseUpdate the previous mock server with the following:Add a logg-in route api/loginAdd a log-out route api/logoutAdd a state variable loggedIn and set true/false value based on the above APIs.Update the get/message default handler to return the message Hello: fname lname if user is logged in by reading from the query parameters otherwise  Hello: Guest is the customer Id is less than equal to 5 characters.Update the get/message Hello Universe variant to modify the file to following using transpose data based on if user is logged in or logged out- User Logged In{    message: fname lname}- User Logged Out{    message: Guest}Start mock serverHit get/message with customer id length &lt;=5 and see you should get Hello: GuestSet the variant to Hello UniverseHit get/message with customer id length &lt;=5 and see you should get message: GuestHit api/loginSet the variant to defaultHit http://localhost:8000/get/message/12345?fname=John&amp;lname=Doe with customer id length &lt;=5 and see you should get Hello: John Doe.Set the variant to Hello UniverseHit http://localhost:8000/get/message/12345?fname=John&amp;lname=Doe with customer id length &lt;=5 and see you should get message:John DoeHit api/logout and repeat 5 to 7.Create and install certificates to enable HTTPS in Shifu.Update run-mock-server-console.js to enable https in mock server.Start mock server and navigate to https://localhost:4444/_admin and repeat 5 to 12 steps.",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 401/Exercise"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-301-setmockid": {
        "title": "SetMockId",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExercise1. What is SetMockIdThis feature is very handy when you want to stub all the endpoints for a particular test without manually writing the paths for those endpoints. Generally applicable in scenarios where one page calls different endpoints according to test flows. You do not need to set variant or create variants for these endpoints. You will need to manually store the stubbed JSON files in the file structure location which are specified by your endpoints. The endpoints responses can be captured and stored under mocked data directory as a one time setup.2. How SetMockId works?ScenarioLets say your test case requires to mock two end points /api/message and /api/product/getStatus. These endpoints are called three times each. For the first end point you always want to return the same data (in json) while for the second endpoint you want to return the same data for the first and third call (in html) and a different data for the second call (in html).ImplementationCreate a folder under the mocked-data of your test directory (this folder name is configurable when you start your mock server by passing mockedDirectory option) by the name test1. Under this folder add the following files for your mocked response.api-message-GET.json - This will be returned for all the calls for the first endpoint with default response code 200api-product-getStatus-GET.html - This will be returned for all the calls for the second endpoint with default response code 200, except for the second and third call as it has its own fileapi-product-getStatus-GET-2.html - This will be returned for the second call for the second endpoint with default response code 200api-product-getStatus-GET-3-code-201.html - This will be returned for the third call for the second endpoint with response code 201Now set the setMockId either by mock api, UI or rest call to set to test1ExplanationThe underlying mock service automatically figures out the file extension so that you do not have to specify it. If you have the same file with multiple file extension than the following order is used:JSONHTMLTXTFirst file encountered of any other extensionOnce the shifu.setMockId(“test1”) API is called, Shifu only looks for the responses under the test1 folder. If it does not find the response, it will return 404 with the file name that it did not find. Shifu internally keeps track of the number of times each individual endpoint is called after client.setMockId(“test1”) API is called and first looks for the file with count specific name such as api-message-GET-1.json, if it does not find the said file then it looks for the default file which is api-message-GET.json.3. Good To KnowIf setMockId is set, then custom file path in handlershifu.util.respondWithFile(this, reply, {filePath: ‘./message/GET/default.json’});and file based on URL path ./mocked-data/api/message/get/default.json are ignored for the mocked response. Here is the order followed for file lookup:SetMockIdCustom File Path for default or variants endpoints.File based on URL Path for default or variants endpoints.SetMockId does not work with in-line Handlershifu.route({  id: 'message',  label: 'Message',  path: '/get/message/{customerid}',  method: 'GET',  variantLabel: 'Hello',  handler: function (req, reply) {    var lname = req.query.lname;    var fname = req.query.fname;    var customerid = req.params.customerid;    if (customerid.length &gt; 5) {      reply().code(400);    } else {      reply('Hello ' + fname + &quot; &quot; + lname);    }  }})",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 301/SetMockId"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-301-parallel-sessions": {
        "title": "Parallel Sessions",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExercise1. What is parallel sessions and why it's needed?Parallel sessions allows you to run multiple instance of server virtually while running only one server. This is helpful when you are running multiple test cases which access the same routes but different variants as parallel sessions allow you to set different variants on same routes without conflicting. This saves CPU and RAM both as only one server is running instead of multiple.2. How Parallel Sessions works internally?3. How to add parallel sessions?To add parallel sessions, modify run-mock-server-console.js to add 'sessions' parameter.require('./endpoints');var shifu = require('shifu');shifu.start({  host: &quot;localhost&quot;,  mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  sessions: 2,  project: 'HelloShifu'});You can also start or add sessions via command line argumentnode resources/run-mock-server-console.js --shifuSessions 2If you pass sessions = 2, there will be two parallel sessions along with one default session.4. Supported APIs for Parallel sessionsRegister SessionTo register sessions to be usedvar sessionId = shifu.registerSession();Get SessionsTo get all the active sessionsvar activeSessions = shifu.getSessions();Check SessionTo check the session status (Available or In-Use or invalid)var sessionStatus = shifu.checkSession(sessionId);Close SessionTo de-register session for later usevar closeSession = shifu.closeSession(sessionId);5. Using Parallel SessionsTo use a parallel session call the following api:curl http://localhost:8000/_admin/api/shifu/registerSessionorshifu.registerSession()and a session id will be returned.Append this sessionId to the mocked host address to use this parallel session. For ex: If your mock host server is http://localhost:8080 and your session id is 112233 then the mock server address for this parallel session will be http://localhost:8080/112233.6. Verifying parallel sessionsStart mock server with two sessions. Now go to the 'Message' route. You will see three routes for message, default and two for parallel sessions that you just added. Now for each route choose a different variant and hit the URL icon. You will see that each time you will get a different value though you are hitting the same route.7. Understanding the Shifu UI with sessionsTry to go through Shifu UI to understand sessions.",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 301/Parallel Sessions"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-301-exercise": {
        "title": "Exercise",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExerciseUpdate the previous mock server with the following:Update the Hello World variant of 'get/message' request toRemove the header parametersReturn the file as before by using RespondWithFile without handlerUpdate the default handler to return ONLY code 400 if the customer id is greater than 5 charactersStart mock server and test Step 1Now add data for setMockId for /get/message and /get/number routes.Return the following for URL hit count 1/get/message{    &quot;message&quot; : 1}/get/number{    &quot;number&quot; : 1}Return the following for URL hit count 2/get/message{    &quot;message&quot; : 2}/get/number{    &quot;number&quot; : 2}Return the following for default/get/message{    &quot;message&quot; : &quot;Undefined&quot;}/get/number{    &quot;number&quot; : &quot;Undefined&quot;}Call API to setMockId to the folder name via Shifu UIHit the rest endpoint /get/message and /get/number one time each and verify the response is &quot;message&quot; : 1 and &quot;number&quot; : 1 respectively.Hit the rest endpoint /get/message and /get/number once more and verify the response for second hit is &quot;message&quot; : 2 and &quot;number&quot; : 2 respectively.Hit the rest endpoint /get/message and /get/number one more time to verify that the response is &quot;message&quot; : &quot;undefined&quot; and &quot;number&quot; : &quot;undefined&quot; respectively.Call ResetMockId API via Shifu UIHit the rest endpoint /get/message and /get/number once each and verify the response is based on the handler and not on SetMockId - You may have to add appropriate file based on the route path.Update run-mock-server-console.js to add two parallel sessions to the server.Now call GetSessionId to register a session using Shifu UI.Now set Hello World and Hello Universe variant for get/message api for the two sessions Ids respectively.Now hit the server https://localhost:8000/sessionId/get/message for different session Ids and verify that you get different responses as per each variant.",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 301/Exercise"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-301-different-ways-of-returning-response-data": {
        "title": "Different ways of returning response data",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExercise1. Returning only the codeshifu.route({ id: 'message', label: 'hello message', path: '/message', handler: function(req, reply) {   reply().code(400); }})2. Using RespondWithFile without handlershifu.route({  path: '/api/customer/getId',  label: 'Get Customer Id',  method: 'GET', }).respondWithFile();3. Returning static mocked data with a response codeshifu.route({  id: 'message',  label: 'hello message',  path: '/message',   handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {code: 400});  }})",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 301/Different ways of returning response data"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-301-apis-for-setmockid": {
        "title": "APIs for SetMockId",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExercise1. SetMockIdshifu.setMockId(&quot;1234&quot;, &quot;default&quot;);2. GetMockIdshifu.getMockId(&quot;default&quot;);3. ResetMockIdshifu.resetMockId(&quot;default&quot;);",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 301/APIs for SetMockId"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-201-returning-response-from-a-file": {
        "title": "Returning Response from a File",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. What does it mean?This feature allows you to respond with a data stored in a file instead of hard coding the response data in the routes definition. This way user does not have to change the response rather can just swap the file with different data.2. How it works?shifu.route({  id: 'ResponseFromFile',  label: 'Response From File',  path: '/get/fromFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }});In the above setup, file needed for default route, which is /get/fromFile should be located at ./mocked-data/get/fromFile/GET/default.json3. What is mockedDirectory Path?Mocked directory path is the location to the base directory where all your mocked response file will be stored. This parameter is defined in run-mock-server-console.js file. It is defined at the start of mock server as shown in the code below:require('./endpoints-Shifu-201');require('shifu').start({  host: &quot;localhost&quot;,  mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  project: 'HelloShifu'});4. Automatic calculation of file locationThe path to the mocked data file is auto-calculated based on the route path. For variants, the name of the file should be changed from default to the variant name as shown below:shifu.route({  id: 'ResponseFromFile',  label: 'Response From File',  path: '/get/fromFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }}).variant({  id: 'textData',  label: 'Text Data',  handler: function (req, reply) {    shifu.util.respondWithFile(this, reply);  }})In the above example, mock server would look for ./resources/mocked-data/get/fromFile/GET/textData.txt file for the variant textData5. Providing custom path to the response fileA custom file path could also be provided for a mocked data file. to do so, use the following code:shifu.route({  id: 'CustomResponseFile',  label: 'Response From Custom Path',  path: '/get/customFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {filePath: './custom.json'});  }})Shifu will look for the file under MockedDirectory only but at ./resources/mocked-data/custom.json",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 201/Returning Response from a File"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-201-request-call-information": {
        "title": "Request Call Information",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. Query ParametersLet's say you go to the following URL: http://localhost:8000/get/customerInfo/12345?ctype=new . To read the query parameter, do the following:var ctype = req.query.ctype;To run the above scenario, hit the following in any browser with Shifu server running: http://localhost:8000/get/customerInfo/12345?ctype=new after updating the route toshifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}',  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    var id = req.params.customerid;    var ctype = req.query.ctype;    var replyString = 'Customer Type: ' + ctype + ' customer id: ' + id;    reply(replyString);  }});2. Header informationLet's say there is a header parameter 'name' with value 'John' is passed with the request. To read the testHeader parameter, do the following:var req = req.raw.req;var name = req.headers.name;To run the above scenario, use postman to make the following get call: http://localhost:8000/get/customerInfo/12345?ctype=new and add header 'name' with value 'John' after updating the route toshifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}',  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    var id = req.params.customerid;    var ctype = req.query.ctype;    var req = req.raw.req;    var name = req.headers.name;    var replyString = 'Customer Type: ' + ctype + ' customer id: ' + id + ' nameFromHeader: ' + name;    reply(replyString);  }});3. PayloadThe payload can be read using the following code://fname would be &quot;Bob&quot; if the posted body content (as JSON) was {&quot;fname&quot;: &quot;Bob&quot;}var fname = req.payload.fname;To run the above scenario, use postman to make the following POST call: http://localhost:8000/payload and add payload {&quot;fname&quot;: &quot;Bob&quot;} in the request.shifu.route({  id: 'payload',  label: 'Reading Payload',  path: '/payload',  method: 'POST',  variantLabel: 'Payload',  handler: function (req, reply) {    var fname = req.payload.fname;    reply(fname);  }});4. Content TypesThe mock module is independent of content-types i.e. user can set any content type and mocking route is intercepted only based on the path defined in the mocked routes file.",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 201/Request Call Information"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-201-exercise": {
        "title": "Exercise",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. Update the previous mock server with the followinga. Update the route /get/message to a dynamic URL which takes customer id as a parameter.b. Update the 'Hello World' variant to- return the following file with auto file location calculation.json { &quot;message&quot; : &quot;Hello World&quot; }- Set the following header params in response{ fname: John lname: Doe }Update the Hello Universe variantto return the following file and the file location should be hard coded.{    &quot;message&quot; : &quot;Hello Universe&quot;}Set the following cookie params in response{    customerId: 123456}Update the default handler to do the following:Add reading of query parameter 'fname' and 'lname' from the request.If the customer id is greater than 5 charactersreturn 'invalid id' as responseIf the customer id is less than or equal to 5 charactersreturn following response from the handler (NOT Using The File)Hello - fname lnameAdd a POST route /set/customerId and in default handler read the payload value and log it on console.{    &quot;customerid&quot;: 123456}2. Start mock serverMake a REST call to /get/message with customer id greater than 5 characters and check the response is Invalid IdMake a REST call to /get/message with customer id equal to 5 characters and check the response to be Hello undefined undefinedMake a REST call to http://localhost:8000/get/message/12345?fname=John&amp;lname=Doe and check the response to be Hello John DoeSwitch to Hello World variant and check the response is &quot;message&quot; : &quot;Hello World&quot; and use dev tools on Chrome browser to verify that the header params are set (fname: John and lname: Doe)Switch to Hello Universe variant and check the response is &quot;message&quot; : &quot;Hello Universe&quot; and use dev tools on Chrome browser to verify that the cookie is set (customerId: 123456)Make a post call to mock server at http://localhost:8000/set/customerId using Postman (or any other HTTP client) with the following data and verify that 12345 is logged on the console{ &quot;customerId&quot; : 12345}",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 201/Exercise"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-201-dynamic-urls": {
        "title": "Dynamic URLs",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. How to create dynamic urls/get/customerInfo/{customerid}/{zipcode}2. Adding a dynamic URL in mock servershifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}',  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    reply('How to read the customer id :(');  }});3. Reading dynamic URL parametersvar id = req.params.customerid;4. Using dynamic values to define responseshifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}',  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    var id = req.params.customerid;    reply('Customer id is ' + id + ' :)');  }});5. Passing dynamic URL parameters from the Shifu UITry to pass dynamic url parameters generated from Shifu UI",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 201/Dynamic URLs"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-201-customizing-mocked-response": {
        "title": "Customizing Mocked Response",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. Set custom headersshifu.route({  id: 'header',  label: 'Custom Headers',  path: '/set/headers',  handler: function(req, reply) {  reply({message: 'custom headers'})    .header('header1', 'test1')    .header('header2', 'test2')    .header('header3', 'test3')  }}) shifu.route({  id: 'header',  label: 'Custom Headers',  path: '/set/headers',  handler: function (req, reply) {    var myHeaders = {      header1: 'test1',      header2: 'test2',      header3: true    };    shifu.util.respondWithFile(this, reply, {headers: myHeaders});  }});2. Set custom cookiesshifu.route({  id: 'cookies',  label: 'Custom Cookies',  path: '/set/cookies',  handler: function(req, reply) {    reply({message: 'test'})    .state('cookie1', 'testCookie1')    .state('cookie2', 'testCookie2')    }}); shifu.route({  id: 'cookies',  label: 'Custom Cookies',  path: '/set/cookies',  handler: function (req, reply) {    var cookies = [      {name: 'cookie1', value: 'testCookie1'},      {name: 'cookie2', value: 'testCookie2'},    ];    shifu.util.respondWithFile(this, reply, {cookies: cookies});  }});3. Set CORS headersvar corsHeaders = {  origin: ['*'],  headers: [&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, X-Requested-With, Content-Type, Accept&quot;],  credentials: true,} // Itemsshifu.route({  id: 'corsheaders',  label: 'CORS',  path: '/set/cors',   config: {    cors: corsHeaders  },  handler: function(req, reply) {    reply('cors headers set');  }});",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 201/Customizing Mocked Response"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-101-setting-and-installing-mock-server": {
        "title": "Setting and Installing Mock Server",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. Pre-requisitesnode.js 4+ (npm is included in the package)2. Add mock dependency to package.json&quot;dependencies&quot;: {  &quot;shifu&quot;: &quot;^1.0.0&quot;}3. Add .npmrc file to the projectregistry=https://registry.npmjs.org/strict-ssl=false4. Install mock dependency with npm installRun npm install command to install mock related dependencies.5. Add resources/endpoints.js and create ./resources/mocked-data directory to store the mock data.require('./endpoints');require('shifu').start({  host: &quot;localhost&quot;,  mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  project: 'HelloShifu'});6. Add resources/run-mock-server-console.jsrequire('./endpoints');require('shifu').start({  host: &quot;localhost&quot;,  mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  project: 'HelloShifu'});Please note that you will need to replace HelloShifu for key project field with your project name(without dashes).7. Add script to start mock server in package.json&quot;scripts&quot;: {  &quot;lint&quot;: &quot;eslint . --ext .js&quot;,  &quot;start-server&quot;: &quot;node ./resources/run-mock-server-console.js&quot;},8. Test mock server can be startednpm run start-server",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 101/Setting and Installing Mock Server"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-101-introduction": {
        "title": "Introduction",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. What is Shifu?We provide a mocking solution which can be leveraged to quickly stub the REST API responses that are used by your application during development or testing. The application points to the mock service host address instead of the live service, pre-recorded responses are then returned for various endpoints from the mock service. Since there is minimal logic when writing mock service, maintaining and development cost for mock service is minimal. Some of the major development pain-points addressed by the mocking solution are:Unstable servicesInconsistent DataTest against negative or unreal scenarios2. Architectural Explanation3. High Level Key FeaturesUI Interface: Mock service UI for manual testing/debugging.Test Reuse: Execute same test cases against mock or live service.Drop-And-Respond: Respond with a mocked data file based on the url route path automatically by dropping mocked data file in folder mapping to url path.Response Reuse: Ability to use same json response file and change data dynamically for mocked response for various variants.Test De-coupling: No coupling with test cases - Test cases are independent of mock implementation except that setting the desired response for the mock service (which has no impact if the test case is run against a live service).Common Utilities: Common utility methods are provided as part of this solution which allows quicker test development.HTTPS Support: HTTPS support for all the urls.Magellan/Nightwatch integration: Ability to use mocking service with Magellan tests.Parallel sessions: Support for single instance mock server for parallel processesSwagger integration: Automatic mock creator for web-services with swagger definition.Server states: Ability to mock server state.4. Mock TerminologyRoutesVariantsHandlerSetMockIdAdmin UIRespondWithFile",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 101/Introduction"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-101-introduction-to-variants": {
        "title": "Introduction to Variants",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. What are variants?Variants allows to return a different data set for a given mocked route. Variants can be selected in the admin UI to determine what type of response a route should have. Routes are defined using the variant method on the Route object (returned by calling the route method). An object parameter is provided with the following attributesid: the variant id - used for the RESTful admin API and profile settingslabel: (optional) the variant label - used for display on the admin panelhandler: (optional) the HAPI route handler which provides the route responseVariants are useful because they allow you to test multiple scenarios that can happen with your route. Say, for example, you have a route exposing the ability to update a password. You might have several exceptional scenarios that you would want to test out (each could be a variant that you simply select to tell the route handler to use the appropriate response)the password was reset successfullythe password didn't pass validationthe old password wasn't entered correctlythe username doesn't existand so on...2. Default HandlerThe handler defined under route is the default handlershifu.route({    id: 'helloWorld',    label: 'Hello World',    path: '/helloWorld',    method: 'GET',    handler: function (req, reply) {        reply('Hello World');    }});3. Creating a variantshifu.route({    id: 'message',    label: 'Message',    path: '/get/message',    method: 'GET',    variantLabel: 'Hello',    handler: function (req, reply) {        reply('Hello');    }}).variant({    id: 'hello',    label: 'Hello World',    handler: function (req, reply) {        reply('Hello World');    }});4. Selecting a different variant to be returned from UIYou can select a different variant from admin UI to determine what type of response a route should have.5. Adding more variantsshifu.route({    id: 'message',    label: 'Message',    path: '/get/message',    method: 'GET',    variantLabel: 'Hello',    handler: function (req, reply) {        reply('Hello');    }}).variant({    id: 'hello',    label: 'Hello World',    handler: function (req, reply) {        reply('Hello World');    }}).variant({    id: 'helloUniverse',    label: 'Hello Universe',    handler: function (req, reply) {        reply('Hello Universe');    }});",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 101/Introduction to Variants"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-101-introduction-to-mocking-ui": {
        "title": "Introduction to Mocking UI",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. Starting Mocking UITo start Mocking UI, after starting mock server navigate to http://localhost:8000/shifu on your favorite browser.2. Navigating through Mocking UITry to navigate through Mocking UI to get better undertstanding of its functions.",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 101/Introduction to Mocking UI"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-101-exercise": {
        "title": "Exercise",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. Create mock server with the followingAdd a GET route /get/message with default variant returning HelloAdd a variant that returns &quot;Hello World&quot;Add another variant that returns &quot;Hello Universe&quot;Add another GET route /get/numbers with default variant returning incremental values starting from 1Add a variant that returns even number starting from 2 in incrementsAdd another variant to return odd numbers starting from 1 in increments2. Start mock serverMake a REST call to /get/message and verify default variant returns 'Hello'Switch back and forth to other two variants and verify that you see 'Hello World' and 'Hello Universe' message respectively.Make a REST call to /get/numbers and verify default variant returns numbers in incremental orderSwitch back and forth to other two variants and verify that you see even and odd numbers in incremental order respectively.",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 101/Exercise"
      },
    
      "documentation-mocking-rweb-javascript-training-guide-mocking-101-adding-routes-for-mocking": {
        "title": "Adding Routes for Mocking",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. What REST APIs can be mocked?GETHEADPOSTPUTPATCHDELETEOPTIONS2. Add a route to be mocked in endpoints.jsshifu.route({  id: 'helloWorld',  label: 'Hello World',  path: '/helloWorld',  method: 'GET',  handler: function (req, reply) {    reply('Hello World');  }});Now start mock server and hit http://localhost:8000/helloWorld3. Understanding route parametersid: Unique route idlabel: Description of the routepath: Path of the routemethod: HTTP methodhandler: Function which handles the request for the path4. Adding multiple routes to be mockedshifu.route({  id: 'helloUniverse',  label: 'Hello Universe',  path: '/helloUniverse',  method: 'GET',  handler: function (req, reply) {    reply('Hello Universe');  }});Now start mock server and hit http://localhost:8000/helloUniverse",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Training Guide/Mocking 101/Adding Routes for Mocking"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-401-state": {
        "title": "State",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExercise1. What is state?State allows you to maintain state of your server, for example if a user is logged in or logged out. The mock server internally uses Hapi node server, which helps you return the state of the current application state. Within any response handler, use this.state('varName') to access an object stored in the state and this.state('varName', 'varValue') where varValue can be any type of object you want to set the state.2. How to set a state in mock server?shifu.route({  path: '/api/login',  label: 'LogIn',  method: 'POST',  handler: function(request, reply) {    // now you can use this.state('loggedIn') in any route handler to see if the user has logged in    this.state('loggedIn', true);    reply().code(204);  }});",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 401/State"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-401-starting-https-server-with-mock-server": {
        "title": "Starting HTTPS server with Mock Server",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExercise1. Updating run-mock-server-console.js to enable HTTPSrequire('./endpoints');var fs = require('fs');var shifu = require('shifu'); shifu.start({  host: &quot;localhost&quot;,    mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  httpsPort: 4444,  project: 'HelloShifu'});The default port for HTTPS is 44442. Starting mock server with HTTPS enabledOnce you add the above code, the mock server will provide the HTTPS and HTTPS support by default. Hence when the mock server starts up, you will see both the ports open. Note that the mock server auto generates the certificates (key.pem and cert.pem). If you want to provide your own key and certificate, you can provide it under the mocked data directory.",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 401/Starting HTTPS server with Mock Server"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-401-rest-apis": {
        "title": "Rest APIs",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExercise1. Set VariantMethod    : POSTSyntax    : {host}:{port}/_admin/api/route/{routeId}Rest API  : curl -H &quot;Content-Type: application/json&quot; -X POST -d '{&quot;variant&quot;:&quot;preorder&quot;}' http://localhost:8000/_admin/api/route/getCollection?returnConfig=trueshifu.route({    id: 'getCollection',    label: 'Get Collection',    path: '/product/grouping/api/collection/{collectionId}',     variantLabel: 'default',    handler: function(req, reply) {        var response = getResponseData('/product/grouping/api/collection', 'default');        reply(response);    }}).variant({    id: 'preorder',    label: 'Get Pre-order Collection',    handler: function (req, reply) {        reply({message: 'hello pre-order'});    }});To get the config back as a response, add query parameter returnConfig=true as shown in example above2. Set Mock IdMethod    : GETSyntax    : {host}:{port}/_admin/api/shifu/setMockId/{mockid}/{sessionid}Rest API  : curl http://localhost:8000/_admin/api/shifu/setMockId/1234/default3. Get Mock IdMethod    : GETSyntax    : {host}:{port}/_admin/api/shifu/getMockId/{sessionid}Rest API  : curl http://localhost:8000/_admin/api/shifu/getMockId/default4. Reset Mock IdMethod    : GETSyntax    : {host}:{port}/_admin/api/shifu/resetMockId/{sessionid}Rest API  : curl http://localhost:8000/_admin/api/shifu/resetMockId/default5. Get Url CountMethod    : GETSyntax    : {host}:{port}/_admin/api/shifu/getURLCount/{sessionid}Rest API  : curl http://localhost:8000/_admin/api/shifu/getURLCount/default6. Reset Url CountMethod    : GETSyntax    : {host}:{port}/_admin/api/shifu/resetURLCount/{sessionid}Rest API  : curl http://localhost:8000/_admin/api/shifu/resetURLCount/default7. Re-set the state of Mock ServerMethod    : POSTSyntax    : {host}:{port}/_admin/api/state/resetRest API  : curl -X POST http://localhost:8000/_admin/api/state/reset8. Register SessionMethod    : GETSyntax    : {host}:{port}/_admin/api/shifu/registerSessionRest API  : curl http://localhost:8000/_admin/api/shifu/registerSession9. Get SessionsMethod    : GETSyntax    : {host}:{port}/_admin/api/shifu/getSessionsRest API  : curl http://localhost:8000/_admin/api/shifu/getSessions10. Check SessionMethod    : GETSyntax    : {host}:{port}/_admin/api/shifu/checkSession/{sessionid}Rest API  : curl http://localhost:8000/_admin/api/shifu/checkSession/{sessionid}11. Close SessionMethod    : GETSyntax    : {host}:{port}/_admin/api/shifu/closeSession/{sessionid}Rest API  : curl http://localhost:8000/_admin/api/shifu/closeSession/{sessionid}",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 401/Rest APIs"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-401-mocking-utility-methods": {
        "title": "Mocking Utility Methods",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExercise1. RespondWithFile Utilityshifu.route({  id: 'message',  label: 'hello message',  path: '/message',   handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }})Setting Codeshifu.route({    id: 'message',    label: 'hello message',    path: '/message',    handler: function(req, reply) {        shifu.util.respondWithFile(this, reply, {code: 400});    }})Custom File Locationshifu.route({    id: 'message',    label: 'hello message',    path: '/message',    handler: function(req, reply) {        shifu.util.respondWithFile(this, reply, {code: 400, filePath: '../mocked-data/fileName.json'});    }})Setting Headersshifu.route({id: 'message',label: 'hello message',path: '/message',handler: function(req, reply) {    var myHeaders = {        header1: 'test1',        header2: 'test2',        header3: true    };    shifu.util.respondWithFile(this, reply, {code: 400, filePath: '../mocked-data/fileName.json', headers: myHeaders});}});Setting Cookiesshifu.route({id: 'message',label: 'hello message',path: '/message',handler: function(req, reply) {    var myHeaders = {        header1: 'test1',        header2: 'test2',        header3: true    };    var cookies = [        {name: 'com.wm.customer', value: 'vz7.0b5c56'},        {name: 'CID', value: 'SmockedCID', options: {domain: 'domain', path: '/'}},        {name: 'anotherCookie', value: 'cookieValue'}    ];    shifu.util.respondWithFile(this, reply, {code: 400, filePath: '../mocked-data/fileName.json', headers: myHeaders, cookies: cookies});}});Setting Delayshifu.route({    id: 'message',    label: 'hello message',    path: '/message',    handler: function(req, reply) {        var myHeaders = {            header1: 'test1',            header2: 'test2',            header3: true        };        var cookies = [            {name: 'com.wm.customer', value: 'vz7.0b5c56'},            {name: 'CID', value: 'SmockedCID', options: {domain: 'domain', path: '/'}},            {name: 'anotherCookie', value: 'cookieValue'}        ];        shifu.util.respondWithFile(this, reply, {code: 400, filePath: '../mocked-data/fileName.json', headers: myHeaders, cookies: cookies, delay: 1000});    }});Modifying Static JSON responseIf you have many variants for a REST end point and the mocked data for all variants can use the same JSON response with few changes to the values, than this feature is what you need. This feature allows you to dynamically change a JSON file before sending the response back from the mock server for the request. It removes the need of having one to one mapping of static JSON files with each variants.// Static Response JSON File{    &quot;id&quot;: &quot;1234&quot;,    &quot;name&quot;: &quot;toothpaste&quot;,    &quot;details&quot;: [        {            &quot;flavor&quot;: &quot;Mint 1&quot;,            &quot;Size&quot;: &quot;10&quot;,            &quot;Size_Type&quot;: &quot;ounce&quot;        },        {            &quot;flavor&quot;: &quot;Mint&quot;,            &quot;Size&quot;: &quot;10&quot;,            &quot;Size_Type&quot;: &quot;ounce&quot;        }    ]}// Sample code for substituting id from 1234 to 7777 and flavor from Mint to Mint 2 for second array element in routesshifu.route({    id: 'Get Collection',    label: 'Get Collections',    path: '/product/grouping/api/collection/{collectionId}',    handler: function(req, reply) {        var dataToChange = {            'id': '7777',            'details[1].flavor': 'Mint 2'        }        shifu.util.respondWithFile(this, reply, {transpose: dataToChange});     }});// Dynamic Response JSON File returned from Mock service{    &quot;id&quot;: &quot;7777&quot;,    &quot;name&quot;: &quot;toothpaste&quot;,    &quot;details&quot;: [        {            &quot;flavor&quot;: &quot;Mint 1&quot;,            &quot;Size&quot;: &quot;10&quot;,            &quot;Size_Type&quot;: &quot;ounce&quot;        },        {            &quot;flavor&quot;: &quot;Mint 2&quot;,            &quot;Size&quot;: &quot;10&quot;,            &quot;Size_Type&quot;: &quot;ounce&quot;        }    ]}2. Logging utilityShifu exposes a logging utility which can be used to log datashifu.log.debug('This is debug Message');shifu.log.info('This is info Message');shifu.log.error('This is error Message');shifu.log.warn('This is warn Message');shifu.log.setLogLevel('debug');shifu.log.getLogLevel();shifu.log.resetLogLevel();// default level is INFO3. Responding with a specific variant in handlers (respondWithMockVariant)This function will respond with a variant on the main route handler. The variant passed in MUST be the variant on existing route.shifu.util.respondWithMockVariant(this, 'variant', reply);The variant passed in MUST be the variant on existing route.shifu.route({    id: 'respondWithVariant',    label: 'Respond With Variant',    path: '/respondWithVariant',    variantLabel: 'Respond With Variant Main Route',    handler: function (req, reply) {        shifu.util.respondWithMockVariant(this, 'variant', reply); // make sure that the variant exist in the same route.    }}).variant({    id: 'variant',    label: 'Respond With Variant Variant Route',    handler: function (req, reply) {        reply({'message': 'I am an example of respond_with_mock_variant instead of response of main route '});    }});4. GetUrlCountTo get URL count for all Rest APIs mocked by mock serverShifu API : shifu.getURLCount(&quot;default&quot;);5. ResetUrlCountTo resets URL count to zeroShifu API : shifu.resetURLCount(&quot;default&quot;);",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 401/Mocking Utility Methods"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-401-exercise": {
        "title": "Exercise",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExerciseUpdate the previous mock server with the following:Add a logg-in route api/loginAdd a log-out route api/logoutAdd a state variable loggedIn and set true/false value based on the above APIs.Update the get/message default handler to return the message Hello: fname lname if user is logged in by reading from the query parameters otherwise  Hello: Guest is the customer Id is less than equal to 5 characters.Update the get/message Hello Universe variant to modify the file to following using transpose data based on if user is logged in or logged out- User Logged In{    message: fname lname}- User Logged Out{    message: Guest}Start mock serverHit get/message with customer id length &lt;=5 and see you should get Hello: GuestSet the variant to Hello UniverseHit get/message with customer id length &lt;=5 and see you should get message: GuestHit api/loginSet the variant to defaultHit http://localhost:8000/get/message/12345?fname=John&amp;lname=Doe with customer id length &lt;=5 and see you should get Hello: John Doe.Set the variant to Hello UniverseHit http://localhost:8000/get/message/12345?fname=John&amp;lname=Doe with customer id length &lt;=5 and see you should get message:John DoeHit api/logout and repeat 5 to 7.Create and install certificates to enable HTTPS in Shifu.Update run-mock-server-console.js to enable https in mock server.Start mock server and navigate to https://localhost:4444/_admin and repeat 5 to 12 steps.",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 401/Exercise"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-301-setmockid": {
        "title": "SetMockId",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExercise1. What is SetMockIdThis feature is very handy when you want to stub all the endpoints for a particular test without manually writing the paths for those endpoints. Generally applicable in scenarios where one page calls different endpoints according to test flows. You do not need to set variant or create variants for these endpoints. You will need to manually store the stubbed JSON files in the file structure location which are specified by your endpoints. The endpoints responses can be captured and stored under mocked data directory as a one time setup.2. How SetMockId works?ScenarioLets say your test case requires to mock two end points /api/message and /api/product/getStatus. These endpoints are called three times each. For the first end point you always want to return the same data (in json) while for the second endpoint you want to return the same data for the first and third call (in html) and a different data for the second call (in html).ImplementationCreate a folder under the mocked-data of your test directory (this folder name is configurable when you start your mock server by passing mockedDirectory option) by the name test1. Under this folder add the following files for your mocked response.api-message-GET.json - This will be returned for all the calls for the first endpoint with default response code 200api-product-getStatus-GET.html - This will be returned for all the calls for the second endpoint with default response code 200, except for the second and third call as it has its own fileapi-product-getStatus-GET-2.html - This will be returned for the second call for the second endpoint with default response code 200api-product-getStatus-GET-3-code-201.html - This will be returned for the third call for the second endpoint with response code 201Now set the setMockId either by mock api, UI or rest call to set to test1ExplanationThe underlying mock service automatically figures out the file extension so that you do not have to specify it. If you have the same file with multiple file extension than the following order is used:JSONHTMLTXTFirst file encountered of any other extensionOnce the shifu.setMockId(“test1”) API is called, Shifu only looks for the responses under the test1 folder. If it does not find the response, it will return 404 with the file name that it did not find. Shifu internally keeps track of the number of times each individual endpoint is called after client.setMockId(“test1”) API is called and first looks for the file with count specific name such as api-message-GET-1.json, if it does not find the said file then it looks for the default file which is api-message-GET.json.3. Good To KnowIf setMockId is set, then custom file path in handlershifu.util.respondWithFile(this, reply, {filePath: ‘./message/GET/default.json’});and file based on URL path ./mocked-data/api/message/get/default.json are ignored for the mocked response. Here is the order followed for file lookup:SetMockIdCustom File Path for default or variants endpoints.File based on URL Path for default or variants endpoints.SetMockId does not work with in-line Handlershifu.route({  id: 'message',  label: 'Message',  path: '/get/message/{customerid}',  method: 'GET',  variantLabel: 'Hello',  handler: function (req, reply) {    var lname = req.query.lname;    var fname = req.query.fname;    var customerid = req.params.customerid;    if (customerid.length &gt; 5) {      reply().code(400);    } else {      reply('Hello ' + fname + &quot; &quot; + lname);    }  }})",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 301/SetMockId"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-301-parallel-sessions": {
        "title": "Parallel Sessions",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExercise1. What is parallel sessions and why it's needed?Parallel sessions allows you to run multiple instance of server virtually while running only one server. This is helpful when you are running multiple test cases which access the same routes but different variants as parallel sessions allow you to set different variants on same routes without conflicting. This saves CPU and RAM both as only one server is running instead of multiple.2. How Parallel Sessions works internally?3. How to add parallel sessions?To add parallel sessions, modify run-mock-server-console.js to add 'sessions' parameter.require('./endpoints');var shifu = require('shifu');shifu.start({  host: &quot;localhost&quot;,  mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  sessions: 2,  project: 'HelloShifu'});You can also start or add sessions via command line argumentnode resources/run-mock-server-console.js --shifuSessions 2If you pass sessions = 2, there will be two parallel sessions along with one default session.4. Supported APIs for Parallel sessionsRegister SessionTo register sessions to be usedvar sessionId = shifu.registerSession();Get SessionsTo get all the active sessionsvar activeSessions = shifu.getSessions();Check SessionTo check the session status (Available or In-Use or invalid)var sessionStatus = shifu.checkSession(sessionId);Close SessionTo de-register session for later usevar closeSession = shifu.closeSession(sessionId);5. Using Parallel SessionsTo use a parallel session call the following api:curl http://localhost:8000/_admin/api/shifu/registerSessionorshifu.registerSession()and a session id will be returned.Append this sessionId to the mocked host address to use this parallel session. For ex: If your mock host server is http://localhost:8080 and your session id is 112233 then the mock server address for this parallel session will be http://localhost:8080/112233.6. Verifying parallel sessionsStart mock server with two sessions. Now go to the 'Message' route. You will see three routes for message, default and two for parallel sessions that you just added. Now for each route choose a different variant and hit the URL icon. You will see that each time you will get a different value though you are hitting the same route.7. Understanding the Shifu UI with sessionsTry to go through Shifu UI to understand sessions.",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 301/Parallel Sessions"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-301-exercise": {
        "title": "Exercise",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExerciseUpdate the previous mock server with the following:Update the Hello World variant of 'get/message' request toRemove the header parametersReturn the file as before by using RespondWithFile without handlerUpdate the default handler to return ONLY code 400 if the customer id is greater than 5 charactersStart mock server and test Step 1Now add data for setMockId for /get/message and /get/number routes.Return the following for URL hit count 1/get/message{    &quot;message&quot; : 1}/get/number{    &quot;number&quot; : 1}Return the following for URL hit count 2/get/message{    &quot;message&quot; : 2}/get/number{    &quot;number&quot; : 2}Return the following for default/get/message{    &quot;message&quot; : &quot;Undefined&quot;}/get/number{    &quot;number&quot; : &quot;Undefined&quot;}Call API to setMockId to the folder name via Shifu UIHit the rest endpoint /get/message and /get/number one time each and verify the response is &quot;message&quot; : 1 and &quot;number&quot; : 1 respectively.Hit the rest endpoint /get/message and /get/number once more and verify the response for second hit is &quot;message&quot; : 2 and &quot;number&quot; : 2 respectively.Hit the rest endpoint /get/message and /get/number one more time to verify that the response is &quot;message&quot; : &quot;undefined&quot; and &quot;number&quot; : &quot;undefined&quot; respectively.Call ResetMockId API via Shifu UIHit the rest endpoint /get/message and /get/number once each and verify the response is based on the handler and not on SetMockId - You may have to add appropriate file based on the route path.Update run-mock-server-console.js to add two parallel sessions to the server.Now call GetSessionId to register a session using Shifu UI.Now set Hello World and Hello Universe variant for get/message api for the two sessions Ids respectively.Now hit the server https://localhost:8000/sessionId/get/message for different session Ids and verify that you get different responses as per each variant.",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 301/Exercise"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-301-different-ways-of-returning-response-data": {
        "title": "Different ways of returning response data",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExercise1. Returning only the codeshifu.route({ id: 'message', label: 'hello message', path: '/message', handler: function(req, reply) {   reply().code(400); }})2. Using RespondWithFile without handlershifu.route({  path: '/api/customer/getId',  label: 'Get Customer Id',  method: 'GET', }).respondWithFile();3. Returning static mocked data with a response codeshifu.route({  id: 'message',  label: 'hello message',  path: '/message',   handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {code: 400});  }})",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 301/Different ways of returning response data"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-301-apis-for-setmockid": {
        "title": "APIs for SetMockId",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExercise1. SetMockIdshifu.setMockId(&quot;1234&quot;, &quot;default&quot;);2. GetMockIdshifu.getMockId(&quot;default&quot;);3. ResetMockIdshifu.resetMockId(&quot;default&quot;);",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 301/APIs for SetMockId"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-201-returning-response-from-a-file": {
        "title": "Returning Response from a File",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. What does it mean?This feature allows you to respond with a data stored in a file instead of hard coding the response data in the routes definition. This way user does not have to change the response rather can just swap the file with different data.2. How it works?shifu.route({  id: 'ResponseFromFile',  label: 'Response From File',  path: '/get/fromFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }});In the above setup, file needed for default route, which is /get/fromFile should be located at ./mocked-data/get/fromFile/GET/default.json3. What is mockedDirectory Path?Mocked directory path is the location to the base directory where all your mocked response file will be stored. This parameter is defined in run-mock-server-console.js file. It is defined at the start of mock server as shown in the code below:require('./endpoints-Shifu-201');require('shifu').start({  host: &quot;localhost&quot;,  mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  project: 'HelloShifu'});4. Automatic calculation of file locationThe path to the mocked data file is auto-calculated based on the route path. For variants, the name of the file should be changed from default to the variant name as shown below:shifu.route({  id: 'ResponseFromFile',  label: 'Response From File',  path: '/get/fromFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }}).variant({  id: 'textData',  label: 'Text Data',  handler: function (req, reply) {    shifu.util.respondWithFile(this, reply);  }})In the above example, mock server would look for ./resources/mocked-data/get/fromFile/GET/textData.txt file for the variant textData5. Providing custom path to the response fileA custom file path could also be provided for a mocked data file. to do so, use the following code:shifu.route({  id: 'CustomResponseFile',  label: 'Response From Custom Path',  path: '/get/customFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {filePath: './custom.json'});  }})Shifu will look for the file under MockedDirectory only but at ./resources/mocked-data/custom.json",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 201/Returning Response from a File"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-201-request-call-information": {
        "title": "Request Call Information",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. Query ParametersLet's say you go to the following URL: http://localhost:8000/get/customerInfo/12345?ctype=new . To read the query parameter, do the following:var ctype = req.query.ctype;To run the above scenario, hit the following in any browser with Shifu server running: http://localhost:8000/get/customerInfo/12345?ctype=new after updating the route toshifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}',  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    var id = req.params.customerid;    var ctype = req.query.ctype;    var replyString = 'Customer Type: ' + ctype + ' customer id: ' + id;    reply(replyString);  }});2. Header informationLet's say there is a header parameter 'name' with value 'John' is passed with the request. To read the testHeader parameter, do the following:var req = req.raw.req;var name = req.headers.name;To run the above scenario, use postman to make the following get call: http://localhost:8000/get/customerInfo/12345?ctype=new and add header 'name' with value 'John' after updating the route toshifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}',  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    var id = req.params.customerid;    var ctype = req.query.ctype;    var req = req.raw.req;    var name = req.headers.name;    var replyString = 'Customer Type: ' + ctype + ' customer id: ' + id + ' nameFromHeader: ' + name;    reply(replyString);  }});3. PayloadThe payload can be read using the following code://fname would be &quot;Bob&quot; if the posted body content (as JSON) was {&quot;fname&quot;: &quot;Bob&quot;}var fname = req.payload.fname;To run the above scenario, use postman to make the following POST call: http://localhost:8000/payload and add payload {&quot;fname&quot;: &quot;Bob&quot;} in the request.shifu.route({  id: 'payload',  label: 'Reading Payload',  path: '/payload',  method: 'POST',  variantLabel: 'Payload',  handler: function (req, reply) {    var fname = req.payload.fname;    reply(fname);  }});4. Content TypesThe mock module is independent of content-types i.e. user can set any content type and mocking route is intercepted only based on the path defined in the mocked routes file.",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 201/Request Call Information"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-201-exercise": {
        "title": "Exercise",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. Update the previous mock server with the followinga. Update the route /get/message to a dynamic URL which takes customer id as a parameter.b. Update the 'Hello World' variant to- return the following file with auto file location calculation.json { &quot;message&quot; : &quot;Hello World&quot; }- Set the following header params in response{ fname: John lname: Doe }Update the Hello Universe variantto return the following file and the file location should be hard coded.{    &quot;message&quot; : &quot;Hello Universe&quot;}Set the following cookie params in response{    customerId: 123456}Update the default handler to do the following:Add reading of query parameter 'fname' and 'lname' from the request.If the customer id is greater than 5 charactersreturn 'invalid id' as responseIf the customer id is less than or equal to 5 charactersreturn following response from the handler (NOT Using The File)Hello - fname lnameAdd a POST route /set/customerId and in default handler read the payload value and log it on console.{    &quot;customerid&quot;: 123456}2. Start mock serverMake a REST call to /get/message with customer id greater than 5 characters and check the response is Invalid IdMake a REST call to /get/message with customer id equal to 5 characters and check the response to be Hello undefined undefinedMake a REST call to http://localhost:8000/get/message/12345?fname=John&amp;lname=Doe and check the response to be Hello John DoeSwitch to Hello World variant and check the response is &quot;message&quot; : &quot;Hello World&quot; and use dev tools on Chrome browser to verify that the header params are set (fname: John and lname: Doe)Switch to Hello Universe variant and check the response is &quot;message&quot; : &quot;Hello Universe&quot; and use dev tools on Chrome browser to verify that the cookie is set (customerId: 123456)Make a post call to mock server at http://localhost:8000/set/customerId using Postman (or any other HTTP client) with the following data and verify that 12345 is logged on the console{ &quot;customerId&quot; : 12345}",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 201/Exercise"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-201-dynamic-urls": {
        "title": "Dynamic URLs",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. How to create dynamic urls/get/customerInfo/{customerid}/{zipcode}2. Adding a dynamic URL in mock servershifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}',  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    reply('How to read the customer id :(');  }});3. Reading dynamic URL parametersvar id = req.params.customerid;4. Using dynamic values to define responseshifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}',  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    var id = req.params.customerid;    reply('Customer id is ' + id + ' :)');  }});5. Passing dynamic URL parameters from the Shifu UITry to pass dynamic url parameters generated from Shifu UI",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 201/Dynamic URLs"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-201-customizing-mocked-response": {
        "title": "Customizing Mocked Response",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. Set custom headersshifu.route({  id: 'header',  label: 'Custom Headers',  path: '/set/headers',  handler: function(req, reply) {  reply({message: 'custom headers'})    .header('header1', 'test1')    .header('header2', 'test2')    .header('header3', 'test3')  }}) shifu.route({  id: 'header',  label: 'Custom Headers',  path: '/set/headers',  handler: function (req, reply) {    var myHeaders = {      header1: 'test1',      header2: 'test2',      header3: true    };    shifu.util.respondWithFile(this, reply, {headers: myHeaders});  }});2. Set custom cookiesshifu.route({  id: 'cookies',  label: 'Custom Cookies',  path: '/set/cookies',  handler: function(req, reply) {    reply({message: 'test'})    .state('cookie1', 'testCookie1')    .state('cookie2', 'testCookie2')    }}); shifu.route({  id: 'cookies',  label: 'Custom Cookies',  path: '/set/cookies',  handler: function (req, reply) {    var cookies = [      {name: 'cookie1', value: 'testCookie1'},      {name: 'cookie2', value: 'testCookie2'},    ];    shifu.util.respondWithFile(this, reply, {cookies: cookies});  }});3. Set CORS headersvar corsHeaders = {  origin: ['*'],  headers: [&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, X-Requested-With, Content-Type, Accept&quot;],  credentials: true,} // Itemsshifu.route({  id: 'corsheaders',  label: 'CORS',  path: '/set/cors',   config: {    cors: corsHeaders  },  handler: function(req, reply) {    reply('cors headers set');  }});",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 201/Customizing Mocked Response"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-101-setting-and-installing-mock-server": {
        "title": "Setting and Installing Mock Server",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. Pre-requisitesnode.js 4+ (npm is included in the package)2. Add mock dependency to package.json&quot;dependencies&quot;: {  &quot;shifu&quot;: &quot;^1.0.0&quot;}3. Add .npmrc file to the projectregistry=https://registry.npmjs.org/strict-ssl=false4. Install mock dependency with npm installRun npm install command to install mock related dependencies.5. Add resources/endpoints.js and create ./resources/mocked-data directory to store the mock data.require('./endpoints');require('shifu').start({  host: &quot;localhost&quot;,  mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  project: 'HelloShifu'});6. Add resources/run-mock-server-console.jsrequire('./endpoints');require('shifu').start({  host: &quot;localhost&quot;,  mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  project: 'HelloShifu'});Please note that you will need to replace HelloShifu for key project field with your project name(without dashes).7. Add script to start mock server in package.json&quot;scripts&quot;: {  &quot;lint&quot;: &quot;eslint . --ext .js&quot;,  &quot;start-server&quot;: &quot;node ./resources/run-mock-server-console.js&quot;},8. Test mock server can be startednpm run start-server",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 101/Setting and Installing Mock Server"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-101-introduction": {
        "title": "Introduction",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. What is Shifu?We provide a mocking solution which can be leveraged to quickly stub the REST API responses that are used by your application during development or testing. The application points to the mock service host address instead of the live service, pre-recorded responses are then returned for various endpoints from the mock service. Since there is minimal logic when writing mock service, maintaining and development cost for mock service is minimal. Some of the major development pain-points addressed by the mocking solution are:Unstable servicesInconsistent DataTest against negative or unreal scenarios2. Architectural Explanation3. High Level Key FeaturesUI Interface: Mock service UI for manual testing/debugging.Test Reuse: Execute same test cases against mock or live service.Drop-And-Respond: Respond with a mocked data file based on the url route path automatically by dropping mocked data file in folder mapping to url path.Response Reuse: Ability to use same json response file and change data dynamically for mocked response for various variants.Test De-coupling: No coupling with test cases - Test cases are independent of mock implementation except that setting the desired response for the mock service (which has no impact if the test case is run against a live service).Common Utilities: Common utility methods are provided as part of this solution which allows quicker test development.HTTPS Support: HTTPS support for all the urls.Magellan/Nightwatch integration: Ability to use mocking service with Magellan tests.Parallel sessions: Support for single instance mock server for parallel processesSwagger integration: Automatic mock creator for web-services with swagger definition.Server states: Ability to mock server state.4. Mock TerminologyRoutesVariantsHandlerSetMockIdAdmin UIRespondWithFile",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 101/Introduction"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-101-introduction-to-variants": {
        "title": "Introduction to Variants",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. What are variants?Variants allows to return a different data set for a given mocked route. Variants can be selected in the admin UI to determine what type of response a route should have. Routes are defined using the variant method on the Route object (returned by calling the route method). An object parameter is provided with the following attributesid: the variant id - used for the RESTful admin API and profile settingslabel: (optional) the variant label - used for display on the admin panelhandler: (optional) the HAPI route handler which provides the route responseVariants are useful because they allow you to test multiple scenarios that can happen with your route. Say, for example, you have a route exposing the ability to update a password. You might have several exceptional scenarios that you would want to test out (each could be a variant that you simply select to tell the route handler to use the appropriate response)the password was reset successfullythe password didn't pass validationthe old password wasn't entered correctlythe username doesn't existand so on...2. Default HandlerThe handler defined under route is the default handlershifu.route({    id: 'helloWorld',    label: 'Hello World',    path: '/helloWorld',    method: 'GET',    handler: function (req, reply) {        reply('Hello World');    }});3. Creating a variantshifu.route({    id: 'message',    label: 'Message',    path: '/get/message',    method: 'GET',    variantLabel: 'Hello',    handler: function (req, reply) {        reply('Hello');    }}).variant({    id: 'hello',    label: 'Hello World',    handler: function (req, reply) {        reply('Hello World');    }});4. Selecting a different variant to be returned from UIYou can select a different variant from admin UI to determine what type of response a route should have.5. Adding more variantsshifu.route({    id: 'message',    label: 'Message',    path: '/get/message',    method: 'GET',    variantLabel: 'Hello',    handler: function (req, reply) {        reply('Hello');    }}).variant({    id: 'hello',    label: 'Hello World',    handler: function (req, reply) {        reply('Hello World');    }}).variant({    id: 'helloUniverse',    label: 'Hello Universe',    handler: function (req, reply) {        reply('Hello Universe');    }});",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 101/Introduction to Variants"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-101-introduction-to-mocking-ui": {
        "title": "Introduction to Mocking UI",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. Starting Mocking UITo start Mocking UI, after starting mock server navigate to http://localhost:8000/shifu on your favorite browser.2. Navigating through Mocking UITry to navigate through Mocking UI to get better undertstanding of its functions.",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 101/Introduction to Mocking UI"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-101-exercise": {
        "title": "Exercise",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. Create mock server with the followingAdd a GET route /get/message with default variant returning HelloAdd a variant that returns &quot;Hello World&quot;Add another variant that returns &quot;Hello Universe&quot;Add another GET route /get/numbers with default variant returning incremental values starting from 1Add a variant that returns even number starting from 2 in incrementsAdd another variant to return odd numbers starting from 1 in increments2. Start mock serverMake a REST call to /get/message and verify default variant returns 'Hello'Switch back and forth to other two variants and verify that you see 'Hello World' and 'Hello Universe' message respectively.Make a REST call to /get/numbers and verify default variant returns numbers in incremental orderSwitch back and forth to other two variants and verify that you see even and odd numbers in incremental order respectively.",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 101/Exercise"
      },
    
      "documentation-mocking-services-javascript-training-guide-mocking-101-adding-routes-for-mocking": {
        "title": "Adding Routes for Mocking",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. What REST APIs can be mocked?GETHEADPOSTPUTPATCHDELETEOPTIONS2. Add a route to be mocked in endpoints.jsshifu.route({  id: 'helloWorld',  label: 'Hello World',  path: '/helloWorld',  method: 'GET',  handler: function (req, reply) {    reply('Hello World');  }});Now start mock server and hit http://localhost:8000/helloWorld3. Understanding route parametersid: Unique route idlabel: Description of the routepath: Path of the routemethod: HTTP methodhandler: Function which handles the request for the path4. Adding multiple routes to be mockedshifu.route({  id: 'helloUniverse',  label: 'Hello Universe',  path: '/helloUniverse',  method: 'GET',  handler: function (req, reply) {    reply('Hello Universe');  }});Now start mock server and hit http://localhost:8000/helloUniverse",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Training Guide/Mocking 101/Adding Routes for Mocking"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-401-state": {
        "title": "State",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExercise1. What is state?State allows you to maintain state of your server, for example if a user is logged in or logged out. The mock server internally uses Hapi node server, which helps you return the state of the current application state. Within any response handler, use this.state('varName') to access an object stored in the state and this.state('varName', 'varValue') where varValue can be any type of object you want to set the state.2. How to set a state in mock server?shifu.route({  path: '/api/login',  label: 'LogIn',  method: 'POST',  handler: function(request, reply) {    // now you can use this.state('loggedIn') in any route handler to see if the user has logged in    this.state('loggedIn', true);    reply().code(204);  }});",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 401/State"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-401-starting-https-server-with-mock-server": {
        "title": "Starting HTTPS server with Mock Server",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExercise1. Updating run-mock-server-console.js to enable HTTPSrequire('./endpoints');var fs = require('fs');var shifu = require('shifu'); shifu.start({  host: &quot;localhost&quot;,    mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  httpsPort: 4444,  project: 'HelloShifu'});The default port for HTTPS is 44442. Starting mock server with HTTPS enabledOnce you add the above code, the mock server will provide the HTTPS and HTTPS support by default. Hence when the mock server starts up, you will see both the ports open. Note that the mock server auto generates the certificates (key.pem and cert.pem). If you want to provide your own key and certificate, you can provide it under the mocked data directory.",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 401/Starting HTTPS server with Mock Server"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-401-rest-apis": {
        "title": "Rest APIs",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExercise1. Set VariantMethod    : POSTSyntax    : {host}:{port}/_admin/api/route/{routeId}Rest API  : curl -H &quot;Content-Type: application/json&quot; -X POST -d '{&quot;variant&quot;:&quot;preorder&quot;}' http://localhost:8000/_admin/api/route/getCollection?returnConfig=trueshifu.route({    id: 'getCollection',    label: 'Get Collection',    path: '/product/grouping/api/collection/{collectionId}',     variantLabel: 'default',    handler: function(req, reply) {        var response = getResponseData('/product/grouping/api/collection', 'default');        reply(response);    }}).variant({    id: 'preorder',    label: 'Get Pre-order Collection',    handler: function (req, reply) {        reply({message: 'hello pre-order'});    }});To get the config back as a response, add query parameter returnConfig=true as shown in example above2. Set Mock IdMethod    : GETSyntax    : {host}:{port}/_admin/api/shifu/setMockId/{mockid}/{sessionid}Rest API  : curl http://localhost:8000/_admin/api/shifu/setMockId/1234/default3. Get Mock IdMethod    : GETSyntax    : {host}:{port}/_admin/api/shifu/getMockId/{sessionid}Rest API  : curl http://localhost:8000/_admin/api/shifu/getMockId/default4. Reset Mock IdMethod    : GETSyntax    : {host}:{port}/_admin/api/shifu/resetMockId/{sessionid}Rest API  : curl http://localhost:8000/_admin/api/shifu/resetMockId/default5. Get Url CountMethod    : GETSyntax    : {host}:{port}/_admin/api/shifu/getURLCount/{sessionid}Rest API  : curl http://localhost:8000/_admin/api/shifu/getURLCount/default6. Reset Url CountMethod    : GETSyntax    : {host}:{port}/_admin/api/shifu/resetURLCount/{sessionid}Rest API  : curl http://localhost:8000/_admin/api/shifu/resetURLCount/default7. Re-set the state of Mock ServerMethod    : POSTSyntax    : {host}:{port}/_admin/api/state/resetRest API  : curl -X POST http://localhost:8000/_admin/api/state/reset8. Register SessionMethod    : GETSyntax    : {host}:{port}/_admin/api/shifu/registerSessionRest API  : curl http://localhost:8000/_admin/api/shifu/registerSession9. Get SessionsMethod    : GETSyntax    : {host}:{port}/_admin/api/shifu/getSessionsRest API  : curl http://localhost:8000/_admin/api/shifu/getSessions10. Check SessionMethod    : GETSyntax    : {host}:{port}/_admin/api/shifu/checkSession/{sessionid}Rest API  : curl http://localhost:8000/_admin/api/shifu/checkSession/{sessionid}11. Close SessionMethod    : GETSyntax    : {host}:{port}/_admin/api/shifu/closeSession/{sessionid}Rest API  : curl http://localhost:8000/_admin/api/shifu/closeSession/{sessionid}",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 401/Rest APIs"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-401-mocking-utility-methods": {
        "title": "Mocking Utility Methods",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExercise1. RespondWithFile Utilityshifu.route({  id: 'message',  label: 'hello message',  path: '/message',   handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }})Setting Codeshifu.route({    id: 'message',    label: 'hello message',    path: '/message',    handler: function(req, reply) {        shifu.util.respondWithFile(this, reply, {code: 400});    }})Custom File Locationshifu.route({    id: 'message',    label: 'hello message',    path: '/message',    handler: function(req, reply) {        shifu.util.respondWithFile(this, reply, {code: 400, filePath: '../mocked-data/fileName.json'});    }})Setting Headersshifu.route({id: 'message',label: 'hello message',path: '/message',handler: function(req, reply) {    var myHeaders = {        header1: 'test1',        header2: 'test2',        header3: true    };    shifu.util.respondWithFile(this, reply, {code: 400, filePath: '../mocked-data/fileName.json', headers: myHeaders});}});Setting Cookiesshifu.route({id: 'message',label: 'hello message',path: '/message',handler: function(req, reply) {    var myHeaders = {        header1: 'test1',        header2: 'test2',        header3: true    };    var cookies = [        {name: 'com.wm.customer', value: 'vz7.0b5c56'},        {name: 'CID', value: 'SmockedCID', options: {domain: 'domain', path: '/'}},        {name: 'anotherCookie', value: 'cookieValue'}    ];    shifu.util.respondWithFile(this, reply, {code: 400, filePath: '../mocked-data/fileName.json', headers: myHeaders, cookies: cookies});}});Setting Delayshifu.route({    id: 'message',    label: 'hello message',    path: '/message',    handler: function(req, reply) {        var myHeaders = {            header1: 'test1',            header2: 'test2',            header3: true        };        var cookies = [            {name: 'com.wm.customer', value: 'vz7.0b5c56'},            {name: 'CID', value: 'SmockedCID', options: {domain: 'domain', path: '/'}},            {name: 'anotherCookie', value: 'cookieValue'}        ];        shifu.util.respondWithFile(this, reply, {code: 400, filePath: '../mocked-data/fileName.json', headers: myHeaders, cookies: cookies, delay: 1000});    }});Modifying Static JSON responseIf you have many variants for a REST end point and the mocked data for all variants can use the same JSON response with few changes to the values, than this feature is what you need. This feature allows you to dynamically change a JSON file before sending the response back from the mock server for the request. It removes the need of having one to one mapping of static JSON files with each variants.// Static Response JSON File{    &quot;id&quot;: &quot;1234&quot;,    &quot;name&quot;: &quot;toothpaste&quot;,    &quot;details&quot;: [        {            &quot;flavor&quot;: &quot;Mint 1&quot;,            &quot;Size&quot;: &quot;10&quot;,            &quot;Size_Type&quot;: &quot;ounce&quot;        },        {            &quot;flavor&quot;: &quot;Mint&quot;,            &quot;Size&quot;: &quot;10&quot;,            &quot;Size_Type&quot;: &quot;ounce&quot;        }    ]}// Sample code for substituting id from 1234 to 7777 and flavor from Mint to Mint 2 for second array element in routesshifu.route({    id: 'Get Collection',    label: 'Get Collections',    path: '/product/grouping/api/collection/{collectionId}',    handler: function(req, reply) {        var dataToChange = {            'id': '7777',            'details[1].flavor': 'Mint 2'        }        shifu.util.respondWithFile(this, reply, {transpose: dataToChange});     }});// Dynamic Response JSON File returned from Mock service{    &quot;id&quot;: &quot;7777&quot;,    &quot;name&quot;: &quot;toothpaste&quot;,    &quot;details&quot;: [        {            &quot;flavor&quot;: &quot;Mint 1&quot;,            &quot;Size&quot;: &quot;10&quot;,            &quot;Size_Type&quot;: &quot;ounce&quot;        },        {            &quot;flavor&quot;: &quot;Mint 2&quot;,            &quot;Size&quot;: &quot;10&quot;,            &quot;Size_Type&quot;: &quot;ounce&quot;        }    ]}2. Logging utilityShifu exposes a logging utility which can be used to log datashifu.log.debug('This is debug Message');shifu.log.info('This is info Message');shifu.log.error('This is error Message');shifu.log.warn('This is warn Message');shifu.log.setLogLevel('debug');shifu.log.getLogLevel();shifu.log.resetLogLevel();// default level is INFO3. Responding with a specific variant in handlers (respondWithMockVariant)This function will respond with a variant on the main route handler. The variant passed in MUST be the variant on existing route.shifu.util.respondWithMockVariant(this, 'variant', reply);The variant passed in MUST be the variant on existing route.shifu.route({    id: 'respondWithVariant',    label: 'Respond With Variant',    path: '/respondWithVariant',    variantLabel: 'Respond With Variant Main Route',    handler: function (req, reply) {        shifu.util.respondWithMockVariant(this, 'variant', reply); // make sure that the variant exist in the same route.    }}).variant({    id: 'variant',    label: 'Respond With Variant Variant Route',    handler: function (req, reply) {        reply({'message': 'I am an example of respond_with_mock_variant instead of response of main route '});    }});4. GetUrlCountTo get URL count for all Rest APIs mocked by mock serverShifu API : shifu.getURLCount(&quot;default&quot;);5. ResetUrlCountTo resets URL count to zeroShifu API : shifu.resetURLCount(&quot;default&quot;);",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 401/Mocking Utility Methods"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-401-exercise": {
        "title": "Exercise",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExerciseUpdate the previous mock server with the following:Add a logg-in route api/loginAdd a log-out route api/logoutAdd a state variable loggedIn and set true/false value based on the above APIs.Update the get/message default handler to return the message Hello: fname lname if user is logged in by reading from the query parameters otherwise  Hello: Guest is the customer Id is less than equal to 5 characters.Update the get/message Hello Universe variant to modify the file to following using transpose data based on if user is logged in or logged out- User Logged In{    message: fname lname}- User Logged Out{    message: Guest}Start mock serverHit get/message with customer id length &lt;=5 and see you should get Hello: GuestSet the variant to Hello UniverseHit get/message with customer id length &lt;=5 and see you should get message: GuestHit api/loginSet the variant to defaultHit http://localhost:8000/get/message/12345?fname=John&amp;lname=Doe with customer id length &lt;=5 and see you should get Hello: John Doe.Set the variant to Hello UniverseHit http://localhost:8000/get/message/12345?fname=John&amp;lname=Doe with customer id length &lt;=5 and see you should get message:John DoeHit api/logout and repeat 5 to 7.Create and install certificates to enable HTTPS in Shifu.Update run-mock-server-console.js to enable https in mock server.Start mock server and navigate to https://localhost:4444/_admin and repeat 5 to 12 steps.",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 401/Exercise"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-301-setmockid": {
        "title": "SetMockId",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExercise1. What is SetMockIdThis feature is very handy when you want to stub all the endpoints for a particular test without manually writing the paths for those endpoints. Generally applicable in scenarios where one page calls different endpoints according to test flows. You do not need to set variant or create variants for these endpoints. You will need to manually store the stubbed JSON files in the file structure location which are specified by your endpoints. The endpoints responses can be captured and stored under mocked data directory as a one time setup.2. How SetMockId works?ScenarioLets say your test case requires to mock two end points /api/message and /api/product/getStatus. These endpoints are called three times each. For the first end point you always want to return the same data (in json) while for the second endpoint you want to return the same data for the first and third call (in html) and a different data for the second call (in html).ImplementationCreate a folder under the mocked-data of your test directory (this folder name is configurable when you start your mock server by passing mockedDirectory option) by the name test1. Under this folder add the following files for your mocked response.api-message-GET.json - This will be returned for all the calls for the first endpoint with default response code 200api-product-getStatus-GET.html - This will be returned for all the calls for the second endpoint with default response code 200, except for the second and third call as it has its own fileapi-product-getStatus-GET-2.html - This will be returned for the second call for the second endpoint with default response code 200api-product-getStatus-GET-3-code-201.html - This will be returned for the third call for the second endpoint with response code 201Now set the setMockId either by mock api, UI or rest call to set to test1ExplanationThe underlying mock service automatically figures out the file extension so that you do not have to specify it. If you have the same file with multiple file extension than the following order is used:JSONHTMLTXTFirst file encountered of any other extensionOnce the shifu.setMockId(“test1”) API is called, Shifu only looks for the responses under the test1 folder. If it does not find the response, it will return 404 with the file name that it did not find. Shifu internally keeps track of the number of times each individual endpoint is called after client.setMockId(“test1”) API is called and first looks for the file with count specific name such as api-message-GET-1.json, if it does not find the said file then it looks for the default file which is api-message-GET.json.3. Good To KnowIf setMockId is set, then custom file path in handlershifu.util.respondWithFile(this, reply, {filePath: ‘./message/GET/default.json’});and file based on URL path ./mocked-data/api/message/get/default.json are ignored for the mocked response. Here is the order followed for file lookup:SetMockIdCustom File Path for default or variants endpoints.File based on URL Path for default or variants endpoints.SetMockId does not work with in-line Handlershifu.route({  id: 'message',  label: 'Message',  path: '/get/message/{customerid}',  method: 'GET',  variantLabel: 'Hello',  handler: function (req, reply) {    var lname = req.query.lname;    var fname = req.query.fname;    var customerid = req.params.customerid;    if (customerid.length &gt; 5) {      reply().code(400);    } else {      reply('Hello ' + fname + &quot; &quot; + lname);    }  }})",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 301/SetMockId"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-301-parallel-sessions": {
        "title": "Parallel Sessions",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExercise1. What is parallel sessions and why it's needed?Parallel sessions allows you to run multiple instance of server virtually while running only one server. This is helpful when you are running multiple test cases which access the same routes but different variants as parallel sessions allow you to set different variants on same routes without conflicting. This saves CPU and RAM both as only one server is running instead of multiple.2. How Parallel Sessions works internally?3. How to add parallel sessions?To add parallel sessions, modify run-mock-server-console.js to add 'sessions' parameter.require('./endpoints');var shifu = require('shifu');shifu.start({  host: &quot;localhost&quot;,  mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  sessions: 2,  project: 'HelloShifu'});You can also start or add sessions via command line argumentnode resources/run-mock-server-console.js --shifuSessions 2If you pass sessions = 2, there will be two parallel sessions along with one default session.4. Supported APIs for Parallel sessionsRegister SessionTo register sessions to be usedvar sessionId = shifu.registerSession();Get SessionsTo get all the active sessionsvar activeSessions = shifu.getSessions();Check SessionTo check the session status (Available or In-Use or invalid)var sessionStatus = shifu.checkSession(sessionId);Close SessionTo de-register session for later usevar closeSession = shifu.closeSession(sessionId);5. Using Parallel SessionsTo use a parallel session call the following api:curl http://localhost:8000/_admin/api/shifu/registerSessionorshifu.registerSession()and a session id will be returned.Append this sessionId to the mocked host address to use this parallel session. For ex: If your mock host server is http://localhost:8080 and your session id is 112233 then the mock server address for this parallel session will be http://localhost:8080/112233.6. Verifying parallel sessionsStart mock server with two sessions. Now go to the 'Message' route. You will see three routes for message, default and two for parallel sessions that you just added. Now for each route choose a different variant and hit the URL icon. You will see that each time you will get a different value though you are hitting the same route.7. Understanding the Shifu UI with sessionsTry to go through Shifu UI to understand sessions.",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 301/Parallel Sessions"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-301-exercise": {
        "title": "Exercise",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExerciseUpdate the previous mock server with the following:Update the Hello World variant of 'get/message' request toRemove the header parametersReturn the file as before by using RespondWithFile without handlerUpdate the default handler to return ONLY code 400 if the customer id is greater than 5 charactersStart mock server and test Step 1Now add data for setMockId for /get/message and /get/number routes.Return the following for URL hit count 1/get/message{    &quot;message&quot; : 1}/get/number{    &quot;number&quot; : 1}Return the following for URL hit count 2/get/message{    &quot;message&quot; : 2}/get/number{    &quot;number&quot; : 2}Return the following for default/get/message{    &quot;message&quot; : &quot;Undefined&quot;}/get/number{    &quot;number&quot; : &quot;Undefined&quot;}Call API to setMockId to the folder name via Shifu UIHit the rest endpoint /get/message and /get/number one time each and verify the response is &quot;message&quot; : 1 and &quot;number&quot; : 1 respectively.Hit the rest endpoint /get/message and /get/number once more and verify the response for second hit is &quot;message&quot; : 2 and &quot;number&quot; : 2 respectively.Hit the rest endpoint /get/message and /get/number one more time to verify that the response is &quot;message&quot; : &quot;undefined&quot; and &quot;number&quot; : &quot;undefined&quot; respectively.Call ResetMockId API via Shifu UIHit the rest endpoint /get/message and /get/number once each and verify the response is based on the handler and not on SetMockId - You may have to add appropriate file based on the route path.Update run-mock-server-console.js to add two parallel sessions to the server.Now call GetSessionId to register a session using Shifu UI.Now set Hello World and Hello Universe variant for get/message api for the two sessions Ids respectively.Now hit the server https://localhost:8000/sessionId/get/message for different session Ids and verify that you get different responses as per each variant.",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 301/Exercise"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-301-different-ways-of-returning-response-data": {
        "title": "Different ways of returning response data",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExercise1. Returning only the codeshifu.route({ id: 'message', label: 'hello message', path: '/message', handler: function(req, reply) {   reply().code(400); }})2. Using RespondWithFile without handlershifu.route({  path: '/api/customer/getId',  label: 'Get Customer Id',  method: 'GET', }).respondWithFile();3. Returning static mocked data with a response codeshifu.route({  id: 'message',  label: 'hello message',  path: '/message',   handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {code: 400});  }})",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 301/Different ways of returning response data"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-301-apis-for-setmockid": {
        "title": "APIs for SetMockId",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExercise1. SetMockIdshifu.setMockId(&quot;1234&quot;, &quot;default&quot;);2. GetMockIdshifu.getMockId(&quot;default&quot;);3. ResetMockIdshifu.resetMockId(&quot;default&quot;);",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 301/APIs for SetMockId"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-201-returning-response-from-a-file": {
        "title": "Returning Response from a File",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. What does it mean?This feature allows you to respond with a data stored in a file instead of hard coding the response data in the routes definition. This way user does not have to change the response rather can just swap the file with different data.2. How it works?shifu.route({  id: 'ResponseFromFile',  label: 'Response From File',  path: '/get/fromFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }});In the above setup, file needed for default route, which is /get/fromFile should be located at ./mocked-data/get/fromFile/GET/default.json3. What is mockedDirectory Path?Mocked directory path is the location to the base directory where all your mocked response file will be stored. This parameter is defined in run-mock-server-console.js file. It is defined at the start of mock server as shown in the code below:require('./endpoints-Shifu-201');require('shifu').start({  host: &quot;localhost&quot;,  mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  project: 'HelloShifu'});4. Automatic calculation of file locationThe path to the mocked data file is auto-calculated based on the route path. For variants, the name of the file should be changed from default to the variant name as shown below:shifu.route({  id: 'ResponseFromFile',  label: 'Response From File',  path: '/get/fromFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }}).variant({  id: 'textData',  label: 'Text Data',  handler: function (req, reply) {    shifu.util.respondWithFile(this, reply);  }})In the above example, mock server would look for ./resources/mocked-data/get/fromFile/GET/textData.txt file for the variant textData5. Providing custom path to the response fileA custom file path could also be provided for a mocked data file. to do so, use the following code:shifu.route({  id: 'CustomResponseFile',  label: 'Response From Custom Path',  path: '/get/customFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {filePath: './custom.json'});  }})Shifu will look for the file under MockedDirectory only but at ./resources/mocked-data/custom.json",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 201/Returning Response from a File"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-201-request-call-information": {
        "title": "Request Call Information",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. Query ParametersLet's say you go to the following URL: http://localhost:8000/get/customerInfo/12345?ctype=new . To read the query parameter, do the following:var ctype = req.query.ctype;To run the above scenario, hit the following in any browser with Shifu server running: http://localhost:8000/get/customerInfo/12345?ctype=new after updating the route toshifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}',  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    var id = req.params.customerid;    var ctype = req.query.ctype;    var replyString = 'Customer Type: ' + ctype + ' customer id: ' + id;    reply(replyString);  }});2. Header informationLet's say there is a header parameter 'name' with value 'John' is passed with the request. To read the testHeader parameter, do the following:var req = req.raw.req;var name = req.headers.name;To run the above scenario, use postman to make the following get call: http://localhost:8000/get/customerInfo/12345?ctype=new and add header 'name' with value 'John' after updating the route toshifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}',  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    var id = req.params.customerid;    var ctype = req.query.ctype;    var req = req.raw.req;    var name = req.headers.name;    var replyString = 'Customer Type: ' + ctype + ' customer id: ' + id + ' nameFromHeader: ' + name;    reply(replyString);  }});3. PayloadThe payload can be read using the following code://fname would be &quot;Bob&quot; if the posted body content (as JSON) was {&quot;fname&quot;: &quot;Bob&quot;}var fname = req.payload.fname;To run the above scenario, use postman to make the following POST call: http://localhost:8000/payload and add payload {&quot;fname&quot;: &quot;Bob&quot;} in the request.shifu.route({  id: 'payload',  label: 'Reading Payload',  path: '/payload',  method: 'POST',  variantLabel: 'Payload',  handler: function (req, reply) {    var fname = req.payload.fname;    reply(fname);  }});4. Content TypesThe mock module is independent of content-types i.e. user can set any content type and mocking route is intercepted only based on the path defined in the mocked routes file.",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 201/Request Call Information"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-201-exercise": {
        "title": "Exercise",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. Update the previous mock server with the followinga. Update the route /get/message to a dynamic URL which takes customer id as a parameter.b. Update the 'Hello World' variant to- return the following file with auto file location calculation.json { &quot;message&quot; : &quot;Hello World&quot; }- Set the following header params in response{ fname: John lname: Doe }Update the Hello Universe variantto return the following file and the file location should be hard coded.{    &quot;message&quot; : &quot;Hello Universe&quot;}Set the following cookie params in response{    customerId: 123456}Update the default handler to do the following:Add reading of query parameter 'fname' and 'lname' from the request.If the customer id is greater than 5 charactersreturn 'invalid id' as responseIf the customer id is less than or equal to 5 charactersreturn following response from the handler (NOT Using The File)Hello - fname lnameAdd a POST route /set/customerId and in default handler read the payload value and log it on console.{    &quot;customerid&quot;: 123456}2. Start mock serverMake a REST call to /get/message with customer id greater than 5 characters and check the response is Invalid IdMake a REST call to /get/message with customer id equal to 5 characters and check the response to be Hello undefined undefinedMake a REST call to http://localhost:8000/get/message/12345?fname=John&amp;lname=Doe and check the response to be Hello John DoeSwitch to Hello World variant and check the response is &quot;message&quot; : &quot;Hello World&quot; and use dev tools on Chrome browser to verify that the header params are set (fname: John and lname: Doe)Switch to Hello Universe variant and check the response is &quot;message&quot; : &quot;Hello Universe&quot; and use dev tools on Chrome browser to verify that the cookie is set (customerId: 123456)Make a post call to mock server at http://localhost:8000/set/customerId using Postman (or any other HTTP client) with the following data and verify that 12345 is logged on the console{ &quot;customerId&quot; : 12345}",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 201/Exercise"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-201-dynamic-urls": {
        "title": "Dynamic URLs",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. How to create dynamic urls/get/customerInfo/{customerid}/{zipcode}2. Adding a dynamic URL in mock servershifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}',  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    reply('How to read the customer id :(');  }});3. Reading dynamic URL parametersvar id = req.params.customerid;4. Using dynamic values to define responseshifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}',  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    var id = req.params.customerid;    reply('Customer id is ' + id + ' :)');  }});5. Passing dynamic URL parameters from the Shifu UITry to pass dynamic url parameters generated from Shifu UI",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 201/Dynamic URLs"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-201-customizing-mocked-response": {
        "title": "Customizing Mocked Response",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. Set custom headersshifu.route({  id: 'header',  label: 'Custom Headers',  path: '/set/headers',  handler: function(req, reply) {  reply({message: 'custom headers'})    .header('header1', 'test1')    .header('header2', 'test2')    .header('header3', 'test3')  }}) shifu.route({  id: 'header',  label: 'Custom Headers',  path: '/set/headers',  handler: function (req, reply) {    var myHeaders = {      header1: 'test1',      header2: 'test2',      header3: true    };    shifu.util.respondWithFile(this, reply, {headers: myHeaders});  }});2. Set custom cookiesshifu.route({  id: 'cookies',  label: 'Custom Cookies',  path: '/set/cookies',  handler: function(req, reply) {    reply({message: 'test'})    .state('cookie1', 'testCookie1')    .state('cookie2', 'testCookie2')    }}); shifu.route({  id: 'cookies',  label: 'Custom Cookies',  path: '/set/cookies',  handler: function (req, reply) {    var cookies = [      {name: 'cookie1', value: 'testCookie1'},      {name: 'cookie2', value: 'testCookie2'},    ];    shifu.util.respondWithFile(this, reply, {cookies: cookies});  }});3. Set CORS headersvar corsHeaders = {  origin: ['*'],  headers: [&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, X-Requested-With, Content-Type, Accept&quot;],  credentials: true,} // Itemsshifu.route({  id: 'corsheaders',  label: 'CORS',  path: '/set/cors',   config: {    cors: corsHeaders  },  handler: function(req, reply) {    reply('cors headers set');  }});",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 201/Customizing Mocked Response"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-101-setting-and-installing-mock-server": {
        "title": "Setting and Installing Mock Server",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. Pre-requisitesnode.js 4+ (npm is included in the package)2. Add mock dependency to package.json&quot;dependencies&quot;: {  &quot;shifu&quot;: &quot;^1.0.0&quot;}3. Add .npmrc file to the projectregistry=https://registry.npmjs.org/strict-ssl=false4. Install mock dependency with npm installRun npm install command to install mock related dependencies.5. Add resources/endpoints.js and create ./resources/mocked-data directory to store the mock data.require('./endpoints');require('shifu').start({  host: &quot;localhost&quot;,  mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  project: 'HelloShifu'});6. Add resources/run-mock-server-console.jsrequire('./endpoints');require('shifu').start({  host: &quot;localhost&quot;,  mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  project: 'HelloShifu'});Please note that you will need to replace HelloShifu for key project field with your project name(without dashes).7. Add script to start mock server in package.json&quot;scripts&quot;: {  &quot;lint&quot;: &quot;eslint . --ext .js&quot;,  &quot;start-server&quot;: &quot;node ./resources/run-mock-server-console.js&quot;},8. Test mock server can be startednpm run start-server",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 101/Setting and Installing Mock Server"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-101-introduction": {
        "title": "Introduction",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. What is Shifu?We provide a mocking solution which can be leveraged to quickly stub the REST API responses that are used by your application during development or testing. The application points to the mock service host address instead of the live service, pre-recorded responses are then returned for various endpoints from the mock service. Since there is minimal logic when writing mock service, maintaining and development cost for mock service is minimal. Some of the major development pain-points addressed by the mocking solution are:Unstable servicesInconsistent DataTest against negative or unreal scenarios2. Architectural Explanation3. High Level Key FeaturesUI Interface: Mock service UI for manual testing/debugging.Test Reuse: Execute same test cases against mock or live service.Drop-And-Respond: Respond with a mocked data file based on the url route path automatically by dropping mocked data file in folder mapping to url path.Response Reuse: Ability to use same json response file and change data dynamically for mocked response for various variants.Test De-coupling: No coupling with test cases - Test cases are independent of mock implementation except that setting the desired response for the mock service (which has no impact if the test case is run against a live service).Common Utilities: Common utility methods are provided as part of this solution which allows quicker test development.HTTPS Support: HTTPS support for all the urls.Magellan/Nightwatch integration: Ability to use mocking service with Magellan tests.Parallel sessions: Support for single instance mock server for parallel processesSwagger integration: Automatic mock creator for web-services with swagger definition.Server states: Ability to mock server state.4. Mock TerminologyRoutesVariantsHandlerSetMockIdAdmin UIRespondWithFile",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 101/Introduction"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-101-introduction-to-variants": {
        "title": "Introduction to Variants",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. What are variants?Variants allows to return a different data set for a given mocked route. Variants can be selected in the admin UI to determine what type of response a route should have. Routes are defined using the variant method on the Route object (returned by calling the route method). An object parameter is provided with the following attributesid: the variant id - used for the RESTful admin API and profile settingslabel: (optional) the variant label - used for display on the admin panelhandler: (optional) the HAPI route handler which provides the route responseVariants are useful because they allow you to test multiple scenarios that can happen with your route. Say, for example, you have a route exposing the ability to update a password. You might have several exceptional scenarios that you would want to test out (each could be a variant that you simply select to tell the route handler to use the appropriate response)the password was reset successfullythe password didn't pass validationthe old password wasn't entered correctlythe username doesn't existand so on...2. Default HandlerThe handler defined under route is the default handlershifu.route({    id: 'helloWorld',    label: 'Hello World',    path: '/helloWorld',    method: 'GET',    handler: function (req, reply) {        reply('Hello World');    }});3. Creating a variantshifu.route({    id: 'message',    label: 'Message',    path: '/get/message',    method: 'GET',    variantLabel: 'Hello',    handler: function (req, reply) {        reply('Hello');    }}).variant({    id: 'hello',    label: 'Hello World',    handler: function (req, reply) {        reply('Hello World');    }});4. Selecting a different variant to be returned from UIYou can select a different variant from admin UI to determine what type of response a route should have.5. Adding more variantsshifu.route({    id: 'message',    label: 'Message',    path: '/get/message',    method: 'GET',    variantLabel: 'Hello',    handler: function (req, reply) {        reply('Hello');    }}).variant({    id: 'hello',    label: 'Hello World',    handler: function (req, reply) {        reply('Hello World');    }}).variant({    id: 'helloUniverse',    label: 'Hello Universe',    handler: function (req, reply) {        reply('Hello Universe');    }});",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 101/Introduction to Variants"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-101-introduction-to-mocking-ui": {
        "title": "Introduction to Mocking UI",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. Starting Mocking UITo start Mocking UI, after starting mock server navigate to http://localhost:8000/shifu on your favorite browser.2. Navigating through Mocking UITry to navigate through Mocking UI to get better undertstanding of its functions.",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 101/Introduction to Mocking UI"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-101-exercise": {
        "title": "Exercise",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. Create mock server with the followingAdd a GET route /get/message with default variant returning HelloAdd a variant that returns &quot;Hello World&quot;Add another variant that returns &quot;Hello Universe&quot;Add another GET route /get/numbers with default variant returning incremental values starting from 1Add a variant that returns even number starting from 2 in incrementsAdd another variant to return odd numbers starting from 1 in increments2. Start mock serverMake a REST call to /get/message and verify default variant returns 'Hello'Switch back and forth to other two variants and verify that you see 'Hello World' and 'Hello Universe' message respectively.Make a REST call to /get/numbers and verify default variant returns numbers in incremental orderSwitch back and forth to other two variants and verify that you see even and odd numbers in incremental order respectively.",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 101/Exercise"
      },
    
      "documentation-mocking-native-ios-javascript-training-guide-mocking-101-adding-routes-for-mocking": {
        "title": "Adding Routes for Mocking",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. What REST APIs can be mocked?GETHEADPOSTPUTPATCHDELETEOPTIONS2. Add a route to be mocked in endpoints.jsshifu.route({  id: 'helloWorld',  label: 'Hello World',  path: '/helloWorld',  method: 'GET',  handler: function (req, reply) {    reply('Hello World');  }});Now start mock server and hit http://localhost:8000/helloWorld3. Understanding route parametersid: Unique route idlabel: Description of the routepath: Path of the routemethod: HTTP methodhandler: Function which handles the request for the path4. Adding multiple routes to be mockedshifu.route({  id: 'helloUniverse',  label: 'Hello Universe',  path: '/helloUniverse',  method: 'GET',  handler: function (req, reply) {    reply('Hello Universe');  }});Now start mock server and hit http://localhost:8000/helloUniverse",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Training Guide/Mocking 101/Adding Routes for Mocking"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-401-state": {
        "title": "State",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExercise1. What is state?State allows you to maintain state of your server, for example if a user is logged in or logged out. The mock server internally uses Hapi node server, which helps you return the state of the current application state. Within any response handler, use this.state('varName') to access an object stored in the state and this.state('varName', 'varValue') where varValue can be any type of object you want to set the state.2. How to set a state in mock server?shifu.route({  path: '/api/login',  label: 'LogIn',  method: 'POST',  handler: function(request, reply) {    // now you can use this.state('loggedIn') in any route handler to see if the user has logged in    this.state('loggedIn', true);    reply().code(204);  }});",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 401/State"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-401-starting-https-server-with-mock-server": {
        "title": "Starting HTTPS server with Mock Server",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExercise1. Updating run-mock-server-console.js to enable HTTPSrequire('./endpoints');var fs = require('fs');var shifu = require('shifu'); shifu.start({  host: &quot;localhost&quot;,    mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  httpsPort: 4444,  project: 'HelloShifu'});The default port for HTTPS is 44442. Starting mock server with HTTPS enabledOnce you add the above code, the mock server will provide the HTTPS and HTTPS support by default. Hence when the mock server starts up, you will see both the ports open. Note that the mock server auto generates the certificates (key.pem and cert.pem). If you want to provide your own key and certificate, you can provide it under the mocked data directory.",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 401/Starting HTTPS server with Mock Server"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-401-rest-apis": {
        "title": "Rest APIs",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExercise1. Set VariantMethod    : POSTSyntax    : {host}:{port}/_admin/api/route/{routeId}Rest API  : curl -H &quot;Content-Type: application/json&quot; -X POST -d '{&quot;variant&quot;:&quot;preorder&quot;}' http://localhost:8000/_admin/api/route/getCollection?returnConfig=trueshifu.route({    id: 'getCollection',    label: 'Get Collection',    path: '/product/grouping/api/collection/{collectionId}',     variantLabel: 'default',    handler: function(req, reply) {        var response = getResponseData('/product/grouping/api/collection', 'default');        reply(response);    }}).variant({    id: 'preorder',    label: 'Get Pre-order Collection',    handler: function (req, reply) {        reply({message: 'hello pre-order'});    }});To get the config back as a response, add query parameter returnConfig=true as shown in example above2. Set Mock IdMethod    : GETSyntax    : {host}:{port}/_admin/api/shifu/setMockId/{mockid}/{sessionid}Rest API  : curl http://localhost:8000/_admin/api/shifu/setMockId/1234/default3. Get Mock IdMethod    : GETSyntax    : {host}:{port}/_admin/api/shifu/getMockId/{sessionid}Rest API  : curl http://localhost:8000/_admin/api/shifu/getMockId/default4. Reset Mock IdMethod    : GETSyntax    : {host}:{port}/_admin/api/shifu/resetMockId/{sessionid}Rest API  : curl http://localhost:8000/_admin/api/shifu/resetMockId/default5. Get Url CountMethod    : GETSyntax    : {host}:{port}/_admin/api/shifu/getURLCount/{sessionid}Rest API  : curl http://localhost:8000/_admin/api/shifu/getURLCount/default6. Reset Url CountMethod    : GETSyntax    : {host}:{port}/_admin/api/shifu/resetURLCount/{sessionid}Rest API  : curl http://localhost:8000/_admin/api/shifu/resetURLCount/default7. Re-set the state of Mock ServerMethod    : POSTSyntax    : {host}:{port}/_admin/api/state/resetRest API  : curl -X POST http://localhost:8000/_admin/api/state/reset8. Register SessionMethod    : GETSyntax    : {host}:{port}/_admin/api/shifu/registerSessionRest API  : curl http://localhost:8000/_admin/api/shifu/registerSession9. Get SessionsMethod    : GETSyntax    : {host}:{port}/_admin/api/shifu/getSessionsRest API  : curl http://localhost:8000/_admin/api/shifu/getSessions10. Check SessionMethod    : GETSyntax    : {host}:{port}/_admin/api/shifu/checkSession/{sessionid}Rest API  : curl http://localhost:8000/_admin/api/shifu/checkSession/{sessionid}11. Close SessionMethod    : GETSyntax    : {host}:{port}/_admin/api/shifu/closeSession/{sessionid}Rest API  : curl http://localhost:8000/_admin/api/shifu/closeSession/{sessionid}",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 401/Rest APIs"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-401-mocking-utility-methods": {
        "title": "Mocking Utility Methods",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExercise1. RespondWithFile Utilityshifu.route({  id: 'message',  label: 'hello message',  path: '/message',   handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }})Setting Codeshifu.route({    id: 'message',    label: 'hello message',    path: '/message',    handler: function(req, reply) {        shifu.util.respondWithFile(this, reply, {code: 400});    }})Custom File Locationshifu.route({    id: 'message',    label: 'hello message',    path: '/message',    handler: function(req, reply) {        shifu.util.respondWithFile(this, reply, {code: 400, filePath: '../mocked-data/fileName.json'});    }})Setting Headersshifu.route({id: 'message',label: 'hello message',path: '/message',handler: function(req, reply) {    var myHeaders = {        header1: 'test1',        header2: 'test2',        header3: true    };    shifu.util.respondWithFile(this, reply, {code: 400, filePath: '../mocked-data/fileName.json', headers: myHeaders});}});Setting Cookiesshifu.route({id: 'message',label: 'hello message',path: '/message',handler: function(req, reply) {    var myHeaders = {        header1: 'test1',        header2: 'test2',        header3: true    };    var cookies = [        {name: 'com.wm.customer', value: 'vz7.0b5c56'},        {name: 'CID', value: 'SmockedCID', options: {domain: 'domain', path: '/'}},        {name: 'anotherCookie', value: 'cookieValue'}    ];    shifu.util.respondWithFile(this, reply, {code: 400, filePath: '../mocked-data/fileName.json', headers: myHeaders, cookies: cookies});}});Setting Delayshifu.route({    id: 'message',    label: 'hello message',    path: '/message',    handler: function(req, reply) {        var myHeaders = {            header1: 'test1',            header2: 'test2',            header3: true        };        var cookies = [            {name: 'com.wm.customer', value: 'vz7.0b5c56'},            {name: 'CID', value: 'SmockedCID', options: {domain: 'domain', path: '/'}},            {name: 'anotherCookie', value: 'cookieValue'}        ];        shifu.util.respondWithFile(this, reply, {code: 400, filePath: '../mocked-data/fileName.json', headers: myHeaders, cookies: cookies, delay: 1000});    }});Modifying Static JSON responseIf you have many variants for a REST end point and the mocked data for all variants can use the same JSON response with few changes to the values, than this feature is what you need. This feature allows you to dynamically change a JSON file before sending the response back from the mock server for the request. It removes the need of having one to one mapping of static JSON files with each variants.// Static Response JSON File{    &quot;id&quot;: &quot;1234&quot;,    &quot;name&quot;: &quot;toothpaste&quot;,    &quot;details&quot;: [        {            &quot;flavor&quot;: &quot;Mint 1&quot;,            &quot;Size&quot;: &quot;10&quot;,            &quot;Size_Type&quot;: &quot;ounce&quot;        },        {            &quot;flavor&quot;: &quot;Mint&quot;,            &quot;Size&quot;: &quot;10&quot;,            &quot;Size_Type&quot;: &quot;ounce&quot;        }    ]}// Sample code for substituting id from 1234 to 7777 and flavor from Mint to Mint 2 for second array element in routesshifu.route({    id: 'Get Collection',    label: 'Get Collections',    path: '/product/grouping/api/collection/{collectionId}',    handler: function(req, reply) {        var dataToChange = {            'id': '7777',            'details[1].flavor': 'Mint 2'        }        shifu.util.respondWithFile(this, reply, {transpose: dataToChange});     }});// Dynamic Response JSON File returned from Mock service{    &quot;id&quot;: &quot;7777&quot;,    &quot;name&quot;: &quot;toothpaste&quot;,    &quot;details&quot;: [        {            &quot;flavor&quot;: &quot;Mint 1&quot;,            &quot;Size&quot;: &quot;10&quot;,            &quot;Size_Type&quot;: &quot;ounce&quot;        },        {            &quot;flavor&quot;: &quot;Mint 2&quot;,            &quot;Size&quot;: &quot;10&quot;,            &quot;Size_Type&quot;: &quot;ounce&quot;        }    ]}2. Logging utilityShifu exposes a logging utility which can be used to log datashifu.log.debug('This is debug Message');shifu.log.info('This is info Message');shifu.log.error('This is error Message');shifu.log.warn('This is warn Message');shifu.log.setLogLevel('debug');shifu.log.getLogLevel();shifu.log.resetLogLevel();// default level is INFO3. Responding with a specific variant in handlers (respondWithMockVariant)This function will respond with a variant on the main route handler. The variant passed in MUST be the variant on existing route.shifu.util.respondWithMockVariant(this, 'variant', reply);The variant passed in MUST be the variant on existing route.shifu.route({    id: 'respondWithVariant',    label: 'Respond With Variant',    path: '/respondWithVariant',    variantLabel: 'Respond With Variant Main Route',    handler: function (req, reply) {        shifu.util.respondWithMockVariant(this, 'variant', reply); // make sure that the variant exist in the same route.    }}).variant({    id: 'variant',    label: 'Respond With Variant Variant Route',    handler: function (req, reply) {        reply({'message': 'I am an example of respond_with_mock_variant instead of response of main route '});    }});4. GetUrlCountTo get URL count for all Rest APIs mocked by mock serverShifu API : shifu.getURLCount(&quot;default&quot;);5. ResetUrlCountTo resets URL count to zeroShifu API : shifu.resetURLCount(&quot;default&quot;);",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 401/Mocking Utility Methods"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-401-exercise": {
        "title": "Exercise",
        "content": "StateMocking Utility MethodsRest APIsStarting HTTPS server with Mock ServerExerciseUpdate the previous mock server with the following:Add a logg-in route api/loginAdd a log-out route api/logoutAdd a state variable loggedIn and set true/false value based on the above APIs.Update the get/message default handler to return the message Hello: fname lname if user is logged in by reading from the query parameters otherwise  Hello: Guest is the customer Id is less than equal to 5 characters.Update the get/message Hello Universe variant to modify the file to following using transpose data based on if user is logged in or logged out- User Logged In{    message: fname lname}- User Logged Out{    message: Guest}Start mock serverHit get/message with customer id length &lt;=5 and see you should get Hello: GuestSet the variant to Hello UniverseHit get/message with customer id length &lt;=5 and see you should get message: GuestHit api/loginSet the variant to defaultHit http://localhost:8000/get/message/12345?fname=John&amp;lname=Doe with customer id length &lt;=5 and see you should get Hello: John Doe.Set the variant to Hello UniverseHit http://localhost:8000/get/message/12345?fname=John&amp;lname=Doe with customer id length &lt;=5 and see you should get message:John DoeHit api/logout and repeat 5 to 7.Create and install certificates to enable HTTPS in Shifu.Update run-mock-server-console.js to enable https in mock server.Start mock server and navigate to https://localhost:4444/_admin and repeat 5 to 12 steps.",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 401/Exercise"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-301-setmockid": {
        "title": "SetMockId",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExercise1. What is SetMockIdThis feature is very handy when you want to stub all the endpoints for a particular test without manually writing the paths for those endpoints. Generally applicable in scenarios where one page calls different endpoints according to test flows. You do not need to set variant or create variants for these endpoints. You will need to manually store the stubbed JSON files in the file structure location which are specified by your endpoints. The endpoints responses can be captured and stored under mocked data directory as a one time setup.2. How SetMockId works?ScenarioLets say your test case requires to mock two end points /api/message and /api/product/getStatus. These endpoints are called three times each. For the first end point you always want to return the same data (in json) while for the second endpoint you want to return the same data for the first and third call (in html) and a different data for the second call (in html).ImplementationCreate a folder under the mocked-data of your test directory (this folder name is configurable when you start your mock server by passing mockedDirectory option) by the name test1. Under this folder add the following files for your mocked response.api-message-GET.json - This will be returned for all the calls for the first endpoint with default response code 200api-product-getStatus-GET.html - This will be returned for all the calls for the second endpoint with default response code 200, except for the second and third call as it has its own fileapi-product-getStatus-GET-2.html - This will be returned for the second call for the second endpoint with default response code 200api-product-getStatus-GET-3-code-201.html - This will be returned for the third call for the second endpoint with response code 201Now set the setMockId either by mock api, UI or rest call to set to test1ExplanationThe underlying mock service automatically figures out the file extension so that you do not have to specify it. If you have the same file with multiple file extension than the following order is used:JSONHTMLTXTFirst file encountered of any other extensionOnce the shifu.setMockId(“test1”) API is called, Shifu only looks for the responses under the test1 folder. If it does not find the response, it will return 404 with the file name that it did not find. Shifu internally keeps track of the number of times each individual endpoint is called after client.setMockId(“test1”) API is called and first looks for the file with count specific name such as api-message-GET-1.json, if it does not find the said file then it looks for the default file which is api-message-GET.json.3. Good To KnowIf setMockId is set, then custom file path in handlershifu.util.respondWithFile(this, reply, {filePath: ‘./message/GET/default.json’});and file based on URL path ./mocked-data/api/message/get/default.json are ignored for the mocked response. Here is the order followed for file lookup:SetMockIdCustom File Path for default or variants endpoints.File based on URL Path for default or variants endpoints.SetMockId does not work with in-line Handlershifu.route({  id: 'message',  label: 'Message',  path: '/get/message/{customerid}',  method: 'GET',  variantLabel: 'Hello',  handler: function (req, reply) {    var lname = req.query.lname;    var fname = req.query.fname;    var customerid = req.params.customerid;    if (customerid.length &gt; 5) {      reply().code(400);    } else {      reply('Hello ' + fname + &quot; &quot; + lname);    }  }})",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 301/SetMockId"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-301-parallel-sessions": {
        "title": "Parallel Sessions",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExercise1. What is parallel sessions and why it's needed?Parallel sessions allows you to run multiple instance of server virtually while running only one server. This is helpful when you are running multiple test cases which access the same routes but different variants as parallel sessions allow you to set different variants on same routes without conflicting. This saves CPU and RAM both as only one server is running instead of multiple.2. How Parallel Sessions works internally?3. How to add parallel sessions?To add parallel sessions, modify run-mock-server-console.js to add 'sessions' parameter.require('./endpoints');var shifu = require('shifu');shifu.start({  host: &quot;localhost&quot;,  mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  sessions: 2,  project: 'HelloShifu'});You can also start or add sessions via command line argumentnode resources/run-mock-server-console.js --shifuSessions 2If you pass sessions = 2, there will be two parallel sessions along with one default session.4. Supported APIs for Parallel sessionsRegister SessionTo register sessions to be usedvar sessionId = shifu.registerSession();Get SessionsTo get all the active sessionsvar activeSessions = shifu.getSessions();Check SessionTo check the session status (Available or In-Use or invalid)var sessionStatus = shifu.checkSession(sessionId);Close SessionTo de-register session for later usevar closeSession = shifu.closeSession(sessionId);5. Using Parallel SessionsTo use a parallel session call the following api:curl http://localhost:8000/_admin/api/shifu/registerSessionorshifu.registerSession()and a session id will be returned.Append this sessionId to the mocked host address to use this parallel session. For ex: If your mock host server is http://localhost:8080 and your session id is 112233 then the mock server address for this parallel session will be http://localhost:8080/112233.6. Verifying parallel sessionsStart mock server with two sessions. Now go to the 'Message' route. You will see three routes for message, default and two for parallel sessions that you just added. Now for each route choose a different variant and hit the URL icon. You will see that each time you will get a different value though you are hitting the same route.7. Understanding the Shifu UI with sessionsTry to go through Shifu UI to understand sessions.",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 301/Parallel Sessions"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-301-exercise": {
        "title": "Exercise",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExerciseUpdate the previous mock server with the following:Update the Hello World variant of 'get/message' request toRemove the header parametersReturn the file as before by using RespondWithFile without handlerUpdate the default handler to return ONLY code 400 if the customer id is greater than 5 charactersStart mock server and test Step 1Now add data for setMockId for /get/message and /get/number routes.Return the following for URL hit count 1/get/message{    &quot;message&quot; : 1}/get/number{    &quot;number&quot; : 1}Return the following for URL hit count 2/get/message{    &quot;message&quot; : 2}/get/number{    &quot;number&quot; : 2}Return the following for default/get/message{    &quot;message&quot; : &quot;Undefined&quot;}/get/number{    &quot;number&quot; : &quot;Undefined&quot;}Call API to setMockId to the folder name via Shifu UIHit the rest endpoint /get/message and /get/number one time each and verify the response is &quot;message&quot; : 1 and &quot;number&quot; : 1 respectively.Hit the rest endpoint /get/message and /get/number once more and verify the response for second hit is &quot;message&quot; : 2 and &quot;number&quot; : 2 respectively.Hit the rest endpoint /get/message and /get/number one more time to verify that the response is &quot;message&quot; : &quot;undefined&quot; and &quot;number&quot; : &quot;undefined&quot; respectively.Call ResetMockId API via Shifu UIHit the rest endpoint /get/message and /get/number once each and verify the response is based on the handler and not on SetMockId - You may have to add appropriate file based on the route path.Update run-mock-server-console.js to add two parallel sessions to the server.Now call GetSessionId to register a session using Shifu UI.Now set Hello World and Hello Universe variant for get/message api for the two sessions Ids respectively.Now hit the server https://localhost:8000/sessionId/get/message for different session Ids and verify that you get different responses as per each variant.",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 301/Exercise"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-301-different-ways-of-returning-response-data": {
        "title": "Different ways of returning response data",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExercise1. Returning only the codeshifu.route({ id: 'message', label: 'hello message', path: '/message', handler: function(req, reply) {   reply().code(400); }})2. Using RespondWithFile without handlershifu.route({  path: '/api/customer/getId',  label: 'Get Customer Id',  method: 'GET', }).respondWithFile();3. Returning static mocked data with a response codeshifu.route({  id: 'message',  label: 'hello message',  path: '/message',   handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {code: 400});  }})",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 301/Different ways of returning response data"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-301-apis-for-setmockid": {
        "title": "APIs for SetMockId",
        "content": "Different ways of returning response dataSetMockIdAPIs for SetMockIdParallel SessionsExercise1. SetMockIdshifu.setMockId(&quot;1234&quot;, &quot;default&quot;);2. GetMockIdshifu.getMockId(&quot;default&quot;);3. ResetMockIdshifu.resetMockId(&quot;default&quot;);",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 301/APIs for SetMockId"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-201-returning-response-from-a-file": {
        "title": "Returning Response from a File",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. What does it mean?This feature allows you to respond with a data stored in a file instead of hard coding the response data in the routes definition. This way user does not have to change the response rather can just swap the file with different data.2. How it works?shifu.route({  id: 'ResponseFromFile',  label: 'Response From File',  path: '/get/fromFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }});In the above setup, file needed for default route, which is /get/fromFile should be located at ./mocked-data/get/fromFile/GET/default.json3. What is mockedDirectory Path?Mocked directory path is the location to the base directory where all your mocked response file will be stored. This parameter is defined in run-mock-server-console.js file. It is defined at the start of mock server as shown in the code below:require('./endpoints-Shifu-201');require('shifu').start({  host: &quot;localhost&quot;,  mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  project: 'HelloShifu'});4. Automatic calculation of file locationThe path to the mocked data file is auto-calculated based on the route path. For variants, the name of the file should be changed from default to the variant name as shown below:shifu.route({  id: 'ResponseFromFile',  label: 'Response From File',  path: '/get/fromFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }}).variant({  id: 'textData',  label: 'Text Data',  handler: function (req, reply) {    shifu.util.respondWithFile(this, reply);  }})In the above example, mock server would look for ./resources/mocked-data/get/fromFile/GET/textData.txt file for the variant textData5. Providing custom path to the response fileA custom file path could also be provided for a mocked data file. to do so, use the following code:shifu.route({  id: 'CustomResponseFile',  label: 'Response From Custom Path',  path: '/get/customFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {filePath: './custom.json'});  }})Shifu will look for the file under MockedDirectory only but at ./resources/mocked-data/custom.json",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 201/Returning Response from a File"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-201-request-call-information": {
        "title": "Request Call Information",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. Query ParametersLet's say you go to the following URL: http://localhost:8000/get/customerInfo/12345?ctype=new . To read the query parameter, do the following:var ctype = req.query.ctype;To run the above scenario, hit the following in any browser with Shifu server running: http://localhost:8000/get/customerInfo/12345?ctype=new after updating the route toshifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}',  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    var id = req.params.customerid;    var ctype = req.query.ctype;    var replyString = 'Customer Type: ' + ctype + ' customer id: ' + id;    reply(replyString);  }});2. Header informationLet's say there is a header parameter 'name' with value 'John' is passed with the request. To read the testHeader parameter, do the following:var req = req.raw.req;var name = req.headers.name;To run the above scenario, use postman to make the following get call: http://localhost:8000/get/customerInfo/12345?ctype=new and add header 'name' with value 'John' after updating the route toshifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}',  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    var id = req.params.customerid;    var ctype = req.query.ctype;    var req = req.raw.req;    var name = req.headers.name;    var replyString = 'Customer Type: ' + ctype + ' customer id: ' + id + ' nameFromHeader: ' + name;    reply(replyString);  }});3. PayloadThe payload can be read using the following code://fname would be &quot;Bob&quot; if the posted body content (as JSON) was {&quot;fname&quot;: &quot;Bob&quot;}var fname = req.payload.fname;To run the above scenario, use postman to make the following POST call: http://localhost:8000/payload and add payload {&quot;fname&quot;: &quot;Bob&quot;} in the request.shifu.route({  id: 'payload',  label: 'Reading Payload',  path: '/payload',  method: 'POST',  variantLabel: 'Payload',  handler: function (req, reply) {    var fname = req.payload.fname;    reply(fname);  }});4. Content TypesThe mock module is independent of content-types i.e. user can set any content type and mocking route is intercepted only based on the path defined in the mocked routes file.",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 201/Request Call Information"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-201-exercise": {
        "title": "Exercise",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. Update the previous mock server with the followinga. Update the route /get/message to a dynamic URL which takes customer id as a parameter.b. Update the 'Hello World' variant to- return the following file with auto file location calculation.json { &quot;message&quot; : &quot;Hello World&quot; }- Set the following header params in response{ fname: John lname: Doe }Update the Hello Universe variantto return the following file and the file location should be hard coded.{    &quot;message&quot; : &quot;Hello Universe&quot;}Set the following cookie params in response{    customerId: 123456}Update the default handler to do the following:Add reading of query parameter 'fname' and 'lname' from the request.If the customer id is greater than 5 charactersreturn 'invalid id' as responseIf the customer id is less than or equal to 5 charactersreturn following response from the handler (NOT Using The File)Hello - fname lnameAdd a POST route /set/customerId and in default handler read the payload value and log it on console.{    &quot;customerid&quot;: 123456}2. Start mock serverMake a REST call to /get/message with customer id greater than 5 characters and check the response is Invalid IdMake a REST call to /get/message with customer id equal to 5 characters and check the response to be Hello undefined undefinedMake a REST call to http://localhost:8000/get/message/12345?fname=John&amp;lname=Doe and check the response to be Hello John DoeSwitch to Hello World variant and check the response is &quot;message&quot; : &quot;Hello World&quot; and use dev tools on Chrome browser to verify that the header params are set (fname: John and lname: Doe)Switch to Hello Universe variant and check the response is &quot;message&quot; : &quot;Hello Universe&quot; and use dev tools on Chrome browser to verify that the cookie is set (customerId: 123456)Make a post call to mock server at http://localhost:8000/set/customerId using Postman (or any other HTTP client) with the following data and verify that 12345 is logged on the console{ &quot;customerId&quot; : 12345}",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 201/Exercise"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-201-dynamic-urls": {
        "title": "Dynamic URLs",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. How to create dynamic urls/get/customerInfo/{customerid}/{zipcode}2. Adding a dynamic URL in mock servershifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}',  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    reply('How to read the customer id :(');  }});3. Reading dynamic URL parametersvar id = req.params.customerid;4. Using dynamic values to define responseshifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}',  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    var id = req.params.customerid;    reply('Customer id is ' + id + ' :)');  }});5. Passing dynamic URL parameters from the Shifu UITry to pass dynamic url parameters generated from Shifu UI",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 201/Dynamic URLs"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-201-customizing-mocked-response": {
        "title": "Customizing Mocked Response",
        "content": "Dynamic URLsRequest Call InformationCustomizing Mocked ResponseReturning Response from a FileExercise1. Set custom headersshifu.route({  id: 'header',  label: 'Custom Headers',  path: '/set/headers',  handler: function(req, reply) {  reply({message: 'custom headers'})    .header('header1', 'test1')    .header('header2', 'test2')    .header('header3', 'test3')  }}) shifu.route({  id: 'header',  label: 'Custom Headers',  path: '/set/headers',  handler: function (req, reply) {    var myHeaders = {      header1: 'test1',      header2: 'test2',      header3: true    };    shifu.util.respondWithFile(this, reply, {headers: myHeaders});  }});2. Set custom cookiesshifu.route({  id: 'cookies',  label: 'Custom Cookies',  path: '/set/cookies',  handler: function(req, reply) {    reply({message: 'test'})    .state('cookie1', 'testCookie1')    .state('cookie2', 'testCookie2')    }}); shifu.route({  id: 'cookies',  label: 'Custom Cookies',  path: '/set/cookies',  handler: function (req, reply) {    var cookies = [      {name: 'cookie1', value: 'testCookie1'},      {name: 'cookie2', value: 'testCookie2'},    ];    shifu.util.respondWithFile(this, reply, {cookies: cookies});  }});3. Set CORS headersvar corsHeaders = {  origin: ['*'],  headers: [&quot;Access-Control-Allow-Headers&quot;, &quot;Origin, X-Requested-With, Content-Type, Accept&quot;],  credentials: true,} // Itemsshifu.route({  id: 'corsheaders',  label: 'CORS',  path: '/set/cors',   config: {    cors: corsHeaders  },  handler: function(req, reply) {    reply('cors headers set');  }});",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 201/Customizing Mocked Response"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-101-setting-and-installing-mock-server": {
        "title": "Setting and Installing Mock Server",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. Pre-requisitesnode.js 4+ (npm is included in the package)2. Add mock dependency to package.json&quot;dependencies&quot;: {  &quot;shifu&quot;: &quot;^1.0.0&quot;}3. Add .npmrc file to the projectregistry=https://registry.npmjs.org/strict-ssl=false4. Install mock dependency with npm installRun npm install command to install mock related dependencies.5. Add resources/endpoints.js and create ./resources/mocked-data directory to store the mock data.require('./endpoints');require('shifu').start({  host: &quot;localhost&quot;,  mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  project: 'HelloShifu'});6. Add resources/run-mock-server-console.jsrequire('./endpoints');require('shifu').start({  host: &quot;localhost&quot;,  mockedDirectory: &quot;./resources/mocked-data&quot;,  port: 8000,  project: 'HelloShifu'});Please note that you will need to replace HelloShifu for key project field with your project name(without dashes).7. Add script to start mock server in package.json&quot;scripts&quot;: {  &quot;lint&quot;: &quot;eslint . --ext .js&quot;,  &quot;start-server&quot;: &quot;node ./resources/run-mock-server-console.js&quot;},8. Test mock server can be startednpm run start-server",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 101/Setting and Installing Mock Server"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-101-introduction": {
        "title": "Introduction",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. What is Shifu?We provide a mocking solution which can be leveraged to quickly stub the REST API responses that are used by your application during development or testing. The application points to the mock service host address instead of the live service, pre-recorded responses are then returned for various endpoints from the mock service. Since there is minimal logic when writing mock service, maintaining and development cost for mock service is minimal. Some of the major development pain-points addressed by the mocking solution are:Unstable servicesInconsistent DataTest against negative or unreal scenarios2. Architectural Explanation3. High Level Key FeaturesUI Interface: Mock service UI for manual testing/debugging.Test Reuse: Execute same test cases against mock or live service.Drop-And-Respond: Respond with a mocked data file based on the url route path automatically by dropping mocked data file in folder mapping to url path.Response Reuse: Ability to use same json response file and change data dynamically for mocked response for various variants.Test De-coupling: No coupling with test cases - Test cases are independent of mock implementation except that setting the desired response for the mock service (which has no impact if the test case is run against a live service).Common Utilities: Common utility methods are provided as part of this solution which allows quicker test development.HTTPS Support: HTTPS support for all the urls.Magellan/Nightwatch integration: Ability to use mocking service with Magellan tests.Parallel sessions: Support for single instance mock server for parallel processesSwagger integration: Automatic mock creator for web-services with swagger definition.Server states: Ability to mock server state.4. Mock TerminologyRoutesVariantsHandlerSetMockIdAdmin UIRespondWithFile",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 101/Introduction"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-101-introduction-to-variants": {
        "title": "Introduction to Variants",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. What are variants?Variants allows to return a different data set for a given mocked route. Variants can be selected in the admin UI to determine what type of response a route should have. Routes are defined using the variant method on the Route object (returned by calling the route method). An object parameter is provided with the following attributesid: the variant id - used for the RESTful admin API and profile settingslabel: (optional) the variant label - used for display on the admin panelhandler: (optional) the HAPI route handler which provides the route responseVariants are useful because they allow you to test multiple scenarios that can happen with your route. Say, for example, you have a route exposing the ability to update a password. You might have several exceptional scenarios that you would want to test out (each could be a variant that you simply select to tell the route handler to use the appropriate response)the password was reset successfullythe password didn't pass validationthe old password wasn't entered correctlythe username doesn't existand so on...2. Default HandlerThe handler defined under route is the default handlershifu.route({    id: 'helloWorld',    label: 'Hello World',    path: '/helloWorld',    method: 'GET',    handler: function (req, reply) {        reply('Hello World');    }});3. Creating a variantshifu.route({    id: 'message',    label: 'Message',    path: '/get/message',    method: 'GET',    variantLabel: 'Hello',    handler: function (req, reply) {        reply('Hello');    }}).variant({    id: 'hello',    label: 'Hello World',    handler: function (req, reply) {        reply('Hello World');    }});4. Selecting a different variant to be returned from UIYou can select a different variant from admin UI to determine what type of response a route should have.5. Adding more variantsshifu.route({    id: 'message',    label: 'Message',    path: '/get/message',    method: 'GET',    variantLabel: 'Hello',    handler: function (req, reply) {        reply('Hello');    }}).variant({    id: 'hello',    label: 'Hello World',    handler: function (req, reply) {        reply('Hello World');    }}).variant({    id: 'helloUniverse',    label: 'Hello Universe',    handler: function (req, reply) {        reply('Hello Universe');    }});",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 101/Introduction to Variants"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-101-introduction-to-mocking-ui": {
        "title": "Introduction to Mocking UI",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. Starting Mocking UITo start Mocking UI, after starting mock server navigate to http://localhost:8000/shifu on your favorite browser.2. Navigating through Mocking UITry to navigate through Mocking UI to get better undertstanding of its functions.",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 101/Introduction to Mocking UI"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-101-exercise": {
        "title": "Exercise",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. Create mock server with the followingAdd a GET route /get/message with default variant returning HelloAdd a variant that returns &quot;Hello World&quot;Add another variant that returns &quot;Hello Universe&quot;Add another GET route /get/numbers with default variant returning incremental values starting from 1Add a variant that returns even number starting from 2 in incrementsAdd another variant to return odd numbers starting from 1 in increments2. Start mock serverMake a REST call to /get/message and verify default variant returns 'Hello'Switch back and forth to other two variants and verify that you see 'Hello World' and 'Hello Universe' message respectively.Make a REST call to /get/numbers and verify default variant returns numbers in incremental orderSwitch back and forth to other two variants and verify that you see even and odd numbers in incremental order respectively.",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 101/Exercise"
      },
    
      "documentation-mocking-native-android-javascript-training-guide-mocking-101-adding-routes-for-mocking": {
        "title": "Adding Routes for Mocking",
        "content": "IntroductionSetting and Installing Mock ServerAdding Routes for MockingIntroduction to Mocking UIIntroduction to VariantsExercise1. What REST APIs can be mocked?GETHEADPOSTPUTPATCHDELETEOPTIONS2. Add a route to be mocked in endpoints.jsshifu.route({  id: 'helloWorld',  label: 'Hello World',  path: '/helloWorld',  method: 'GET',  handler: function (req, reply) {    reply('Hello World');  }});Now start mock server and hit http://localhost:8000/helloWorld3. Understanding route parametersid: Unique route idlabel: Description of the routepath: Path of the routemethod: HTTP methodhandler: Function which handles the request for the path4. Adding multiple routes to be mockedshifu.route({  id: 'helloUniverse',  label: 'Hello Universe',  path: '/helloUniverse',  method: 'GET',  handler: function (req, reply) {    reply('Hello Universe');  }});Now start mock server and hit http://localhost:8000/helloUniverse",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Training Guide/Mocking 101/Adding Routes for Mocking"
      },
    
      "documentation-functional-testing-rweb-javascript-training-guide-rweb-testing-remote-browser-testing": {
        "title": "Remote browser testing",
        "content": "PrerequisitesBuilt-in browser testingRemote browser testingRemote browser testingDon’t have a desired browser in your local? No worry, you can use the following executors for remote test.magellan-saucelabs-executor: Drive tests on Saucelabsmagellan-testobject-executor: Drive tests on TestObjectmagellan-browserstack-executor: Drive tests on Browserstackmagellan-seleniumgrid-executor:  Drive tests in selenium gridEnable an executorTo do the remote browser test, you need to enable an executor:Install the wanted executor via npm install or add it into your package.json file.E.g. install from npm install:npm install testarmada-magellan-saucelabs-executor --saveAdd following code in your magellan.json{  &quot;executors&quot;: [    &quot;testarmada-magellan-saucelabs-executor&quot;  ],  &quot;strategy_bail&quot;: &quot;testarmada-magellan-early-bail-strategy&quot;}Please note: Some executors need specific configuration to be functional. Please refer to the README.md in executor’s repo for detail configuration.Run tests with multiple executorsMagellan allows to run tests with one or more executors at the same time. This is done by passing a specific command line argument to magellan.For local tests, after enable magellan-local-executor# to run test in Chrome--local_browser chrome# to run test in both Chrome and Firefox--local_browsers chrome, firefoxQuizCan you enable both magellan-local-executor and magellan-saucelabs-executor for your test? and run test in local Chrome and Chrome 60 on Sauce Labs?",
        "url": "/documentation/Functional Testing/rWeb/JAVASCRIPT/Training Guide/rWeb Testing/Remote browser testing"
      },
    
      "documentation-functional-testing-rweb-javascript-training-guide-rweb-testing-prerequisites": {
        "title": "Prerequisites",
        "content": "PrerequisitesBuilt-in browser testingRemote browser testingPrerequisitesEven though we’ve included everything that is needed in the package.json file, it’s always good to have an idea on which dependency is a must for your desktop browser test.The following dependencies are required in the package.json.{  &quot;dependencies&quot;: {  &quot;nightwatch&quot;: &quot;^0.9.11&quot;,  &quot;selenium-server&quot;: &quot;^3.1.0&quot;  }}magellan-local-browser is also required for your local test.{  &quot;dependencies&quot;: {  &quot;testarmada-magellan-local-executor&quot;: &quot;^2.0.0&quot;  }}Depending on which browser you want to test, you need to include specific browser driver in your package.json. E.g. If you want to run your tests on both Chrome and Firefox:{  &quot;dependencies&quot;: {    &quot;chromedriver&quot;: &quot;^2.27.2&quot;,    &quot;geckodriver&quot;: &quot;^1.4.0&quot;    }}Then, you need to add these drivers in the nightwatch.json file. E.g.    &quot;cli_args&quot;: {      &quot;webdriver.chrome.driver&quot;: &quot;./node_modules/chromedriver/lib/chromedriver/chromedriver&quot;,      &quot;webdriver.gecko.driver&quot;: &quot;./node_modules/geckodriver/bin/geckodriver&quot;    }",
        "url": "/documentation/Functional Testing/rWeb/JAVASCRIPT/Training Guide/rWeb Testing/Prerequisites"
      },
    
      "documentation-functional-testing-rweb-javascript-training-guide-rweb-testing-built-in-browser-testing": {
        "title": "Built-in browser testing",
        "content": "PrerequisitesBuilt-in browser testingRemote browser testingBuilt-in browser testingThe sample project has some pre-configured browsers that you can use via --local_browser command.For example, the following command triggers your test in the local Firefox.HOST=dev.walmart.com MOCK_PORT=12000 DPRO_LOCATION=./test/automation/conf/data ./node_modules/.bin/magellan --nightwatch_config ./test/automation/conf/nightwatch.json --config ./test/automation/magellan.json --local_browser firefoxFull list of built in browser can be found at test_settings part in test/automation/conf/nightwatch.json fileTo run test with a new browser, you can just create a new entry in test_settings partQuizCan you make the sample test run on your local simulator's safari browser?Hint: here's the sample Capability:    &quot;appiummweb&quot;: {      &quot;desiredCapabilities&quot;: {        &quot;browserName&quot;: &quot;safari&quot;,        &quot;appiumVersion&quot;: &quot;1.7.2&quot;,        &quot;automationName&quot;: &quot;xcuitest&quot;,        &quot;platformName&quot;: &quot;iOS&quot;,        &quot;platformVersion&quot;: &quot;11.2&quot;,        &quot;deviceName&quot;: &quot;iPhone 8&quot;,        &quot;waitForAppScript&quot;: &quot;true&quot;      },      &quot;selenium&quot;: {        &quot;start_process&quot;: false      },      &quot;appium&quot;: {        &quot;start_process&quot;: true      }   },",
        "url": "/documentation/Functional Testing/rWeb/JAVASCRIPT/Training Guide/rWeb Testing/Built-in browser testing"
      },
    
      "documentation-functional-testing-rweb-javascript-training-guide-tests-framework-page-object-properties": {
        "title": "Page Object properties",
        "content": "About the testsPage Object propertiesPage Object propertiesWe have pages, elements, sections and commands properties under ./lib directory. They are the page object properties required by nightwatch.js. For more information on how to define them please refer this.page is the highest level page object property, defined base on one particular page.One page can have multiple sections.It is useful to define sections of a page. Sections do two things:Provide a level of namespacing under the pageProvide element-level nesting so that any element defined within a section is a descendant of its parent section in the DOMelements are the places that your tests will interact with through commands and assertions on each page. This is made simple using the elements property so that all your elements are defined in a single place.You can add commands to your page object using the commands property. This is a useful way to encapsulate logic about the page that would otherwise live in a test, or multiple tests.command will be called in the context of the page or section where it is defined.",
        "url": "/documentation/Functional Testing/rWeb/JAVASCRIPT/Training Guide/Tests Framework/Page Object properties"
      },
    
      "documentation-functional-testing-rweb-javascript-training-guide-tests-framework-about-the-tests": {
        "title": "About the tests",
        "content": "About the testsPage Object propertiesWe recommend using Page Objects methodologyThe Page Objects methodology is a popular pattern to write end-to-end tests by wrapping the pages or page fragments of a web app into objects. To know more about it, please read this.About the testsFor our sample framework:Create a separate folder tests for tests in your project. Each file inside it will be loaded as a test.All the tests should extend testarmada-nightwatch-extra/lib/base-test-class, which passes certain information, such as selenium session information and test result.You can override before(), beforeEach(), afterEach() and after() method or add your own methods in your base test.A test can have multiple steps if needed, e.g.:const Test = require(&quot;../lib/base-test&quot;);module.exports = new Test({  tags: [&quot;pageobject&quot;, &quot;web&quot;],  &quot;Load demo first page&quot;: function(client) {    const df = client.page[&quot;demo-first&quot;]();    df      .navigate()      .api.resizeWindow(1200, 800);  },  &quot;Verify all cities on first page&quot;: function(client) {    client      .page[&quot;demo-first&quot;]()      .assert.elContainsText(&quot;#tokyo&quot;, &quot;Tokyo&quot;)      .assert.elContainsText(&quot;.city:eq(1) p:eq(1)&quot;, &quot;Europe&quot;);  },  &quot;Jump to demo second page&quot;: function(client) {    client      .page[&quot;demo-first&quot;]()      .jumpToSecondDemo();  }});Each test should have some tags, this will make it easier to group tests when execute.",
        "url": "/documentation/Functional Testing/rWeb/JAVASCRIPT/Training Guide/Tests Framework/About the tests"
      },
    
      "documentation-functional-testing-rweb-javascript-training-guide-setup-setup-and-run-demo-tests-locally-and-on-saucelabs": {
        "title": "Setup and run demo tests locally and on SauceLabs",
        "content": "PrerequisitesSetup and run demo tests locally and on SauceLabsSetupIn the repo root (where you did the builder-init install), please follow these steps to setup the archetype project:# 1.run archetype project./node_modules/.bin/builder-init @walmart/otto-archetype-desktop# 2.copy package.json from archetype to your repocp ./test/automation/package.json .# 3.install the dependenciesnpm installRun demo test locally:npm run testYou should see  the runner magellan open up 2 Chrome windows at once, and the results of the two tests are aggregated in the console.Run demo test on Sauce Labs:npm run test:saucelabsGo to SauceLabs, after log in, you should be able to view your tests running at Dashboard. The tests are using Chrome60 browser on Windows 10.",
        "url": "/documentation/Functional Testing/rWeb/JAVASCRIPT/Training Guide/Setup/Setup and run demo tests locally and on SauceLabs"
      },
    
      "documentation-functional-testing-rweb-javascript-training-guide-setup-prerequisites": {
        "title": "Prerequisites",
        "content": "PrerequisitesSetup and run demo tests locally and on SauceLabsMost of you must already know some about web automation. In this training series, we will show you how to leverage Test Armada tools to make end-to-end tests easy, reliable, and massively parallel distributing tests across available resources both locally and remotely.PrerequisitesHostname mapping and open certain portsPlease add the following hostname mapping in the /etc/hosts file127.0.0.1 dev.walmart.comDemo test will use ports range [12000, 12010], please make sure your machine allows those portsInstall nvmWe recommend using nvm to manage your node and npm version. The sample project recommends node@6.11.2 and above,  npm@3.10.10 and above.nvm install 6.11.2nvm use 6.11.2Install builder-initThe sample project relies on FormidableLabs' builder. Please make sure you have builder-init npm installed.npm install builder-initApply SauceLabs credentials (username and api-key)The demo tests can be executed on SauceLabs. To use it, please make sure you have:SauceLabs accountHave the following credentials set up in ~/.bashrc fileexport SAUCE_CONNECT_VERSION=4.4.11export SAUCE_USERNAME=${YOUR_SAUCE_NAME}export SAUCE_ACCESS_KEY=${YOUR_SAUCE_API_TOKEN}Install Chrome browser, if you don't have it yet",
        "url": "/documentation/Functional Testing/rWeb/JAVASCRIPT/Training Guide/Setup/Prerequisites"
      },
    
      "documentation-functional-testing-rweb-javascript-training-guide-magellan-magellan-usage": {
        "title": "Magellan usage",
        "content": "Magellan usageConfigure test profilesMagellan is a massively parallel test runner. By distributing tests across available CPU cores, Magellan blazes through long test suites in a fraction of the time, aggregating results in one friendly report.There are two ways to tell magellan how you want to scale your tests:Via Command Line ArgumentsAll command line arguments of magellan and its components (executors, reporters and plugins) that are enabled can be listed out by running following command:./node_modules/.bin/magellan --helpE.g. Run tests with 30 workers, 5 retry attempts per failed test:./node_modules/.bin/magellan --max_workers 30 --max_test_attempts 5Via magellan.json FileAll command line arguments of magellan can be placed into magellan.json. You can copy the key value pair straightly into it.For example,./node_modules/.bin/magellan --max_workers 30Is equal to this in magellan.json file:{  &quot;max_workers&quot;: 30}Configuration NotesIf a configuration exists in both  magellan.json  and command line arguments, the one in  magellan.json  will take effect.Magellan searches magellan.json in your repo root by default. If you put it in a different folder, make sure to tell where it is by:./node_modules/.bin/magellan --config ${PATH_TO_MAGELLAN.JSON}Quick Reference Guide for Command-Line UseBy default,  magellan will run your test suite the fastest way possible, in parallelYou can also run it serially (one at a time) by using --serial optionYou can view detailed debug info in --serial mode, with --debug optionTo control which tests to run, could use --tag, --tags option#Specify one tag:$ magellan --tag=smoke#Specify multiple tags:$ magellan --tags=smoke,webTo limit the tests by a file path prefix, use the --group optionTo run one specific test, use the --test flag with a path to the test file",
        "url": "/documentation/Functional Testing/rWeb/JAVASCRIPT/Training Guide/Magellan/Magellan usage"
      },
    
      "documentation-functional-testing-rweb-javascript-training-guide-magellan-configure-test-profiles": {
        "title": "Configure test profiles",
        "content": "Magellan usageConfigure test profilesConfigure test profilesThere are two ways to configure test profilesVia --profile command line argumentMagellan can retrieve test profile information from an URL (to your hosted test profile).The hosted test profile file needs to follow the format of:{  &quot;profiles&quot;: {    &quot;microsoftedge&quot;: [{      &quot;browser&quot;: &quot;microsoftedge_14_Windows_10_Desktop&quot;,      &quot;resolution&quot;: &quot;1280x1024&quot;,      &quot;executor&quot;: &quot;sauce&quot;    }],    &quot;tier-one-browsers&quot;: [{       &quot;browser&quot;: &quot;microsoftedge_14_Windows_10_Desktop&quot;,       &quot;resolution&quot;: &quot;1280x1024&quot;,       &quot;executor&quot;: &quot;sauce&quot;      },      {       &quot;browser&quot;: &quot;chrome_latest_Windows_10_Desktop&quot;,       &quot;resolution&quot;: &quot;1280x1024&quot;,       &quot;executor&quot;: &quot;sauce&quot;      }    ]  }}Magellan can read and resolve the hosted profile by the following command:./node_modules/.bin/magellan --profile http://some.host#microsoftedgeYou can add as many test profiles as your need in the hosted file. Magellan is able to read more test profiles via:./node_modules/.bin/magellan --profile http://some.host#microsoftedge,firefox57Or put multiple test profiles into one collection, such as tier-one-browsers in the above sample. To call it:./node_modules/.bin/magellan --profile http://some.host#tier-one-browsersVia magellan.json fileMagellan.json file is using the same test profile format as the hosted test profile file.To use it:./node_modules/.bin/magellan --profile tier-one-browsers",
        "url": "/documentation/Functional Testing/rWeb/JAVASCRIPT/Training Guide/Magellan/Configure test profiles"
      },
    
      "documentation-functional-testing-native-ios-javascript-training-guide-ios-automation-native-app-locators": {
        "title": "Native app locators",
        "content": "Desired CapabilitiesNative app locatorsNative app locatorsTo find the native app locators, there is a handy tool:Appium DesktopIt's a GUI wrapper around the Appium server, comes with an Inspector, which enables you to check out the hierarchy of your app.E.g How to find the Password locator in Sign in screenSteps:Open Appium Desktop, and start the serverClick Start Inspector Session buttonAdd the Desired Capabilites property one by one. Or Add them from a .json data, e.g.{        &quot;app&quot;: &quot;/Users/abc/app/Walmart.app&quot;,        &quot;appiumVersion&quot;: &quot;1.7.2&quot;,        &quot;automationName&quot;: &quot;XCUITest&quot;,        &quot;platformName&quot;: &quot;iOS&quot;,        &quot;platformVersion&quot;: &quot;11.2&quot;,        &quot;deviceName&quot;: &quot;iPhone 8&quot;,        &quot;waitForAppScript&quot;: &quot;true&quot;,        &quot;locationServicesAuthorized&quot;: &quot;true&quot;,        &quot;locationServicesEnabled&quot;: &quot;true&quot;,        &quot;bundleId&quot;: &quot;com.walmart.beta.electronics&quot;      }Click Start Session to start the inspectorGo to the Sign In screen, and select Password field in the inspector's left preview window.Check the element's attribute. E.g for this case, it has an unique value &quot;Password&quot;, then we can use accessibility id as the locateStrategy and Password, as the selectorIf the element does not have an unique value, you could locate element by relative xpath. e.g. //XCUIElementTypeSecureTextField[@value=&quot;Password&quot;]Please note - should use accessibility id as much as possible.  xpath is slow and unreliable.QuizPlease find the 'Forgot your password?' locator.Can you make the inspector point to the mocked App? Hint: You can refer to processArguments desired capabilities setup in nightwatch.json file, and you need to start a mock server:node ./resources/run-mock-server-console.js",
        "url": "/documentation/Functional Testing/Native iOS/JAVASCRIPT/Training Guide/iOS Automation/Native app locators"
      },
    
      "documentation-functional-testing-native-ios-javascript-training-guide-ios-automation-desired-capabilities": {
        "title": "Desired Capabilities",
        "content": "Desired CapabilitiesNative app locatorsAfter we understand the tests framework, we can start to take a closer look on how native iOS app automation worksUnderlying we are using Appium to drive native iOS app automationMost concepts are similar for web and app automations, a few things maybe new to people who come from web automation world:Desired CapabilitiesDesired capabilities are a set of keys and values (i.e., a map or hash) sent to the Appium server to tell the server what kind of automation session we're interested in starting up.There are various capabilities which can modify the behavior of the server during automation.For example, we could set the platformName capability to iOS to tell Appium that we want an iOS session, rather than an Android one. See the capabilities doc for the complete list of capabilities available for Appium.For our sample repo, Desired Capabilities are defined either in profiles in magellan.json file or ./conf/nightwatch.json file. You can specify to use which one in your command line.For example, in your command, you can specify it via --profile appium-ios-app, which is defined in magellan.json file.",
        "url": "/documentation/Functional Testing/Native iOS/JAVASCRIPT/Training Guide/iOS Automation/Desired Capabilities"
      },
    
      "documentation-functional-testing-native-ios-javascript-training-guide-trouble-shooting-trouble-shooting-tips": {
        "title": "Trouble shooting tips",
        "content": "Trouble shooting tipsTrouble shooting tipsJava version errorException in thread &quot;main&quot; java.lang.UnsupportedClassVersionError: org/openqa/grid/selenium/GridLauncherV3 : Unsupported major.minor version 52.0         at java.lang.ClassLoader.defineClass1(Native Method)         at java.lang.ClassLoader.defineClass(ClassLoader.java:800)...Tips: Please check your java version (java -version), you should use java 1.8. You can download it here.host pointing errorError: getaddrinfo ENOTFOUND travis.dev    at errnoException (dns.js:28:10)    at GetAddrInfoReqWrap.onlookup \\[as oncomplete\\] (dns.js:76:26)...Tips: Please add travis.dev into your hosts file(/etc/hosts)Want to make sure shifu server up and running, check thisSome general trouble shooting tips for Appium iOS app automation:When run simulator test, please sure the accessibility helper is turned off in your Settings appMake sure the app is compiled for the simulator (or real device) as appropriate (e.g. in debug mode for the simulator), or you might get a  posix spawn  error.If this is the first time you've run Appium, make sure to authorize the use of Instruments. See the  UIAutomation Driver  doc.Tests on iOS may exhibit symptoms similar to a memory leak including sluggish performance or hangs. If you experience this problem, it's likely due to a known issue with NSLog. One option is to remove NSLog from your code.Sometimes iOS UI elements become invalidated milliseconds after they are found. This results in an error that looks like (null) cannot be tapped. Sometimes the only solution is to put the finding-and-clicking code in a retry block.",
        "url": "/documentation/Functional Testing/Native iOS/JAVASCRIPT/Training Guide/Trouble Shooting/Trouble shooting tips"
      },
    
      "documentation-functional-testing-native-ios-javascript-training-guide-tests-framework-understand-the-tests-framework": {
        "title": "Understand the tests framework",
        "content": "Execution commandsUnderstand the tests frameworkTests framework structureRecommend practice is Page Objects Model Design Pattern.In our sample boilerplate:Command parameter --test tests/app.test.js executes tests in app.test.js file.Tests are defined in .js files under .tests/ folder, each file is a test.Locators and function commands are grouped by page/screen, and are put in ./lib/pages/device/ folder.E.g in app.test, the login step would require elements and commands that are defined in ./lib/pages/ios/login.js file.Profiles that are used to execute tests in remote, e.g. SauceLabs, are defined in magellan.json fine.Local browsers are defined in nightwatch.json file, they are used for local simulator tests, and they are not supported in profiles.Where to find mobile commandsWhen look at commands in page files, e.g. setMobileElValue() may look new to you. Those mobile commands are defined in ./node_modules/testarmada-nightwatch-extra/lib/commands/mobile.Assertions, e.g. mobileElAttrContains(), are defined in ./node_modules/testarmada-nightwatch-extra/lib/assertions/mobile.To use those mobile commands and assertions, need to add the following lines in nightwatch.json file:  &quot;custom_commands_path&quot;: [    &quot;./node_modules/testarmada-nightwatch-extra/lib/commands/mobile&quot;  ],  &quot;custom_assertions_path&quot;: [    &quot;./node_modules/testarmada-nightwatch-extra/lib/assertions/mobile&quot;  ],You can also add your customized commands into folder ./lib/custom_commands, to increase code reusability. And please remember to add the path to nightwatch.json file, e.g.  &quot;custom_commands_path&quot;: [    &quot;./node_modules/testarmada-nightwatch-extra/lib/commands/mobile&quot;,    &quot;./lib/custom_commands&quot;  ],QuizRun mocked iOS app sample test in the local box with a different iOS simulator.",
        "url": "/documentation/Functional Testing/Native iOS/JAVASCRIPT/Training Guide/Tests Framework/Understand the tests framework"
      },
    
      "documentation-functional-testing-native-ios-javascript-training-guide-tests-framework-execution-commands": {
        "title": "Execution commands",
        "content": "Execution commandsUnderstand the tests frameworkExecution commandsAfter getting your tests up and running, you probably have tons of questions regarding how this work, let’s start with the command that we are using to get the tests running in local box, which is:$ npm run test:iosTo understand what is npm run, please check here.test:ios is a 'script' defined in package.json file, which is:&quot;test:ios&quot;: &quot;DPRO=ios ./node_modules/.bin/magellan --config magellan.json --local_browser appiumiosapp  --test tests/app.test.js --serial --max_test_attempts=1&quot;Commands parameters --test , --serial, --max_test_attempts, etc are all magellan arguments. To find all magellan command line arguments and the usages:./node_modules/.bin/magellan --helpMagellan is part of the functional JS TDK, and it is designed for running tests in massive scale.Following is an example that telling magellan to run tests with 30 workers, 5 retry attempts per failed test./node_modules/.bin/magellan --max_workers 30 --max_test_attempts 5DPRO=ios is telling tests to load data from ./conf/data/ios.jsDPRO  - data provider, support both .json and .js file. We recommend .js format.Each .js data file should return a json object. Please check here, for more details # Example: # To load from ${REPO_ROOT}/config/data/local.js DPRO=local ./node_modules/.bin/magellan --test xxxxx ......--local_browser appiumiosapp tells tests to use testarmada-magellan-local-executor . It loads Desired Capabilities from nightwatch.json.Executor  - acts as a middle layer between magellan and test framework to drive test run (via framework) based on a specific need (differentiated by executing environments).",
        "url": "/documentation/Functional Testing/Native iOS/JAVASCRIPT/Training Guide/Tests Framework/Execution commands"
      },
    
      "documentation-functional-testing-native-ios-javascript-training-guide-setup-setup-ios-app-test-on-local-machine": {
        "title": "Setup iOS app test on local machine",
        "content": "Setup iOS app test on local machineSetup iOS app test on Sauce LabsNew to native iOS app testing? No worry, you don’t need to know much to set it up. Let's get your first native iOS app test up and running in a couple of minutes.Setup iOS app test on local machinePrerequisites:Install Xcode 9.2Install Node.js &gt;= v4.x.xInstall npm. Check that you have at least npm version 3 or above (required by appium@1.7.x):$ npm --version# If not, install npm3$ npm install -g npm@3Please map dev.walmart.com to 127.0.0.1 in your host fileSetup Steps:Get the sample code and install the node package dependencies:# Create a workspace and get the smaple code$ git clone git@gecgithub01.walmart.com:otto/boilerplate-nightwatch-mobile.git$ cd boilerplate-nightwatch-mobile $ npm install$ npm install appium@1.7.2$ npm install wdVerify all the required items are setup properly by running appium-doctor:# install appium-doctor (may require sudo)$ npm install appium-doctor -g# check that all iOS dependencies are set up correctly$ appium-doctor --iosDownload Walmart app and renamed to Walmart.zip. Unzip it under ./app directory, delete Users folder. Compress ./app/Walmart to ./app/Walmart.zip, replace the the original oneOr get the Walmart.app by using the following command option:curl -L 'http://gec-maven-nexus.walmart.com/nexus/service/local/artifact/maven/redirect?r=pangaea_snapshots&amp;g=com.walmart.ios.development-qa-nightly&amp;a=Walmart.app&amp;v=LATEST&amp;p=zip' &gt; app/Walmart.zip &amp;&amp; unzip -o app/Walmart.zip -d app/ &amp;&amp; rm -rf app/Users app/Walmart.zip &amp;&amp; zip -r app/Walmart.zip app/Walmart.appPlease make sure you have iPhone 8, iOS 11.2 simulator before execute the sample test.If you would like to try out some different simulators, please modify the appiumiosapp part in .conf/nightwatch.json file.Try the sample test:$ npm run test:iosIf you don't have SauceLabs credential , please remove this line in ./magellan.json file:&quot;testarmada-magellan-saucelabs-executor&quot;",
        "url": "/documentation/Functional Testing/Native iOS/JAVASCRIPT/Training Guide/Setup/Setup iOS app test on local machine"
      },
    
      "documentation-functional-testing-native-ios-javascript-training-guide-setup-setup-ios-app-test-on-sauce-labs": {
        "title": "Setup iOS app test on Sauce Labs",
        "content": "Setup iOS app test on local machineSetup iOS app test on Sauce LabsSetup iOS app sample test on Sauce LabsApply Sauce Labs access: hereOpen terminal: (or add them into .bash_profile)$ export SAUCE_USERNAME=${USERNAME}$ export SAUCE_ACCESS_KEY=${ACCESSKEY}Upload the testing iOS app to Sauce Labs# Download Walmart app$ curl -L 'http://gec-maven-nexus.walmart.com/nexus/service/local/artifact/maven/redirect?r=pangaea_snapshots&amp;g=com.walmart.ios.development-qa-nightly&amp;a=Walmart.app&amp;v=LATEST&amp;p=zip' &gt; app/Walmart.zip &amp;&amp; unzip -o app/Walmart.zip -d app/ &amp;&amp; rm -rf app/Users app/Walmart.zip &amp;&amp; zip -r app/Walmart.zip app/Walmart.app# Upload Walmart app to SauceLabs, and name it: Walmart_app.zip$ curl -u ${SAUCE_USERNAME}:${SAUCE_ACCESS_KEY} -X POST &quot;http://saucelabs.com/rest/v1/storage/${SAUCE_USERNAME}/Walmart_app.zip?overwrite=true&quot; -H &quot;Content-Type: application/octet-stream&quot; --data-binary @./app/Walmart.zipTo run tests with live services, use command:DPRO=ios ./node_modules/.bin/magellan --config magellan.json --profile appium-ios-app  --test tests/app.test.js --serial -- max_test_attempts=1To run tests with mocked services, use command:DPRO=ios ./node_modules/.bin/magellan --config magellan.json --profile appium-ios-app-mock-sauce  --test tests/app-mock.test.js --serial --max_test_attempts=1 --sauce_create_tunnelsYou can view your tests running at: https://saucelabs.com/beta/dashboard/tests",
        "url": "/documentation/Functional Testing/Native iOS/JAVASCRIPT/Training Guide/Setup/Setup iOS app test on Sauce Labs"
      },
    
      "documentation-performance-testing-rweb-declarative-introduction": {
        "title": "Introduction",
        "content": "SummaryAs a front end engineer, performance of your application becomes an essential measurement for your application to succeed. With evolving technologies and user-centric apps, it becomes very important to measure performance of your app before it gets released.  This is where our tool can help you to measure the performance of the app at every phase of your release cycles.The performance measurement toolThe client side performance measurement tool is based on Sitespeed and is currently serving Web and mWeb interfaces. We have plans to roll out client side performance testing for native apps (android and iOS) soon.Our test runner is a self-service solution for performance monitoring that could be easily and seamlessly integrated into the software development lifecycle (SDLC).Use CasesThis solution will help teams track performance over a matrix of code-bases, configurations, environments, etc.Here are a few use cases we envision:  Trigger performance measurement via command line interface (CLI);  Trigger performance measurement on pull request (PR);  Trigger performance measurement after deployment;  Schedule performance measurement;  Visualize performance reports;  Visualize how performance trend by release or over time;  Define performance budgets that could fail PRs or rollback deployments.ImpactOur test runner will empower developers and help them not only to prevent performance regressions but also to experiment and iterate faster, by squeezing every millisecond they can and ensuring their code is not a bottleneck.It can also help find hot spots and provide insight from application, to page and component levels.ArchitectureOur test solution will integrate and orchestrate multiple components to measure performance according to many scenarios:  Application and mocking servers;  Synthetic users;  Runtime instrumentation and payload rewriting;  Network link conditioning.At a very high level, system architecture:Feature list  Integrates with your CI pipeline to run performance tests as you merge code in Git repo.  Provides reporting in time series data which can be visualized to see the trend of your application in development phase itself.  Laboratory conditions: the tests run in a very restricted environment so that we can rely on the test results without worrying about the noise that can come from network delays, CPU or memory resources. The environment are carefully monitored for any other latency or resource conflicts that may affect the performance test results.  Framework Independent:  If your app is a NodeJS app, our tool will seemlessly measure your performance. It does not matter if your app is React, Angular, Vue or any other framework.  Local Execution : a local version can be used to run tests on your development machine before you check in code.  Mock Server Integration : Tests can be run with a mock server to provide a noise-free testing.  This is an optional feature.  You can remove the mock server if you need to do live server testing, eg. production or stage testing.  Runs for Chrome and Firefox browsers.Metrics collectedOur performance tool collects metrics from the browser API via sitespeed.io. Most of the browsers have a performance API which can be used to capture the performance measurements of an app. Sitespeed.io captures these metrics and provides a metric data which is then transformed into a readable data.Navigation API:  responseTime (TTFB)  backendTime  frontendTime  redirectionTime  dnsLookUpTime  serverConnection  serverResponse  firstPaint  rumSpeedIndex  domContentLoadEventStart  domContentLoadEventEnd  domInteractive  pageLoad  fullyLoadedAssets:  Html content size  Image content size  Javascript content size  Font content size  CSS content size  SVG content size  Cookie size  Total Header size  Total content transfer sizeCustom metrics: (These are added by the app teams on their pages, few examples are below)  aboveTheFold  beforeBundle  afterBundle  index_start  first_script  entrypoint  loadHTTP status codes:  Number of 404 response codes  Number of 200 response codesOther metrics:  number of domains  last modified statsPlanned features  mweb support  native support",
        "url": "/documentation/Performance Testing/rWeb/DECLARATIVE/Introduction"
      },
    
      "documentation-performance-testing-services-declarative-introduction": {
        "title": "Introduction",
        "content": "SummaryOur Performance Testing solution, based on JMeter, was developed in-house and built entirely from open source components. It enables engineers to execute performance tests on their own, without any dependencies. The user is able to monitor the test in Real Time, while the test is running, and at the end of the test get the Test Report over email; and it can also be integrated with Slack, to receive the Test Report on the dedicated Slack Channel. It allows engineers to build and modify tests quickly and easily, offering considerable time savings with minimal-to-none outside help.Key Features  Ability to run performance tests without performance engineering team involvement  No licensing or other third party costs involved, as the tool is build in-house from open source components  Estimated time-savings of 7 hours minimum of combined Performance+DevEngineer time for basic API tests  For existing tests, you can modify the API’s endpoint URL, Data Files, Workload Model etc. quickly and, easily  Readily observe and identify your project’s performance trends and plan accordingly  The Slack integration allows you to post the test reports on the dedicated channel  All Stats are in one place; easy to understand your app/api performance at a glance  Ability to monitor your test in Real Time, while the test is executing  All Infrastructure in on cloud provider and it is easily scalableUse CaseTesting a New or Existing APIA developer wants to track the performance of an API call, a HTTP POST Method Call used to generate a promotional coupon as part of GOP - OneWalmart. They are interested in the following performance characteristics:  Response Time  ThroughputReport  Once the test is completed, a similar report will be generated and sent to the email provided during test executionArchitectureFeature ListPhase 1  Ability to Execute Independently through the UI  One Step Ramp up Model  Both HTTP and HTTPS Protocols Available  HTTP Methods Available Include both GET and, POST  The Ability to Send Header Information as part of the Request  Adding Single Column Data Files in CSV Format  UI Showing Trend Graphs  UI Showing Test Status, whether the Test is Executing or, Queued  Slack Integration for Reporting  Email Integration for Sending Reports  Integration with GIT  Data Files, Workload and Use Case ModificationPhase 2  Multiple Step Ramp up Model  Integration with Medusa  Able to Hit Custom Port with the RequestPlanned Features  Run All Use Cases Sequentially at the Project Level  Text Validation on the Response  Ability to Use Random Variables  Ability to Use UUID Variable  .perf File Validation  VU’s Graph on the UI  Ability to Stop the Test  Adding Wait Time between Requests  Enable Transactional or Workflow Model Flows  Passing Values between Requests  The Ability to Parse Response Data  The Ability to Provide a User Specified Slack Channel",
        "url": "/documentation/Performance Testing/Services/DECLARATIVE/Introduction"
      },
    
      "mocking-rweb-javascript-training-guide": {
        "title": "Training Guide",
        "content": "120 minMocking 101Covered topicsUnderstand of mocking solution and it's featuresHow to set up and start mock serverBasic usage of mocking solution's functionalitiesStart120 minMocking 201Covered topicsLearn creating dynamic URLsRead various REST call request informationCustomize mocked responseStart120 minMocking 301Covered topicsReturning responseSetMockId and APIs for itParallel SessionsStart120 minMocking 401Covered topicsMaintain states in mock serverMocking utility methodsSupported Rest APIs for mock serverStart",
        "url": "/Mocking/rWeb/JAVASCRIPT/Training Guide"
      },
    
      "documentation-mocking-rweb-javascript-introduction": {
        "title": "Introduction",
        "content": "Why Use Mock Server?Most of the applications rely on one or many back end services. For successful test execution and fast development, all the dependent backend services should be reliable 100% of the time. However that is not possible as the backend services may be down from time to time for various reasons or may have data inconsistency issues which makes testing/development against live services inefficient and time consuming.To overcome above mentioned limitations, our mocking solution can be used to quickly stub the API responses that are used by your application.We provide a mocking solution which can be leveraged to quickly stub the REST API responses that are used by your application during development or testing. The application points to the mock service host address instead of the live service. Pre-recorded responses are then returned for various endpoints from the mock service. Since there is minimal logic when writing mock service, maintenance and development cost for mock service is minimal. Some of the major development pain-points addressed by the mocking solution are:  Unstable services - Teams have saved upto 12 hours/week of development as well as testing time due to downtime / instability of external services.  Inconsistent Data - Teams have reduced the test data setup time by about 27 hours/week by eliminating the dependency on external teams for test data setup.  Test flakiness - Teams have reduced test flakiness by about 25%  Test against negative or unreal scenarios - Teams have reported to have increase test coverage for negative scenarios from no tests before to upto 15 test cases now by simulating service faults deterministicallySome of the key features of the mocking solution are:  Ease of setup - Very easy to setup mocked data and use it while development or testing your application  Drop and Respond - Respond with a JSON file based on the url route path automatically by dropping JSON response file in folder mapping to url path  Test Reuse - ability to execute test cases against mock or live serviceThe mocking solution helps the teams develop and test their web and mobile applications in local as well as CI environments.Feature list  Ease of setup - Very easy to setup mocked data and use it while development or testing your application  Test Reuse: Execute same test cases against mock or live service.  Drop-And-Respond: Respond with a JSON file based on the url route path automatically by dropping json response file in folder mapping to url path.  Test De-coupling: No coupling with test cases - Test cases are independent of mock implementation except that setting the desired response for the mock service (which has no impact if the test case is run against a live service).  Respond with mocked data from a directory: Mocked data response from specific directory irrespective of Rest APIs  Common Utilities: Common utility methods are provided as part of the mocking service which allows quicker test development.  UI Interface: Mock service UI for manual testing/debugging.  HTTPS Support: HTTPS support for all the urls.  Parallel Sessions: Support for single instance mock server for parallel processes  Shared Mock data: Allows fetching of mocked data and routes from multiple Git repositories  Magellan/Nightwatch integration: Ability to use mocking service with Magellan tests  Dynamic Transposition of Mock Data (JSON): Ability to modify response on the fly  Support for all file types: Auto evaluation of response file extension and mime type  Swagger integration: Automatic mock creator for web-services with swagger definition  Platform independent mocks: Mock any service irrespective of the language it is written in  Server states: Ability to mock server state  Support for Mobile applications: Ability to mock services for mobile applications  Manual tests against mock service: Ability to run tests manually against mock servicePlanned features  Ability to specify various data storage for mock data  Auto-refresh of data  Network and Test APIs to support instrumentation  Debugging tool to help development by supporting auto-replay of data  Support to auto-generate endpoint URLs for mocking  Support for changing mocked data via UI",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Introduction"
      },
    
      "documentation-mocking-rweb-javascript-getting-started": {
        "title": "Getting Started",
        "content": "Pre-Requisite  Please install the latest Node.jsSetting Mock ServerTo set up mock server, you need only three things:  Install mock-server module.  Routes for mock-server.  Script to start mock-server.Follow the steps below to set-up mock server:  Create a new directory mock-server.  Create a new file package.json under mock-server directory.      Add Mock Server module dependency in package.json as shown below.     \"name\": \"&lt;name-for-your-project&gt;\", \"dependencies\": {   \"shifu\": \"^1.0.0\",   \"shifu-magellan-nightwatch\": \"^1.0.0\" // needed only for magellan/nightwatch }, \"scripts\": {     \"start-mock\": \"node mocks/run-mock-server-console.js\" }        Create another directory mocks under the mock-server directory.      Under the directory mocks, create a file endpoints.js with the following code - This file will contain the routes that you want to mock         var shifu = require('shifu'); // Required     shifu.id('example'); // Required     // add a route that returns a message \"hello world\"     shifu.route({         id: 'message',         label: 'hello message',         path: '/message',         method: 'GET',         variantLabel: 'hello world',         handler: function(req, reply) {           reply({message: 'hello world'});         }     });            Under the directory mocks, create a file run-mock-server-console.jswith the following code - This file will contain the start-up script for mock server         // load mocked endpoint     require('./endpoints');      var shifu = require('shifu');     shifu.start({       host: 'localhost',       mockedDirectory: './mocks', // this can be provided as an absolute path as well.       port: 8080,       project: 'HelloShifu', //Replace HelloShifu with your project name (without dashes).     });            Now open terminal/cmd prompt and navigate to the directory mock-server and run the following command to install Mock Server and dependencies:     npm install          Starting Mock Server      To start mock-server use the following command and than go to http://localhost:8080/shifu for mock-server admin-ui.     npm run start-mock      Common Use Cases      Starting mock server on HTTPS port -  To enable https, add httpsPort with the desired port number in server start script as shown below:      shifu.start({    port: 8080,    httpsPort: 4444,    host: 'localhost',    mockedDirectory: './test/resources/mocked-data',    project: 'HelloShifu'  });        Mocking different REST methods - To mock different rest methods, change the method value in the shifu.route() object to any one of the following desired values:          POST      GET      PUT      DELETE      OPTIONS      PATCH            Returning different data set for the same mocked route (Variants) - Variants allows to return a different set of data for the same mocked route. To add one or more variants, attach the variant object to shifu.route() as shown below:     shifu.route({   id: 'message',   label: 'Hello message',   path: '/message',   method: 'GET',   variantLabel: 'hello world',   handler: function (req, reply) {     reply({message:'Hello World'})   } }) .variant({    id: 'universe',    label: 'hello universe',    handler: function (req, reply) {      reply({message:'hello universe'})    }  })  .variant({    id: 'universe',    label: 'hello galaxy',    handler: function (req, reply) {      reply({message:'Hello Galaxy'})    }  });        To get a different set of response, go to admin-ui and select a different variant for the above route and hit http://localhost:8080/message on your favorite browser.        Storing mocked response in a file - This feature allows you to respond with a static data stored in a file instead of hard coding the response data in the routes definition.     // Automatic reply of the file shifu.route({   id: 'Get Collection',   label: 'Get Collections',   path: '/product/grouping/api/collection/test',   method: 'GET',   variantLabel: 'test-1',   handler: function(req, reply) {     shifu.util.respondWithFile(this, reply);   } }) .variant({    id: 'universe',    label: 'test-2',    handler: function (req, reply) {      shifu.util.respondWithFile(this, reply);    }  });        In the above setup, file needed for default route handler (test-1) should be located at (file location/name is based on mockedDirectory/route/method/[default|variant_name].{ext})     ./mocks/product/grouping/api/collection/GET/default.{ext}        If this would be a POST call than the file should have been at     ./mocks/product/grouping/api/collection/POST/default.{ext}        The file name for variants should change from default.{ext} to universe.{ext} in above example that is the file name should be the variant name.  Directing Traffic To Mock ServerTo mock live services, your application should allow to configure it to be directed to a mock service instead of live services as shown below:Please update your app server or application by changing the host name of your live service with the host name for your mock server.Mock Server Set-up Flow  Identify REST endpoints that needs to be mocked.  Gather mocked data for those REST endpoints.  Create Mocked Routes by adding them in endpoints.js file.  Start Mock Server.  Start Your Application server that points to the Mock Server host name instead of live-service.  Run your application and the mocked data will be returned for mocked routes.",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Getting Started"
      },
    
      "documentation-mocking-rweb-javascript-faq": {
        "title": "FAQ",
        "content": "What Can Be Mocked?Any Restful service API can be mocked such as:  GET  POST  PUT  DELETE  OPTIONS  and so on..Can AJAX Calls Be Mocked?Yes - It is same as for any other backend service. For AJAX call, point it to the mocked server instance instead of the actual back end service and add a mocked route in the file containing mocked routes for mock server.What Are The Pre-Requisites?  node.js 4+ (npm is included in the package)How Can I Add Mock Server Dependency To My Node Project?\"dependencies\": {  \"shifu\": \"1.0.0\" // add the latest version}How To Add A Mocked Route?Add the following code in your routes file, typically endpoints.jsshifu.route({  id: 'helloWorld',                 // required  label: 'Hello World',             // Used for Mock Server UI  path: '/helloWorld',              // the path you want to mock  method: 'GET',                    // The Rest Method you want to mock for this API  handler: function (req, reply) {  // Add Logic to massage data before returning back to the request.    reply('Hello World');  }});Why do I see No routes defined for this path ?Any undefined routes in Shifu will be responsed with a user friendly message No routes defined for this path.How To Create Dynamic URLs?By adding the URL part in curly brackets that you would liek to by dynamic such as /get/customerInfo/{customerid}/{zipcode}For example:shifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}/{zipcode}', // both customerid and zipcode will be dynamic  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    reply('How to read the customer id :(');  }});How To Read Dynamic URLs In Request?var shifu = require('shifu');shifu.route({  path: '/get/customerInfo/{customerid}/{zipcode}'  handler: function(request, reply) {     var params = request.params;    var customerid = params.customerid; // customerid is 123 if request is \"/get/customerInfo/123/92127\"    var zipcode = params.zipcode;       // zipcode is 92127 if request is \"/get/customerInfo/123/92127\"  }}); How To Read Header Parameters In Request?var shifu = require('shifu');shifu.route({  path: '/api/getCart'  handler: function(request, reply) {    var headers = request.raw.req.headers;    var authorization = headers.authorization;    if(authorization) {       // do something    }    reply().code(204);  }}); How To Read Payload In Request?var shifu = require('shifu');shifu.route({  path: '/api/getCart'  handler: function(request, reply) {    var payload = request.payload;    // foo would be \"bar\" if the posted body content (as JSON) is {\"foo\": \"bar\"}    var foo = payload.foo;  }}); How To Read Query Parameters In Request?var shifu = require('shifu');shifu.route({  path: '/api/getCart'  handler: function(request, reply) {    var queryParams = request.query;    // foo would be \"bar\" if incoming request is \"/api/getCart?foo=bar\"    var foo = queryParams.foo;  }}); How to read url parameters in request ?To read the dynamic URL parameters in request with in the route, use request.paramsvar shifu = require('shifu');shifu.route({  path: '/api/customer/{id}'  handler: function(req, reply) {    // would be \"123\" if the endpiont hit was \"/api/customer/123\"    var id = request.params.id;  }});How to add delay to response ?A mocked response can also be delayed by some time specified by the user. You can simulate a delay (in ms) by passing delay as follows :shifu.route({  id: 'message',  label: 'Hello Variants',  path: '/message',  variantLabel: 'hello world',  handler: function (req, reply) {    shifu.util.respondWithFile(this, reply, {code: 202});  }}).variant({    id: 'variant with delay',    label: 'variant with delay',    handler: function (req, reply) {      shifu.util.respondWithFile(this, reply, {filePath: './message/GET/variant_with_delay.json', delay: 1000});    }  });How To Set Custom Headers In Mocked Response?Preferred Wayshifu.route({  id: 'header',  label: 'Test Headers',  path: '/api/testHeaders',  handler: function (req, reply) {    var myHeaders = {      header1: 'test1',      header2: 'test2',      header3: true    };    shifu.util.respondWithFile(this, reply, {headers: myHeaders});  }});Alternate WayTo set custom headers, call header(name, value, options) on reply object, wherename is the header namevalue is the header valueoptions is an optional object with the following attributes            Attribute      Description                  append      if true, the value is appended to any existing header value using separator. Defaults to false.              separator      string used as separator when appending to an exiting value. Defaults to ','              override      if false, the header value is not set if an existing value present. Defaults to true              duplicate      if false, the header value is not modified if the provided value is already included. Does not apply when append is false or if the name is ‘set-cookie’. Defaults to true      shifu.route({  id: 'Get Collection',  label: 'Get Collections',  path: '/product/grouping/api/collection/{collectionId}',  handler: function(req, reply) {  reply({message: 'test'})    .header('X-Res-Header', 'I\\'m a custom response header')  }});How To Set Custom Cookies In Mocked Response?Preferred Wayshifu.route({  id: 'cookie',  label: 'Test Cookies',  path: '/api/testCookies',  handler: function (req, reply) {    var cookies = [      {name: 'com.wm.customer', value: 'vz7.0b5c56'},      {name: 'CID', value: 'SmockedCID', options: {domain: 'domain', path: '/'}},      {name: 'anotherCookie', value: 'cookieValue'}    ];        shifu.util.respondWithFile(this, reply, {cookies: cookies});  }});Alternate WayTo set custom cookies, call state(name, value, options) on reply object, where name is the cookie namevalue is the cookie valueoptions is the server state options settings found hereshifu.route({  id: 'Get Collection',  label: 'Get Collections',  path: '/product/grouping/api/collection/{collectionId}',  handler: function(req, reply) {      reply({message: 'test'})       .state('test-cookie', 'I\\'m a custom response cookie')  }});  How To Set CORS Headers?The Cross-Origin Resource Sharing protocol allows browsers to make cross-origin API calls. CORS is required by web application running inside a browser which are loaded from a different domain than the API server. CORS headers are disabled by default. To enable, set cors to true, or to an object with the following options:            Option      Description                  origin      a string array of allowed origin servers Access-Control-Allow-Origin. Defaults to any origin [‘*’]              maxAge      number of seconds the browser should cache the CORS response (‘Access-Control-Max-Age’). The greater the value, the longer it will take before the browser checks for changes in policy. Defaults to 86400 (one day).              headers      string array of allowed headers Access-Control-Allow-Headers. Defaults to ['Authorization', 'Content-Type', 'If-None-Match'].              additionalHeaders      string array of additional headers to headers. Use this to keep the default headers in place.              methods      string array of allowed HTTP methods Access-Control-Allow-Methods. Defaults to ['GET', 'HEAD', 'POST', 'PUT', 'DELETE', 'OPTIONS']              additionalMethods      string array of additional methods to methods. Use this to keep the default methods in place              exposedHeaders      string array of exposed headers Access-Control-Expose-Headers. Defaults to ['WWW-Authenticate', 'Server-Authorization'              additionalExposedHeaders      a string array of additional headers to exposedHeaders. Use this to keep the default headers in place.              credentials      if true, allows user credentials to be sent Access-Control-Allow-Credentials. Defaults to false.      var corsHeaders = {  origin: ['*'],  headers: [\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\"],  credentials: true,}// Itemsshifu.route({  id: 'tempo',  label: 'Tempo',  path: '/tempo1',      config: {    cors: corsHeaders  },  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }});What Is respondWithFile Utility?This feature allows you to respond with a data stored in a file instead of hard coding the response data in the routes definition. This way user does not have to hard-code/change the response in handler and rather can just swap the file with different data without even bringing the server down.  shifu.route({      id: 'ResponseFromFile',      label: 'Response From File',      path: '/get/fromFile',      handler: function(req, reply) {        shifu.util.respondWithFile(this, reply);      }  });In the above example, mock server will automatically look for a file default.{some_extension}  at ./mocked-data/get/fromFile/GET/default.{some_extension}How File Path Is Calculated For respondWithFile Utility?The path to the mocked data file is auto-calculated based on the route path. For example if the route path is /get/cart than for the default variant, mock server will look for the default.{some_extension} file at ./mocked-data/get/fromFile/GET/default.{some_extension}. For variants, the name of the file should be changed from default to the variant name as shown below:shifu.route({  id: 'ResponseFromFile',  label: 'Response From File',  path: '/get/fromFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }}).variant({  id: 'textData',  label: 'Text Data',  handler: function (req, reply) {    shifu.util.respondWithFile(this, reply);  }});In above example mock server will look for ./resources/mocked-data/get/fromFile/GET/textData.{some_extension} file for the variant textDataCan I Provide A Custom File Location respondWithFile Utility?Yes. By adding filePath parameter as shown in below example:shifu.route({  id: 'CustomResponseFile',  label: 'Response From Custom Path',  path: '/get/customFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {filePath: './custom.json'});  }});In above example mock server will look for the file under MockedDirectory only but at ./mocked-data/custom.jsonHow To Respond Only With Code?shifu.route({  id: 'message',  label: 'hello message',  path: '/message',  handler: function(req, reply) {    reply().code(400);  }});Can I Return A Response Code With respondWithFile Utility?Yes - by adding code parameter as shown in below example:shifu.route({  id: 'message',  label: 'hello message',  path: '/message',   handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {code: 400});  }});What Is MockedDirectory Path?Mocked directory path is the location to the base directory where all your mocked response file will be stored. This parameter is defined in run-mock-server-console.js file. It is defined at the start of mock server as shown in the code below:require('./endpoints');require('shifu').start({  host: \"localhost\",  mockedDirectory: \"./resources/mocked-data\",  port: 8000,  project: 'HelloShifu'});Location For Response File For RespondWithFile?If you have set your default folder to be mocked-data, then based on your URL path:For default variant, mock server will look for ./mocked-data/product/grouping/api/collection/GET/default.json and for mixItem variant mock server will look for ./mocked-data/product/grouping/api/collection/GET/mixItem.jsonWhat Are Variants?Variants allows to return a different data set for a given mocked route. Variants can be selected either in the admin UI or through automation APIs to determine what type of response a route should have. Routes are defined using the variant method on the Route object (returned by calling the route method). An object parameter is provided with the following attributes  id: the variant id - used for the RESTful admin API and profile settings  label: (optional) the variant label - used for display on the admin panel  handler: (optional) the HAPI route handler which provides the route responseVariants are useful because they allow you to test multiple scenarios that can happen with your route. Say, for example, you have a route exposing the ability to update a password. You might have several exceptional scenarios that you would want to test out (each could be a variant that you simply select to tell the route handler to use the appropriate response)  the password was reset successfully  the password didn’t pass validation  the old password wasn’t entered correctly  the username doesn’t exist  and so on…How To Add A Variant To A Route?To add a one or more variants do the following:shifu.route({  id: 'message',  label: 'Message',  path: '/get/message',  method: 'GET',  variantLabel: 'Hello',  handler: function (req, reply) {    reply('Hello');  }}) .variant({    id: 'hello',    label: 'Hello World',    handler: function (req, reply) {      reply('Hello World');    }  }).variant({    id: 'hello',    label: 'Hello Universe',    handler: function (req, reply) {      reply('Hello Universe');    }  });  How To Switch Variants In Test Case?browser.setMockVariant({ fixture: \"fixture id\", variant: \"variant id\" }); How To Switch Variants With HTTP Call?You can also switch the variants via HTTP call (Recommended only when not using Shifu as a library). As an example, if you want to set variant to helloUniverse for the route below:  shifu.route({    id: 'helloWorld',    label: 'Hello World',    path: '/helloWorld',    method: 'GET',    handler: function (req, reply) {      reply('Hello World');    }  })  .variant({    id: 'helloUniverse',    label: 'Hello Universe',    handler: function (req, reply) {      reply('Hello Universe');    }  });curl  -H \"Content-type: application/json\" -X POST -d '{\"variant\":\"&lt;variant&gt;\"}' &lt;host&gt;:&lt;port&gt;/shifu/api/route/&lt;routeId&gt;So for the above route, you can switch the variant to helloUniverse like this:curl  -H \"Content-type: application/json\" -X POST -d '{\"variant\":\"helloUniverse\"}' http://localhost:8000/shifu/api/route/helloWorldWhen using parallel sessions, if you want to switch a variant for a route for a particular session, register the session with mock server like this:curl &lt;host&gt;:&lt;port&gt;/shifu/api/registerSession// e.g curl http://localhost:8000/shifu/api/registerSessionIf sessions are available, mock server will return a response like: {\"session\":\"33b08d\"}Extract the session id from response and append it to the route id you want to switch variant for e.g:curl -H \"Content-type: application/json\" -X POST -d \"variant\":\"helloUniverse\"}' http://localhost:8000/shifu/api/route/helloWorld-33b08dWhat Is Mock Server UI Used For?UI can be used to view and test mocked routes as well as for manual switching of variants when running tests manually.What Is Parallel Sessions?Parallel sessions allows you to run multiple instance of server virtually while running only one server. This is helpful when you are running multiple test cases which access the same routes but different variants as parallel sessions allow you to set different variants on same routes without conflicting. This saves CPU and RAM both as only one server is running instead of multiple. Please see the call flow explaination without and with Parallel Sessions Below:Call Flow Without Parallel SessionsCall Flow With Parallel SessionsHow Can I Enable Parallel Sessions On Mock Server?Add sessions parameter with number of virtual services you want as shown in below example while startung mock Server.require('./endpoints');var shifu = require('shifu');shifu.start({  host: \"localhost\",  mockedDirectory: \"./resources/mocked-data\",  port: 8000,  sessions: 2,  project: 'HelloShifu'});How Can I Register a Session For Parallel Sessions?var sessionId = shifu.registerSession();How Can I Close A Session For Parallel Sessions?var closeSession = shifu.closeSession(sessionId);Does Mock Server Has Any Utility To Modify JSON Data Stored In Files?Yes - Mock Server exposes transpose option that cna be passed in respondWithFile method to modify the JSON files dynamically.How Does transposeData Work To Modify JSON Data Stored In Files?If you have many variants for a Rest end point and the mocked data for all variants can use the same JSON response with few changes to the values, than this feature is what you need. This feature allows you to dynamically change a JSON file before sending the response back from the mock server for the request. It removes the need of having one to one mapping of static JSON files with each variants.// Static Response JSON File{ id: \"1234\", name: \"toothpaste\" details: [   {    flavor: \"Mint 1\",    Size: \"10\",    Size_Type: ounce    },   {    flavor: \"Mint\",    Size: \"10\",    Size_Type: ounce   } ]}// Sample code for substituting id from 1234 to 7777 and flavor from Mint to Mint 2 for second array element in routesshifu.route({    id: 'Get Collection',    label: 'Get Collections',    path: '/product/grouping/api/collection/{collectionId}',     handler: function(req, reply) {      var dataToChange = {        'id': '7777',        'details[1].flavor': 'Mint 2'      }      shifu.util.respondWithFile(this, reply, {transpose: dataToChange});     }});// Dynamic Response JSON File returned from Mock service{ id: \"7777\", name: \"toothpaste\" details: [   {    flavor: \"Mint 1\",    Size: \"10\",    Size_Type: ounce    },   {    flavor: \"Mint 2\",    Size: \"10\",    Size_Type: ounce   } ]}Can I Use transposeData Functionality Outside Of respondWithFile?Yes - You can use it by Shifu Utils.var fileLocation = require(\"path\").join(__dirname, './resources/test-data/data-transposition-test.json');var dataSet = utils.readJsonFile(fileLocation);var dataToChange = { 'items.item[0].id': 1234, // substitue id 0001 to 1234 'items.item[0].val': \"value\", // Add 'val' to first array element of items.item 'items.item[1].id': 4567, // Add 'id' to second array element of items.item 'items.item[0].batters.batter[0].id': 5678 // substitue id 1001 to 5678}substitutedData = shifu.util.transposeData(dataSet, dataToChange);// Base JSON file - data-transposition-test.json{  \"items\":  {    \"item\":    [      {        \"id\": \"0001\",        \"type\": \"donut\",        \"name\": \"Cake\",        \"ppu\": 0.55,        \"batters\":        {          \"type\" : 1,          \"batter\":          [            { \"id\": \"1001\", \"type\": \"Regular\" },          ]        },        \"topping\":        [          { \"id\": \"5001\", \"type\": \"None\" }        ]      }    ]  }};// Resulted JSON{  \"items\": {    \"item\": [      {        \"id\": 1234,        \"type\": \"donut\",        \"name\": \"Cake\",        \"ppu\": 0.55,        \"val\": \"value\"        \"batters\": {          \"type\": 1,          \"batter\": [            {\"id\": 5678, \"type\": \"Regular\"}          ]        },        \"topping\": [          {\"id\": \"5001\", \"type\": \"None\"}        ]      },      {        \"id\": 4567      }    ]  }};Why Mock Server Returns Error 415 Unsupported Media Type?If you’re using content type like application/graphql, follow this example  shifu.route({    id: 'id',    label: 'id',    path: '/graphql',    method: ['POST', 'PUT'],    config : {      payload: {        parse: false,        allow: 'application/graphql'      }    },    handler: function (req, reply) {      shifu.util.respondWithFile(this, reply, {code: 200});    }  });For more details, read thisHow to send meta information for response ?Mocked responses can also have meta information that can be set in the response files itself. For example :{  \"setHeaders\": {    \"date\": \"Fri, 06 Jan 2017 03:33:22 GMT\",    \"content-type\": \"text/html; charset=UTF-8\",    \"transfer-encoding\": \"chunked\",    \"connection\": \"close\",    \"set-cookie\": [      \"__cfduid=d7502270409ade5544a5a60d0fbd7652a1483673602; expires=Sat, 06-Jan-18 03:33:22 GMT; path=/; domain=.typicode.com; HttpOnly\"    ],    \"x-powered-by\": \"Express\",    \"vary\": \"Accept-Encoding\",    \"access-control-allow-credentials\": \"true\",    \"cache-control\": \"public, max-age=14400\",    \"last-modified\": \"Thu, 05 Jan 2017 07:28:00 GMT\",    \"via\": \"1.1 vegur\",    \"cf-cache-status\": \"HIT\",    \"expires\": \"Fri, 06 Jan 2017 07:33:22 GMT\",    \"server\": \"cloudflare-nginx\",    \"cf-ray\": \"31cc1baee47b11fb-SJC\"  },  \"setCode\":201,  \"setPayload\": \"resources/mocked-data/message/GET/file_read_from_recorded_file.txt\",  \"setContentType\": \"text/plain; charset=utf-8\"}The above file is going to set the headers of the response from Shifu according to headers provided in setHeaders, code provided in setCode , contentType provided in setContentType and payload provided in setPayload. If setPayload is a path of the file intended to be responded with, then Shifu will look for the file and respond with the content of that file. If setPayload is JSON content, then Shifu will respond with JSON content.The above functionality makes sure that Shifu is able to handle all the file types when responding with recorded mocked data.In order to test different scenarios, you can add/delete/update header information in the setHeaders value. Or if you need to change the contentType of the response, you can simply replace value of setContentType.Please note that setContentType will take precedence over content-type header value. If setContentType is not provided then, HTTP will set the contentType of the file according to file type.How to add Shifu custom commands to Nightwatch?To add mock server custom commands to control the Shifu server in your end to end tests, add the following in nightwatch.json:\"custom_commands_path\": [    ...    \"./node_modules/shifu-magellan-nightwatch/commands\"  ],",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/FAQ"
      },
    
      "documentation-mocking-rweb-javascript-contribution-guide": {
        "title": "Contribution Guide",
        "content": "ArchitectureThese are the very high level components of mocking eco-system.The below diagram shows the mocking components in detail.The mocking service uses shifu-smocks which provides the stateful HTTP mocking service built on top of HAPI. It allows to add routes and different scenarios for each route.In addition, the mocking service provides certain utilities via shifu-util. It also provides logging facility with shifu-loggerMock Server Start flowThe mocking service exposes its features via API’s and HTTP end points. Lets take a look at the sequence of events when the mock server is started.In the above diagram, the actor can be the test code which starts mock server or a developer using the mock service for local development / testing.      Users can specify what routes to mock by specifying them in endpoints.js        Shifu’s start() is invoked with options to start the Shifu server        Shifu creates an instance of Hapi server        Shifu adds the routes for the system API’s it supports        Shifu gets the plugin from shifu-smocks        Shifu registers the plugin it obtained from the above step        Shifu starts the server        Once the Shifu server is started, you can use the Shifu API’s via HTTP Calls or libraries [Read API Guide for examples]  Parallel vs non-parallel sessionsWithout Parallel sessionsIf we want to run two test cases in parallel, mocking the same route and returning different data, it won’t be possible with running one  mock server and sharing across the whole test suite. So we needed to run one mock server and one application server per test case.With Parallel sessionsWith parallel sessions, we can share one application server and mock server for the whole test suite. It allows to mock the same route but different data for different test cases.To use parallel sessions, the mock server is started with pre-defined number of sessions. For each test, the test case needs to register a session with the mock server. The mock server returns a unique session id which is then sent as part of the request to the application server. If the request gets routed to the mock server for a mocked route, the request handler in mock server extracts the session id from the request, and prepends it to the route. For e.g, if the session id is “123”, it is prepended to the route “/api/getCart” and the route becomes “/123/api/getCart”. For another test using session id “456” , the route will become “/456/api/getCart”. This enables the mock server to be able to return two different responses for the same mocked route.Tech stackLanguage : NodejsNode Version: 4+Unit Tests: MochaCode formatting: EslintCode Coverage Report: IstanbulDeployment informationMocking components are released as npm librariesGit repository informationThe source code for all mocking components reside in Github.  Shifu  Shifu Util  Shifu Magellan Nightwatch  Shifu Logger  Shifu Smocks  Shifu SwaggerDevelopment processTo contribute to the mocking fleet, please follow these steps:      Fork the repository https://github.com/TestArmada/shifu. If your Github username is “abc” for e.g, your forked repository will be https://github.com/abc/shifu.        Clone this forked repository using git clone https://github.com/&lt;username&gt;/shifu.git and make “shifu” your working directory.        Create a branch on local with git checkout -b &lt;your branch name&gt;. Note The default branch for all projects is development so any branch you create will be off the development branch.        Install dependencies using npm install.        Make the code changes in the branch you created in step (3) and write / update the unit tests to verify your changes. Run unit tests using npm test. We use eslint to ensure code formatting. This step runs both unit tests as well as verifies code formatting. We use istanbul for code coverage reporting. 95% is the minimum code coverage we expect for all our components.        Once you’re ready, submit your pull request from your branch against the development branch of Shifu (https://github.com/TestArmada/shifu/tree/development). The PR triggers a Travis build which runs the tests in CI environment (same steps as in (5) above).        Once the PR is reviewed, a team member merges the PR into the development branch.        When the development branch is merged to master, a team member will push a tag to master, a Travis build is triggered and publishes a new version of the package to npm registry.  Note: The same steps above are applicable for contributing to any of the mocking components.",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/Contribution Guide"
      },
    
      "documentation-mocking-rweb-javascript-api-guide": {
        "title": "API Guide",
        "content": "  Start Mock Server - start()  Stop Mock Server - stop()  Create Mocked Route - route()  Create Variant - variant()  Set variant - setMockVariant()  Add global variants - addGlobalVariant()  Respond With File - respondWithFile()  Respond with mock variant - respondWithMockVariant()  Set Mock Id - setMockId()  Get Mock Id - getMockId()  Reset Mock Id - resetMockId()  Reset url count - resetURLCount()  Get url count - getURLCount()  Register session - registerSession()  Close session - closeSession()  Check session - checkSession()  Get sessions - getSessions()  Clear sessions - clearSessions()  Get project name - getProjectName()  Get port information - getPortInfo()  Add state - addState()  Get state - getState()  Clear state - clearState()  Enable Metrics - enableMetrics()  Check if metrics are enabled - isMetricsEnabled()  Dynamic transposition of JSON data - transposeData()  Kill process - killProcess()  Read contents of a file - readFile()  Read contents of a file - readFileSynchronously()  Read contents of JSON file - readJsonFile()  Write to file - writeFile()  Delete file - deleteFile()  Check if directory exists - checkDirectoryExists()  Check if file exists - checkFileExists()  Set Log level - setLogLevel()  Get Log level - getLogLevel()  Reset Log level - resetLogLevel()Start Mock Server - start()This API allows to start the mock server.shifu.start(options, callback);The following attributes are supported:            Attribute      Description      Required                  options      JSON object with the attributes described in the table below      No              callback      The first argument to callback function is the server instance if the start is successful, else it is an error.      No      where options has the following attributes:            Attribute      Description      Required                  host      Hostname for mock server (default: localhost)      No              port      Port for mock server (default: 8080)      No              httpsPort      Https port for mock server      No              mockedDirectory      Path to the mocked data directory (default: resources/mocked-data w.r.t working directory).      No              sessions      Number of parallel sessions to start the mock server with (default: 0)      No              collectMetrics      Enable mock server to collect usage metrics (default: true)      No              project      Name for your project (default: default)      No      Examplevar shifu = require('shifu');shifu.start({  host: 'localhost',  port: 12000,  httpsPort: 12001,  mockedDirectory: '/resources/mockedData',  sessions: 3,  project: 'My Project'});Stop Mock Server - stop()This API allows to stop the mock server.shifu.stop(server, callback);The following attributes are supported:            Attribute      Description      Required                  server      server instance returned by start() method      Yes              callback      The first argument to callback function is an error if an error is encountered in stopping the server, null otherwise      No      Examplevar shifu = require('shifu');var server = shifu.start(options, callback);// do something with mock servershifu.stop(server, function (error) {  if (error) {      console.log('Unable to stop mock server');  } else {      console.log('Mock Server stopped');  }});Create Mocked Route - route()This API allows to create/add required mocked REST endpoints.shifu.route(options);The following attributes are supported:            Attribute      Description      Required                  options      JSON object with the attributes described in the table below      Yes      where options has the following attributes:            Attribute      Description      Required                  id      The unique route id for the mock server      Yes              label      The route label used for display on the Shifu Admin Panel      No              path      The route path      Yes              method      The HTTP route method (defaults to GET)      No              handler      The HAPI route handler which provides the route response. This is optional because you could use multiple variants to handle the response (See Variants)      No      Examplevar shifu = require('shifu');shifu.route({  id: 'my_route',  label: 'My Route',  path: '/api/foo',  method: 'GET',  handler: function(request, reply) {    // Add logic for handler    reply('Hello');  }});Create Variant - variant()This API allows to create/add variants. Variants are route handlers that you can select manually (via Shifu Admin panel) or Rest call or through Node API to select a different dataset for the response for a given route. Variants are defined using the variant() method on the Route object (returned by calling the route method).shifu.route(routeOptions).variant(options)The following attributes are supported:            Attribute      Description      Required                  options      JSON object with the attributes described in the table below      Yes      where options has the following attributes:            Attribute      Description      Required                  id      The unique variant id for a given route      Yes              label      The route label used for display on the Admin Panel      No              handler      The HAPI route handler which provides the variant response for the route      No      Examplevar shifu = require('shifu');shifu.route({  id: 'my_route',  path: '/api/foo',  handler: function(request, reply) {    // this is essentially the same as the \"default\" variant    reply({firstName: 'John'});  }}).variant({  id: 'Billy',  handler: function(request, reply) {    reply({firstName: 'Billy'});  }}).variant({  id: 'Clark',  handler: function(request, reply) {    reply({firstName: 'Billy'});  }});Set variant - setMockVariant()setMockVariant can be used to set a variant to an existing API path.shifu.setMockVariant(options, callback) // with Shifu libraryor browser.setMockVariant(options, callback) // when using MagellanThe following attributes are supported:            Attribute      Description      Required                  options      JSON object with the attributes described in the table below      No              callback      callback function to be called after setMockVariant()      Yes      where options has the following attributes:            Attribute      Description      Required                  fixture      Id defined in route      Yes              variant      The variant defined in endpoint.js for the fixture you entered      Yes              portNumber      Port number where the mock server is running on      No              shifuSessionId      Shifu session id, if using parallel sessions      No      ExampleIf the routes are defined likevar shifu = require('shifu');shifu.route({  id: 'hello',  path: '/helloWorld',  handler: function(request, reply) {    reply('Hello World');  }}).variant({  id: 'universe',  handler: function(request, reply) {    reply('Hello Universe');  }});For the route and variant defined as above, you can set the variant to universe as follows:// when using Shifu libraryshifu.setMockVariant({    fixture: 'hello', // same as id in the .route() options    variant: 'universe' // same as id in the .variant() options}, function (err) {    if (err) {        console.log('Error in setting variant:' + err);    } else {        console.log('Successfully set variant');    }});or // When using Magellanbrowser.setMockVariant({ fixture: \"hello\", variant: \"universe\" });or Alternately, you can also use `curl` call to set a variant with this POST call to `{host}:{port}/shifu/api/route/{routeId}`curl -H \"Content-Type: application/json\" -X POST -d '{\"variant\":\"{universe}\"}' http://localhost:8080/shifu/api/route/hello?returnConfig=trueYou can confirm if this works by going to Admin panel and see that for helloWorld route, the variant universe will be highlighted. Also, hitting this url http://localhost:8080/helloWorld will reply with Hello Universe.If the variant does not exist on the route, mock server returns with an Internal Server error (HTTP 500).Add global variants - addGlobalVariant()You can also add global variants that will affect all routes. The attributes to the options are same as that of variant().shifu.route(routeOptions).addGlobalVariant(options)whereoptions - JSON object with the same attributes as of variant described in this sectionExamplevar shifu = require('shifu');shifu.addGlobalVariant({  id: '500',  label: '500 error',  handler: function(request, reply) {    reply({      statusCode: 500,      error: 'Internal Server Error'    }).code(500);  }})Respond With File - respondWithFile()This API allows to respond with static data stored in a file instead of hard coding the response data in the routes definition. Based on the path of the URL that is being mocked, the response file can be dropped in the directory location and the file will be automatically used by Shifu for sending the response. It also allows to specify the absolute path of the response files.shifu.util.respondWithFile(route, reply, options);The following attributes are supported:            Attribute      Description      Required                  route      Handle to the shifu route object      Yes              reply      Handle to the reply object      Yes              options      JSON object with additional options desribed below      No                  Attribute      Description      Required                  code      HTTP Status code to reply with      No              filePath      Static file path of the mocked data      No              delay      Delay response time by this value (in milliseconds)      No      To use this feature, you can call respondWithFile() from inside route configuration as follows:Examplevar shifu = require('shifu');// Automatic reply of the fileshifu.route({  id: 'Get Collection',  label: 'Get Collections',  path: '/product/grouping/api/collection/{collectionId}'  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }}).variant({  id: 'mixItem',  label: 'Mix Item'  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {code: 204, filePath: '../mocked-data/fileName.json', delay: 1000});  }})Note the Use of shifu.util to access the method respondWithFileRespond with mock variant - respondWithMockVariant()This API allows to respond with a variant on the main route handler. The ‘variant’ passed in MUST be the variant on existing route.shifu.util.respondWithMockVariant(route, variant, req, reply)The following attributes are supported:            Attribute      Description      Required                  route      The route object      Yes              variant      Variant on the route      Yes              request      Request object      Yes              reply      Reply object      Yes      Examplevar shifu = require('shifu');shifu.route({    id: 'respondWithVariant',    label: 'Respond With Variant',    path: '/respondWithVariant',    variantLabel: 'Respond With Main Route',    handler: function(req, reply) {        shifu.util.respondWithMockVariant(this, 'variant', req, reply); // make sure that the variant exist in the same route.    }}).variant({    id: 'variant',    label: 'Respond With Variant Route',    handler: function(req, reply) {        reply({            'message': 'I am an example of respond_with_mock_variant instead of response of main route '        });    }});Note the Use of shifu.util to access the method respondWithMockVariantSet Mock Id - setMockId()This API allows to set mock id for a given test case. If this is set, it overrides all the variants and mocked URLs responses to return mocked data from the given directory as mock-id, where mock-id is the directory name.shifu.setMockId(mockId, shifuSessionId) // with Shifu libraryor browser.setMockId(mocKId, shifuSessionId, callback); // when using MagellanThe following attributes are supported:            Attribute      Description      Required                  mockId      Mock id which is the directory name you want to respond data from      Yes              shifuSessionId      Shifu session id, if using parallel sessions      No              callback      callback function to be invoked after mock id is set (only when using Magellan)      No      The file name should be in the format url-methodName-urlCount.extension for the responses stored under file. For example, for the given route belowvar shifu = require('shifu');shifu.route({  id: 'my_route',  label: 'My Route',  path: '/api/foo',  method: 'GET',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }});the file name should be api-foo-GET-1.json for the first time the URL is hit. For second time the URL is hit, the file name returned would be api-foo-GET-2.json. If the specific file for the count is not present, Shifu will look for default file api-foo-GET.json, which is also helpful if you want to always return the same response irrespective of the number of times the URL is hit.Example:var shifu = require('shifu');shifu.setMockId('cart', 'abcdef'); // All responses should be under \"cart\" directory under your mocked data directoryor browser.setMockId('cart', 'abcdef' , callback);orcurl http://localhost:8000/shifu/api/setMockId/cart/abcdefTIP! For a dynamic url such as /app/{cartid}/getStatus the default file name should be app-cartid-getStatus-GET.json and the count specific file name should be like app-cartid-getStatus-GET-1.json.Get Mock Id - getMockId()This API is used to retrieve the currently set mock id.shifu.getMockId(shifuSessionId);The following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id, if using parallel sessions      No      Example:var shifu = require('shifu');var mockId = shifu.getMockId('abcdef');or curl http://localhost:8000/shifu/api/getMockId/cart/abcdefNote that abcdef is the session id in use for the current test (optional, if not using parallel sessions)Reset Mock Id - resetMockId()This API is used to reset currently set mock id.shifu.resetMockId(shifuSessionId) // with Shifu libraryor browser.resetMockId(shifuSessionId, callback); // when using MagellanThe following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id, if using parallel sessions      No              callback      callback function to be invoked after mock id is set (only when using Magellan)      No      Example:var shifu = require('shifu');shifu.resetMockId('abcdef');or browser.resetMockId('abcdef', callback);or curl http://localhost:8000/shifu/api/resetMockId/cart/abcdefNote that abcdef is the session id in use for the current test (optional, if not using parallel sessions)Reset url count - resetURLCount()This API is used to reset URL count to zero. This works in conjunction with setMockId function where you want to restart over for the URL count.shifu.resetURLCount(shifuSessionId)or browser.resetURLCount(shifuSessionId, callback)The following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id, if using parallel sessions      No              callback      callback function to be be invoked after the mock id is reset      No      Example:var shifu = require('shifu');shifu.resetURLCount('abcdef');or browser.resetCount('abcdef', callback); // 'abcdef' is a shifu session id in use for the testorcurl http://localhost:8000/shifu/api/resetURLCount/abcdefNote that abcdef is the session id in use for the current test (optional, if not using parallel sessions)Get url count - getURLCount()This API is used in conjunction with setMockId function where you want to get the URL count for all mocked calls.shifu.getURLCount(shifuSessionId)The following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id, if using parallel sessions      No      Example:var shifu = require('shifu');shifu.getURLCount('abcdef');or curl http://localhost:8000/shifu/api/getURLCount/abcdefNote that abcdef is the session id in use for the current test (optional, if not using parallel sessions)Register session - registerSession()This API is used to register a session with Shifu for a test case when using parallel sessions. Shifu needs to be started with sessions.shifu.registerSession(); // with Shifu libraryor browser.registerSession(callback); // with browser testsThe following attributes are supported:            Attribute      Description      Required                  callback      callback function to be be invoked after the session is registered. First argument to the callback is an error object, in case of error, null otherwise. The second argument is the registered session id (Only for browser tests)      Yes      You can use registerSession() to register a session with Shifu and can subsequently use that session id for the current test. Shifu returns a unique identifier when registering a session.If no session is available to use, Shifu returns with the message NOT_AVAILABLE.ExampleIf shifu server is started with sessions, for e.g 3 sessions as shown below,var shifu = require('shifu');shifu.start({    host: 'localhost',    port: 8080,    mockedDirectory: 'resources/mockedData',    sessions: 3});var shifuSessionId = shifu.registerSession();or browser.registerSession(function (err, sessId) {    if (err) {      return callback(new Error(\"Unable to get the sessionId\"));    }    self.shifuSessionId = sessId;    client.shifuSessionId = sessId;     return callback();});orcurl http://localhost:8000/shifu/api/registerSessionClose session - closeSession()This API is used to close a session after running a test so it can be made available for subsequent tests.shifu.closeSession(shifuSessionId);or browser.closeSession(shifuSessionId, callback);The following attributes are supported:            Attribute      Description      Required                  shifuSesssionId      Shifu session id to be closed      Yes              callback      callback function to be be invoked after the session is registered. First argument to the callback is an error object, in case of error, null otherwise (Only when using browser tests)      Yes      Examplevar shifu = require('shifu);shifu.closeSession('abcdef'); // abcdef is a previously registered session with Shifuor client.closeSession('abcdef', function (err) {  if (err) {    console.error(\"Error in closing session:\");  }});orcurl http://localhost:8000/shifu/api/closeSession/abcdefNote that abcdef is a previously registered session with Shifu.Check session - checkSession()This API is used to check status of a session id. It returns one of these states  AVAILABLE - If the session is available for use  IN_USE - If the session is in use  DOES_NOT_EXISTS - If the session id passed is invalid or does not existThe following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id      Yes      Examplevar shifu = require('shifu);var status = shifu.checkSession('abcdef');or curl http://localhost:8000/shifu/api/checkSession/abcdefGet sessions - getSessions()This API is used to get sessions informationshifu.getSessions();Examplevar shifu = require('shifu);var status = shifu.getSessions();or curl http://localhost:8000/shifu/api/getSessionsClear sessions - clearSessions()This API is used to clear the sessions information.shifu.clearSessions();Examplevar shifu = require('shifu);var status = shifu.clearSessions();Get project name - getProjectName()This API is used to get the project name passed in Shifu optionsshifu.getProjectName();Examplevar shifu = require('shifu);var projectName = shifu.getProjectName();Get port information - getPortInfo()This API is used to get the port information passed in Shifu optionsshifu.getPortInfo();Examplevar shifu = require('shifu);var portInfo = shifu.getPortInfo();Add state - addState()This API is used to add a value to the server state.shifu.addState(route, key, value);The following attributes are supported:            Attribute      Description      Required                  route      Route object      Yes              key      Key for the state variable      Yes              value      Value of the state variable      Yes      Examplevar shifu = require('shifu);shifu.route({  id: 'setState',  label: 'Add State',  path: '/login',  handler: function (req, reply) {    shifu.addState(this, 'loggedIn', true);    reply().code(204);  }});Get state - getState()This API is used to read a value from the server state.shifu.getState(route, key);The following attributes are supported:            Attribute      Description      Required                  route      Route object      Yes              key      Key for the state variable      Yes      Examplevar shifu = require('shifu);shifu.route({  id: 'getState',  label: 'Get State',  path: '/isLogin',  handler: function (req, reply) {    var isLoggedIn = shifu.getState(this, 'login');    reply(isLoggedIn);  }});Clear state - clearState()This API is used to clear a state for a given session id (Defaults to default session).shifu.clearState(shifuSessionId);The following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id      No      Examplevar shifu = require('shifu);shifu.clearState(); // Clears state for default sessionshifu.clearState('abcdef') // Clears state for session id `abcdef`Enable Metrics - enableMetrics()This API is used to enable gathering of usage metrics.shifu.enableMetrics(boolean);The following attributes are supported:            Attribute      Description      Required                  boolean      true to enable, false to disable      No      Examplevar shifu = require('shifu);shifu.enableMetrics(true); // Enables gathering of usage metricsshifu.enableMetrics(false); // Disables gathering of usage metricsCheck if metrics are enabled - isMetricsEnabled()This API is used to check if metrics gathering is enabled on Shifu. Returns true if metrics gathering is enabled, false otherwiseshifu.isMetricsEnabled();Examplevar shifu = require('shifu);shifu.isMetricsEnabled();Dynamic transposition of JSON data - transposeData()This API allows to dynamically transpose the JSON datashifu.util.transposeData(dataSet, dataToChange);The following attributes are supported:            Attribute      Description      Required                  dataSet      The data set which needs to change      Yes              dataToChange      The changes needed in the data set      Yes      To change the JSON data on fly (edit existing values or add values).// Base JSON file{  \"items\":  {    \"item\":    [      {        \"id\": \"0001\",        \"type\": \"donut\",        \"name\": \"Cake\",        \"ppu\": 0.55,        \"batters\":        {          \"type\" : 1,          \"batter\":          [            { \"id\": \"1001\", \"type\": \"Regular\" },          ]        },        \"topping\":        [          { \"id\": \"5001\", \"type\": \"None\" }        ]      }    ]  }}// Code examplevar dataToChange = { 'items.item[0].id': 1234, // substitue id 0001 to 1234 'items.item[0].val': \"value\", // Add 'val' to first array element of items.item 'items.item[1].id': 4567, // Add 'id' to second array element of items.item 'items.item[0].batters.batter[0].id': 5678 // substitue id 1001 to 5678}// when using utils classvar fileLocation = require(\"path\").join(__dirname, './resources/test-data/data-transposition-test.json');var dataSet = utils.readJsonFile(fileLocation);substitutedData = shifu.util.transposeData(dataSet, dataToChange);// When using with respondwithFile (This will read the file based on url path and transpose the data)shifu.util.respondWithFile(this, reply, {transpose: dataToChange});// Resulted JSON{  \"items\": {    \"item\": [      {        \"id\": 1234,        \"type\": \"donut\",        \"name\": \"Cake\",        \"ppu\": 0.55,        \"val\": \"value\"        \"batters\": {          \"type\": 1,          \"batter\": [            {\"id\": 5678, \"type\": \"Regular\"}          ]        },        \"topping\": [          {\"id\": \"5001\", \"type\": \"None\"}        ]      },      {        \"id\": 4567      }    ]  }}Note the Use of shifu.util to access the method transposeDataKill process - killProcess()This API allows to Kill a process with a pidshifu.util.killProcess(pid, signal, callback);The following attributes are supported:            Attribute      Description      Required                  pid      process id to kill      Yes              signal      Signal to send (defaults to SIGKILL if passed undefined)      Yes              callback      Callback function  after killprocess completes      No      Examplevar shifu = require('shifu);shifu.util.killProcess(18222, 'SIGKILL', function () {  console.log('Process killed);});Note the Use of shifu.util to access the method killProcessRead contents of a file - readFile()This API allows to read contents of a file asynchronouslyshifu.util.readFile(filePath, callback);The following attributes are supported:            Attribute      Description      Required                  file path      Absolute or relative location of file      Yes              callback      Callback function after file is read. If file is read successfully, the second argument is the file data. In case of error, the first argument is an error. Returns promise if callback is omitted      No      Examplevar shifu = require('shifu);shifu.util.readFile('data.json', function (err, fileData) {  if (err) {    console.log('Error in reading file ', err);  } else {    console.log(fileData);  }});Note the Use of shifu.util to access the method readFileRead contents of a file - readFileSynchronously()This API allows to read contents of a file synchronouslyshifu.util.readFileSynchronously(filePath);The following attributes are supported:            Attribute      Description      Required                  file path      Absolute or relative location of file      Yes      Examplevar shifu = require('shifu);shifu.util.readFileSynchronously('data.json');Note the Use of shifu.util to access the method readFileSynchronouslyRead contents of JSON file - readJsonFile()This API allows to read contents of a JSON file synchronouslyshifu.util.readJsonFile(filePath);The following attributes are supported:            Attribute      Description      Required                  file path      Absolute or relative location of JSON file      Yes      Examplevar shifu = require('shifu);shifu.util.readJsonFile('data.json');Note the Use of shifu.util to access the method readJsonFileWrite to file - writeFile()This API allows to write file contents to a fileshifu.util.writeFile(filePath, file data, callback);The following attributes are supported:            Attribute      Description      Required                  file path      Absolute or relative location of file      Yes              file data      contents to write      Yes              callback      Callback function after writeFile completes      Yes      Examplevar shifu = require('shifu);shifu.util.writeFile('hello.txt', 'hello world blah blah', function () {  console.log('Wrote to file successfully');});Note the Use of shifu.util to access the method writeFileDelete file - deleteFile()This API allows to write file contents to a fileshifu.util.deleteFile(filePath, callback);The following attributes are supported:            Attribute      Description      Required                  file location      Absolute or relative location of file to delete      Yes              callback      Callback function after deleteFile completes      Yes      Examplevar shifu = require('shifu);shifu.util.deleteFile('filetoDelete.txt', function (err) {  if (err) {    console.log('Error in deleting file');  }});Note the Use of shifu.util to access the method deleteFileCheck if directory exists - checkDirectoryExists()This API allows to check if a directory exists. Returns true if directory exists, false otherwise.shifu.util.checkDirectoryExists(directoryPath);The following attributes are supported:            Attribute      Description      Required                  directory path      Location of directory to check      Yes      Examplevar shifu = require('shifu);shifu.util.checkDirectoryExists('/home/data');Note the Use of shifu.util to access the method checkDirectoryExistsCheck if file exists - checkFileExists()This API allows to check if a file exists. Returns true if file exists, false otherwise.shifu.util.checkFileExists(filePath);The following attributes are supported:            Attribute      Description      Required                  file path      Location of file to check      Yes      Examplevar shifu = require('shifu);shifu.util.checkFileExists('/home/data');Note the Use of shifu.util to access the method checkFileExistsSet Log level - setLogLevel()This API allows to set log level on Shifushifu.log.setLogLevel(logLevel); // when using ShifuorLogger.setLogLevel(logLevel); // when using Shifu-LoggerThe following attributes are supported:            Attribute      Description      Required                  logLevel      Log level you want to set .Valid values (warn/info/debug/error)      Yes      Examplevar shifu = require('shifu);shifu.log.setLogLevel('debug');orcurl -X GET http://localhost:8080/shifu/api/setloglevel/debugGet Log level - getLogLevel()This API allows to get the current log level on Shifushifu.log.getLogLevel(); // when using Shifuor Logger.getLogLevel(); // when using Shifu-LoggerExamplevar shifu = require('shifu);shifu.log.getLogLevel();orvar Logger = require('shifu-logger');Logger.getLogLevel();orcurl -X GET http://localhost:8080/shifu/api/getloglevelReset Log level - resetLogLevel()This API allows to reset the log level of Shifu to info (Default log level)shifu.log.resetLogLevel();or Logger.resetLogLevel();Examplevar shifu = require('shifu);shifu.log.resetLogLevel();orvar Logger = require('shifu-logger');Logger.resetLogLevel();or curl -X GET http://localhost:8080/shifu/api/resetloglevel",
        "url": "/documentation/Mocking/rWeb/JAVASCRIPT/API Guide"
      },
    
      "mocking-services-javascript-training-guide": {
        "title": "Training Guide",
        "content": "120 minMocking 101Covered topicsUnderstand of mocking solution and it's featuresHow to set up and start mock serverBasic usage of mocking solution's functionalitiesStart120 minMocking 201Covered topicsLearn creating dynamic URLsRead various REST call request informationCustomize mocked responseStart120 minMocking 301Covered topicsReturning responseSetMockId and APIs for itParallel SessionsStart120 minMocking 401Covered topicsMaintain states in mock serverMocking utility methodsSupported Rest APIs for mock serverStart",
        "url": "/Mocking/Services/JAVASCRIPT/Training Guide"
      },
    
      "documentation-mocking-services-javascript-introduction": {
        "title": "Introduction",
        "content": "Why Use Mock Server?Most of the applications rely on one or many back end services. For successful test execution and fast development, all the dependent backend services should be reliable 100% of the time. However that is not possible as the backend services may be down from time to time for various reasons or may have data inconsistency issues which makes testing/development against live services inefficient and time consuming.To overcome above mentioned limitations, our mocking solution can be used to quickly stub the API responses that are used by your application.We provide a mocking solution which can be leveraged to quickly stub the REST API responses that are used by your application during development or testing. The application points to the mock service host address instead of the live service. Pre-recorded responses are then returned for various endpoints from the mock service. Since there is minimal logic when writing mock service, maintenance and development cost for mock service is minimal. Some of the major development pain-points addressed by the mocking solution are:  Unstable services - Teams have saved upto 12 hours/week of development as well as testing time due to downtime / instability of external services.  Inconsistent Data - Teams have reduced the test data setup time by about 27 hours/week by eliminating the dependency on external teams for test data setup.  Test flakiness - Teams have reduced test flakiness by about 25%  Test against negative or unreal scenarios - Teams have reported to have increase test coverage for negative scenarios from no tests before to upto 15 test cases now by simulating service faults deterministicallySome of the key features of the mocking solution are:  Ease of setup - Very easy to setup mocked data and use it while development or testing your application  Drop and Respond - Respond with a JSON file based on the url route path automatically by dropping JSON response file in folder mapping to url path  Test Reuse - ability to execute test cases against mock or live serviceThe mocking solution helps the teams develop and test their web and mobile applications in local as well as CI environments.Feature list  Ease of setup - Very easy to setup mocked data and use it while development or testing your application  Test Reuse: Execute same test cases against mock or live service.  Drop-And-Respond: Respond with a JSON file based on the url route path automatically by dropping json response file in folder mapping to url path.  Test De-coupling: No coupling with test cases - Test cases are independent of mock implementation except that setting the desired response for the mock service (which has no impact if the test case is run against a live service).  Respond with mocked data from a directory: Mocked data response from specific directory irrespective of Rest APIs  Common Utilities: Common utility methods are provided as part of the mocking service which allows quicker test development.  UI Interface: Mock service UI for manual testing/debugging.  HTTPS Support: HTTPS support for all the urls.  Parallel Sessions: Support for single instance mock server for parallel processes  Shared Mock data: Allows fetching of mocked data and routes from multiple Git repositories  Magellan/Nightwatch integration: Ability to use mocking service with Magellan tests  Dynamic Transposition of Mock Data (JSON): Ability to modify response on the fly  Support for all file types: Auto evaluation of response file extension and mime type  Swagger integration: Automatic mock creator for web-services with swagger definition  Platform independent mocks: Mock any service irrespective of the language it is written in  Server states: Ability to mock server state  Support for Mobile applications: Ability to mock services for mobile applications  Manual tests against mock service: Ability to run tests manually against mock servicePlanned features  Ability to specify various data storage for mock data  Auto-refresh of data  Network and Test APIs to support instrumentation  Debugging tool to help development by supporting auto-replay of data  Support to auto-generate endpoint URLs for mocking  Support for changing mocked data via UI",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Introduction"
      },
    
      "documentation-mocking-services-javascript-getting-started": {
        "title": "Getting Started",
        "content": "Pre-Requisite  Please install the latest Node.jsSetting Mock ServerTo set up mock server, you need only three things:  Install mock-server module.  Routes for mock-server.  Script to start mock-server.Follow the steps below to set-up mock server:  Create a new directory mock-server.  Create a new file package.json under mock-server directory.      Add Mock Server module dependency in package.json as shown below.     \"name\": \"&lt;name-for-your-project&gt;\", \"dependencies\": {   \"shifu\": \"^1.0.0\",   \"shifu-magellan-nightwatch\": \"^1.0.0\" // needed only for magellan/nightwatch }, \"scripts\": {     \"start-mock\": \"node mocks/run-mock-server-console.js\" }        Create another directory mocks under the mock-server directory.      Under the directory mocks, create a file endpoints.js with the following code - This file will contain the routes that you want to mock         var shifu = require('shifu'); // Required     shifu.id('example'); // Required     // add a route that returns a message \"hello world\"     shifu.route({         id: 'message',         label: 'hello message',         path: '/message',         method: 'GET',         variantLabel: 'hello world',         handler: function(req, reply) {           reply({message: 'hello world'});         }     });            Under the directory mocks, create a file run-mock-server-console.jswith the following code - This file will contain the start-up script for mock server         // load mocked endpoint     require('./endpoints');      var shifu = require('shifu');     shifu.start({       host: 'localhost',       mockedDirectory: './mocks', // this can be provided as an absolute path as well.       port: 8080,       project: 'HelloShifu', //Replace HelloShifu with your project name (without dashes).     });            Now open terminal/cmd prompt and navigate to the directory mock-server and run the following command to install Mock Server and dependencies:     npm install          Starting Mock Server      To start mock-server use the following command and than go to http://localhost:8080/shifu for mock-server admin-ui.     npm run start-mock      Common Use Cases      Starting mock server on HTTPS port -  To enable https, add httpsPort with the desired port number in server start script as shown below:      shifu.start({    port: 8080,    httpsPort: 4444,    host: 'localhost',    mockedDirectory: './test/resources/mocked-data',    project: 'HelloShifu'  });        Mocking different REST methods - To mock different rest methods, change the method value in the shifu.route() object to any one of the following desired values:          POST      GET      PUT      DELETE      OPTIONS      PATCH            Returning different data set for the same mocked route (Variants) - Variants allows to return a different set of data for the same mocked route. To add one or more variants, attach the variant object to shifu.route() as shown below:     shifu.route({   id: 'message',   label: 'Hello message',   path: '/message',   method: 'GET',   variantLabel: 'hello world',   handler: function (req, reply) {     reply({message:'Hello World'})   } }) .variant({    id: 'universe',    label: 'hello universe',    handler: function (req, reply) {      reply({message:'hello universe'})    }  })  .variant({    id: 'universe',    label: 'hello galaxy',    handler: function (req, reply) {      reply({message:'Hello Galaxy'})    }  });        To get a different set of response, go to admin-ui and select a different variant for the above route and hit http://localhost:8080/message on your favorite browser.        Storing mocked response in a file - This feature allows you to respond with a static data stored in a file instead of hard coding the response data in the routes definition.     // Automatic reply of the file shifu.route({   id: 'Get Collection',   label: 'Get Collections',   path: '/product/grouping/api/collection/test',   method: 'GET',   variantLabel: 'test-1',   handler: function(req, reply) {     shifu.util.respondWithFile(this, reply);   } }) .variant({    id: 'universe',    label: 'test-2',    handler: function (req, reply) {      shifu.util.respondWithFile(this, reply);    }  });        In the above setup, file needed for default route handler (test-1) should be located at (file location/name is based on mockedDirectory/route/method/[default|variant_name].{ext})     ./mocks/product/grouping/api/collection/GET/default.{ext}        If this would be a POST call than the file should have been at     ./mocks/product/grouping/api/collection/POST/default.{ext}        The file name for variants should change from default.{ext} to universe.{ext} in above example that is the file name should be the variant name.  Directing Traffic To Mock ServerTo mock live services, your application should allow to configure it to be directed to a mock service instead of live services as shown below:Please update your app server or application by changing the host name of your live service with the host name for your mock server.Mock Server Set-up Flow  Identify REST endpoints that needs to be mocked.  Gather mocked data for those REST endpoints.  Create Mocked Routes by adding them in endpoints.js file.  Start Mock Server.  Start Your Application server that points to the Mock Server host name instead of live-service.  Run your application and the mocked data will be returned for mocked routes.",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Getting Started"
      },
    
      "documentation-mocking-services-javascript-faq": {
        "title": "FAQ",
        "content": "What Can Be Mocked?Any Restful service API can be mocked such as:  GET  POST  PUT  DELETE  OPTIONS  and so on..Can AJAX Calls Be Mocked?Yes - It is same as for any other backend service. For AJAX call, point it to the mocked server instance instead of the actual back end service and add a mocked route in the file containing mocked routes for mock server.What Are The Pre-Requisites?  node.js 4+ (npm is included in the package)How Can I Add Mock Server Dependency To My Node Project?\"dependencies\": {  \"shifu\": \"1.0.0\" // add the latest version}How To Add A Mocked Route?Add the following code in your routes file, typically endpoints.jsshifu.route({  id: 'helloWorld',                 // required  label: 'Hello World',             // Used for Mock Server UI  path: '/helloWorld',              // the path you want to mock  method: 'GET',                    // The Rest Method you want to mock for this API  handler: function (req, reply) {  // Add Logic to massage data before returning back to the request.    reply('Hello World');  }});How To Create Dynamic URLs?By adding the URL part in curly brackets that you would liek to by dynamic such as /get/customerInfo/{customerid}/{zipcode}For example:shifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}/{zipcode}', // both customerid and zipcode will be dynamic  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    reply('How to read the customer id :(');  }});How To Read Dynamic URLs In Request?var shifu = require('shifu');shifu.route({  path: '/get/customerInfo/{customerid}/{zipcode}'  handler: function(request, reply) {     var params = request.params;    var customerid = params.customerid; // customerid is 123 if request is \"/get/customerInfo/123/92127\"    var zipcode = params.zipcode;       // zipcode is 92127 if request is \"/get/customerInfo/123/92127\"  }}); How To Read Header Parameters In Request?var shifu = require('shifu');shifu.route({  path: '/api/getCart'  handler: function(request, reply) {    var headers = request.raw.req.headers;    var authorization = headers.authorization;  }}); How To Read Payload In Request?var shifu = require('shifu');shifu.route({  path: '/api/getCart'  handler: function(request, reply) {    var payload = request.payload;    // foo would be \"bar\" if the posted body content (as JSON) is {\"foo\": \"bar\"}    var foo = payload.foo;  }}); How To Read Query Parameters In Request?var shifu = require('shifu');shifu.route({  path: '/api/getCart'  handler: function(request, reply) {    var queryParams = request.query;    // foo would be \"bar\" if incoming request is \"/api/getCart?foo=bar\"    var foo = queryParams.foo;  }}); How To Set Custom Headers In Mocked Response?Preferred Wayshifu.route({  id: 'header',  label: 'Test Headers',  path: '/api/testHeaders',  handler: function (req, reply) {    var myHeaders = {      header1: 'test1',      header2: 'test2',      header3: true    };    shifu.util.respondWithFile(this, reply, {headers: myHeaders});  }});Alternate Wayshifu.route({  id: 'Get Collection',  label: 'Get Collections',  path: '/product/grouping/api/collection/{collectionId}',  handler: function(req, reply) {  reply({message: 'test'})    .header('X-Res-Header', 'I\\'m a custom response header')  }});How To Set Custom Cookies In Mocked Response?Preferred Wayshifu.route({  id: 'cookie',  label: 'Test Cookies',  path: '/api/testCookies',  handler: function (req, reply) {    var cookies = [      {name: 'com.wm.customer', value: 'vz7.0b5c56'},      {name: 'CID', value: 'SmockedCID', options: {domain: 'domain', path: '/'}},      {name: 'anotherCookie', value: 'cookieValue'}    ];        shifu.util.respondWithFile(this, reply, {cookies: cookies});  }});Alternate Wayshifu.route({  id: 'Get Collection',  label: 'Get Collections',  path: '/product/grouping/api/collection/{collectionId}',  handler: function(req, reply) {      reply({message: 'test'})       .state('test-cookie', 'I\\'m a custom response cookie')  }});  How To Set CORS Headers?var corsHeaders = {  origin: ['*'],  headers: [\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\"],  credentials: true,}// Itemsshifu.route({  id: 'tempo',  label: 'Tempo',  path: '/tempo1',      config: {    cors: corsHeaders  },  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }});What Is respondWithFile Utility?This feature allows you to respond with a data stored in a file instead of hard coding the response data in the routes definition. This way user does not have to hard-code/change the response in handler and rather can just swap the file with different data without even bringing the server down.  shifu.route({      id: 'ResponseFromFile',      label: 'Response From File',      path: '/get/fromFile',      handler: function(req, reply) {        shifu.util.respondWithFile(this, reply);      }  });In the above example, mock server will automatically look for a file default.{some_extension}  at ./mocked-data/get/fromFile/GET/default.{some_extension}How File Path Is Calculated For respondWithFile Utility?The path to the mocked data file is auto-calculated based on the route path. For example if the route path is /get/cart than for the default variant, mock server will look for the default.{some_extension} file at ./mocked-data/get/fromFile/GET/default.{some_extension}. For variants, the name of the file should be changed from default to the variant name as shown below:shifu.route({  id: 'ResponseFromFile',  label: 'Response From File',  path: '/get/fromFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }}).variant({  id: 'textData',  label: 'Text Data',  handler: function (req, reply) {    shifu.util.respondWithFile(this, reply);  }});In above example mock server will look for ./resources/mocked-data/get/fromFile/GET/textData.{some_extension} file for the variant textDataCan I Provide A Custom File Location respondWithFile Utility?Yes. By adding filePath parameter as shown in below example:shifu.route({  id: 'CustomResponseFile',  label: 'Response From Custom Path',  path: '/get/customFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {filePath: './custom.json'});  }});In above example mock server will look for the file under MockedDirectory only but at ./mocked-data/custom.jsonHow To Respond Only With Code?shifu.route({  id: 'message',  label: 'hello message',  path: '/message',  handler: function(req, reply) {    reply().code(400);  }});Can I Return A Response Code With respondWithFile Utility?Yes - by adding code parameter as shown in below example:shifu.route({  id: 'message',  label: 'hello message',  path: '/message',   handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {code: 400});  }});What Is MockedDirectory Path?Mocked directory path is the location to the base directory where all your mocked response file will be stored. This parameter is defined in run-mock-server-console.js file. It is defined at the start of mock server as shown in the code below:require('./endpoints');require('shifu').start({  host: \"localhost\",  mockedDirectory: \"./resources/mocked-data\",  port: 8000,  project: 'HelloShifu'});Location For Response File For RespondWithFile?If you have set your default folder to be mocked-data, then based on your URL path:For default variant, mock server will look for ./mocked-data/product/grouping/api/collection/GET/default.json and for mixItem variant mock server will look for ./mocked-data/product/grouping/api/collection/GET/mixItem.jsonWhat Are Variants?Variants allows to return a different data set for a given mocked route. Variants can be selected either in the admin UI or through automation APIs to determine what type of response a route should have. Routes are defined using the variant method on the Route object (returned by calling the route method). An object parameter is provided with the following attributes  id: the variant id - used for the RESTful admin API and profile settings  label: (optional) the variant label - used for display on the admin panel  handler: (optional) the HAPI route handler which provides the route responseVariants are useful because they allow you to test multiple scenarios that can happen with your route. Say, for example, you have a route exposing the ability to update a password. You might have several exceptional scenarios that you would want to test out (each could be a variant that you simply select to tell the route handler to use the appropriate response)  the password was reset successfully  the password didn’t pass validation  the old password wasn’t entered correctly  the username doesn’t exist  and so on…How To Add A Variant To A Route?To add a one or more variants do the following:shifu.route({  id: 'message',  label: 'Message',  path: '/get/message',  method: 'GET',  variantLabel: 'Hello',  handler: function (req, reply) {    reply('Hello');  }}) .variant({    id: 'hello',    label: 'Hello World',    handler: function (req, reply) {      reply('Hello World');    }  }).variant({    id: 'hello',    label: 'Hello Universe',    handler: function (req, reply) {      reply('Hello Universe');    }  });  How To Switch Variants In Test Case?browser.setMockVariant({ fixture: \"fixture id\", variant: \"variant id\" }); How To Switch Variants With HTTP Call?You can also switch the variants via HTTP call (Recommended only when not using Shifu as a library). As an example, if you want to set variant to helloUniverse for the route below:  shifu.route({    id: 'helloWorld',    label: 'Hello World',    path: '/helloWorld',    method: 'GET',    handler: function (req, reply) {      reply('Hello World');    }  })  .variant({    id: 'helloUniverse',    label: 'Hello Universe',    handler: function (req, reply) {      reply('Hello Universe');    }  });curl  -H \"Content-type: application/json\" -X POST -d '{\"variant\":\"&lt;variant&gt;\"}' &lt;host&gt;:&lt;port&gt;/shifu/api/route/&lt;routeId&gt;So for the above route, you can switch the variant to helloUniverse like this:curl  -H \"Content-type: application/json\" -X POST -d '{\"variant\":\"helloUniverse\"}' http://localhost:8000/shifu/api/route/helloWorldWhen using parallel sessions, if you want to switch a variant for a route for a particular session, register the session with mock server like this:curl &lt;host&gt;:&lt;port&gt;/shifu/api/registerSession// e.g curl http://localhost:8000/shifu/api/registerSessionIf sessions are available, mock server will return a response like: {\"session\":\"33b08d\"}Extract the session id from response and append it to the route id you want to switch variant for e.g:curl -H \"Content-type: application/json\" -X POST -d \"variant\":\"helloUniverse\"}' http://localhost:8000/shifu/api/route/helloWorld-33b08dWhat Is Mock Server UI Used For?UI can be used to view and test mocked routes as well as for manual switching of variants when running tests manually.What Is Parallel Sessions?Parallel sessions allows you to run multiple instance of server virtually while running only one server. This is helpful when you are running multiple test cases which access the same routes but different variants as parallel sessions allow you to set different variants on same routes without conflicting. This saves CPU and RAM both as only one server is running instead of multiple. Please see the call flow explaination without and with Parallel Sessions Below:Call Flow Without Parallel SessionsCall Flow With Parallel SessionsHow Can I Enable Parallel Sessions On Mock Server?Add sessions parameter with number of virtual services you want as shown in below example while startung mock Server.require('./endpoints');var shifu = require('shifu');shifu.start({  host: \"localhost\",  mockedDirectory: \"./resources/mocked-data\",  port: 8000,  sessions: 2,  project: 'HelloShifu'});How Can I Register a Session For Parallel Sessions?var sessionId = shifu.registerSession();How Can I Close A Session For Parallel Sessions?var closeSession = shifu.closeSession(sessionId);Does Mock Server Has Any Utility To Modify JSON Data Stored In Files?Yes - Mock Server exposes transpose option that cna be passed in respondWithFile method to modify the JSON files dynamically.How Does transposeData Work To Modify JSON Data Stored In Files?If you have many variants for a Rest end point and the mocked data for all variants can use the same JSON response with few changes to the values, than this feature is what you need. This feature allows you to dynamically change a JSON file before sending the response back from the mock server for the request. It removes the need of having one to one mapping of static JSON files with each variants.// Static Response JSON File{ id: \"1234\", name: \"toothpaste\" details: [   {    flavor: \"Mint 1\",    Size: \"10\",    Size_Type: ounce    },   {    flavor: \"Mint\",    Size: \"10\",    Size_Type: ounce   } ]}// Sample code for substituting id from 1234 to 7777 and flavor from Mint to Mint 2 for second array element in routesshifu.route({    id: 'Get Collection',    label: 'Get Collections',    path: '/product/grouping/api/collection/{collectionId}',     handler: function(req, reply) {      var dataToChange = {        'id': '7777',        'details[1].flavor': 'Mint 2'      }      shifu.util.respondWithFile(this, reply, {transpose: dataToChange});     }});// Dynamic Response JSON File returned from Mock service{ id: \"7777\", name: \"toothpaste\" details: [   {    flavor: \"Mint 1\",    Size: \"10\",    Size_Type: ounce    },   {    flavor: \"Mint 2\",    Size: \"10\",    Size_Type: ounce   } ]}Can I Use transposeData Functionality Outside Of respondWithFile?Yes - You can use it by Shifu Utils.var fileLocation = require(\"path\").join(__dirname, './resources/test-data/data-transposition-test.json');var dataSet = utils.readJsonFile(fileLocation);var dataToChange = { 'items.item[0].id': 1234, // substitue id 0001 to 1234 'items.item[0].val': \"value\", // Add 'val' to first array element of items.item 'items.item[1].id': 4567, // Add 'id' to second array element of items.item 'items.item[0].batters.batter[0].id': 5678 // substitue id 1001 to 5678}substitutedData = shifu.util.transposeData(dataSet, dataToChange);// Base JSON file - data-transposition-test.json{  \"items\":  {    \"item\":    [      {        \"id\": \"0001\",        \"type\": \"donut\",        \"name\": \"Cake\",        \"ppu\": 0.55,        \"batters\":        {          \"type\" : 1,          \"batter\":          [            { \"id\": \"1001\", \"type\": \"Regular\" },          ]        },        \"topping\":        [          { \"id\": \"5001\", \"type\": \"None\" }        ]      }    ]  }};// Resulted JSON{  \"items\": {    \"item\": [      {        \"id\": 1234,        \"type\": \"donut\",        \"name\": \"Cake\",        \"ppu\": 0.55,        \"val\": \"value\"        \"batters\": {          \"type\": 1,          \"batter\": [            {\"id\": 5678, \"type\": \"Regular\"}          ]        },        \"topping\": [          {\"id\": \"5001\", \"type\": \"None\"}        ]      },      {        \"id\": 4567      }    ]  }};Why Mock Server Returns Error 415 Unsupported Media Type?If you’re using content type like application/graphql, follow this example  shifu.route({    id: 'id',    label: 'id',    path: '/graphql',    method: ['POST', 'PUT'],    config : {      payload: {        parse: false,        allow: 'application/graphql'      }    },    handler: function (req, reply) {      shifu.util.respondWithFile(this, reply, {code: 200});    }  });For more details, read this",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/FAQ"
      },
    
      "documentation-mocking-services-javascript-contribution-guide": {
        "title": "Contribution Guide",
        "content": "ArchitectureThese are the very high level components of mocking eco-system.The below diagram shows the mocking components in detail.The mocking service uses shifu-smocks which provides the stateful HTTP mocking service built on top of HAPI. It allows to add routes and different scenarios for each route.In addition, the mocking service provides certain utilities via shifu-util. It also provides logging facility with shifu-loggerMock Server Start flowThe mocking service exposes its features via API’s and HTTP end points. Lets take a look at the sequence of events when the mock server is started.In the above diagram, the actor can be the test code which starts mock server or a developer using the mock service for local development / testing.      Users can specify what routes to mock by specifying them in endpoints.js        Shifu’s start() is invoked with options to start the Shifu server        Shifu creates an instance of Hapi server        Shifu adds the routes for the system API’s it supports        Shifu gets the plugin from shifu-smocks        Shifu registers the plugin it obtained from the above step        Shifu starts the server        Once the Shifu server is started, you can use the Shifu API’s via HTTP Calls or libraries [Read API Guide for examples]  Parallel vs non-parallel sessionsWithout Parallel sessionsIf we want to run two test cases in parallel, mocking the same route and returning different data, it won’t be possible with running one  mock server and sharing across the whole test suite. So we needed to run one mock server and one application server per test case.With Parallel sessionsWith parallel sessions, we can share one application server and mock server for the whole test suite. It allows to mock the same route but different data for different test cases.To use parallel sessions, the mock server is started with pre-defined number of sessions. For each test, the test case needs to register a session with the mock server. The mock server returns a unique session id which is then sent as part of the request to the application server. If the request gets routed to the mock server for a mocked route, the request handler in mock server extracts the session id from the request, and prepends it to the route. For e.g, if the session id is “123”, it is prepended to the route “/api/getCart” and the route becomes “/123/api/getCart”. For another test using session id “456” , the route will become “/456/api/getCart”. This enables the mock server to be able to return two different responses for the same mocked route.Tech stackLanguage : NodejsNode Version: 4+Unit Tests: MochaCode formatting: EslintCode Coverage Report: IstanbulDeployment informationMocking components are released as npm librariesGit repository informationThe source code for all mocking components reside in Github.  Shifu  Shifu Util  Shifu Magellan Nightwatch  Shifu Logger  Shifu Smocks  Shifu SwaggerDevelopment processTo contribute to the mocking fleet, please follow these steps:      Fork the repository https://github.com/TestArmada/shifu. If your Github username is “abc” for e.g, your forked repository will be https://github.com/abc/shifu.        Clone this forked repository using git clone https://github.com/&lt;username&gt;/shifu.git and make “shifu” your working directory.        Create a branch on local with git checkout -b &lt;your branch name&gt;. Note The default branch for all projects is development so any branch you create will be off the development branch.        Install dependencies using npm install.        Make the code changes in the branch you created in step (3) and write / update the unit tests to verify your changes. Run unit tests using npm test. We use eslint to ensure code formatting. This step runs both unit tests as well as verifies code formatting. We use istanbul for code coverage reporting. 95% is the minimum code coverage we expect for all our components.        Once you’re ready, submit your pull request from your branch against the development branch of Shifu (https://github.com/TestArmada/shifu/tree/development). The PR triggers a Travis build which runs the tests in CI environment (same steps as in (5) above).        Once the PR is reviewed, a team member merges the PR into the development branch.        When the development branch is merged to master, a team member will push a tag to master, a Travis build is triggered and publishes a new version of the package to npm registry.  Note: The same steps above are applicable for contributing to any of the mocking components.",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/Contribution Guide"
      },
    
      "documentation-mocking-services-javascript-api-guide": {
        "title": "API Guide",
        "content": "  Mocking API’s          Start Mock Server - start()      Stop Mock Server - stop()      Create Mocked Route - route()      Create Variant - variant()      Set variant - setMockVariant()      Add global variants - addGlobalVariant()      Respond With File - respondWithFile()      Respond with mock variant - respondWithMockVariant()      Set Mock Id - setMockId()      Get Mock Id - getMockId()      Reset Mock Id - resetMockId()      Reset url count - resetURLCount()      Get url count - getURLCount()      Register session - registerSession()      Close session - closeSession()      Check session - checkSession()      Get sessions - getSessions()      Clear sessions - clearSessions()      Get project name - getProjectName()      Get port information - getPortInfo()      Add state - addState()      Get state - getState()      Clear state - clearState()      Enable Metrics - enableMetrics()      Check if metrics are enabled - isMetricsEnabled()      Dynamic transposition of JSON data - transposeData()      Kill process - killProcess()      Read contents of a file - readFile()      Read contents of a file - readFileSynchronously()      Read contents of JSON file - readJsonFile()      Write to file - writeFile()      Delete file - deleteFile()      Check if directory exists - checkDirectoryExists()      Check if file exists - checkFileExists()      Set Log level - setLogLevel()      Get Log level - getLogLevel()      Reset Log level - resetLogLevel()      Mocking API’sStart Mock Server - start()This API allows to start the mock server.shifu.start(options, callback);The following attributes are supported:            Attribute      Description      Required                  options      JSON object with the attributes described in the table below      No              callback      The first argument to callback function is the server instance if the start is successful, else it is an error.      No      where options has the following attributes:            Attribute      Description      Required                  host      Hostname for mock server (default: localhost)      No              port      Port for mock server (default: 8080)      No              httpsPort      Https port for mock server      No              mockedDirectory      Path to the mocked data directory (default: resources/mocked-data w.r.t working directory).      No              sessions      Number of parallel sessions to start the mock server with (default: 0)      No              collectMetrics      Enable mock server to collect usage metrics (default: true)      No              project      Name for your project (default: default)      No      Examplevar shifu = require('shifu');shifu.start({  host: 'localhost',  port: 12000,  httpsPort: 12001,  mockedDirectory: '/resources/mockedData',  sessions: 3,  project: 'My Project'});Stop Mock Server - stop()This API allows to stop the mock server.shifu.stop(server, callback);The following attributes are supported:            Attribute      Description      Required                  server      server instance returned by start() method      Yes              callback      The first argument to callback function is an error if an error is encountered in stopping the server, null otherwise      No      Examplevar shifu = require('shifu');var server = shifu.start(options, callback);// do something with mock servershifu.stop(server, function (error) {  if (error) {      console.log('Unable to stop mock server');  } else {      console.log('Mock Server stopped');  }});Create Mocked Route - route()This API allows to create/add required mocked REST endpoints.shifu.route(options);The following attributes are supported:            Attribute      Description      Required                  options      JSON object with the attributes described in the table below      Yes      where options has the following attributes:            Attribute      Description      Required                  id      The unique route id for the mock server      Yes              label      The route label used for display on the Shifu Admin Panel      No              path      The route path      Yes              method      The HTTP route method (defaults to GET)      No              handler      The HAPI route handler which provides the route response. This is optional because you could use multiple variants to handle the response (See Variants)      No      Examplevar shifu = require('shifu');shifu.route({  id: 'my_route',  label: 'My Route',  path: '/api/foo',  method: 'GET',  handler: function(request, reply) {    // Add logic for handler    reply('Hello');  }});Create Variant - variant()This API allows to create/add variants. Variants are route handlers that you can select manually (via Shifu Admin panel) or Rest call or through Node API to select a different dataset for the response for a given route. Variants are defined using the variant() method on the Route object (returned by calling the route method).shifu.route(routeOptions).variant(options)The following attributes are supported:            Attribute      Description      Required                  options      JSON object with the attributes described in the table below      Yes      where options has the following attributes:            Attribute      Description      Required                  id      The unique variant id for a given route      Yes              label      The route label used for display on the Admin Panel      No              handler      The HAPI route handler which provides the variant response for the route      No      Examplevar shifu = require('shifu');shifu.route({  id: 'my_route',  path: '/api/foo',  handler: function(request, reply) {    // this is essentially the same as the \"default\" variant    reply({firstName: 'John'});  }}).variant({  id: 'Billy',  handler: function(request, reply) {    reply({firstName: 'Billy'});  }}).variant({  id: 'Clark',  handler: function(request, reply) {    reply({firstName: 'Billy'});  }});Set variant - setMockVariant()setMockVariant can be used to set a variant to an existing API path.shifu.setMockVariant(options, callback) // with Shifu libraryor browser.setMockVariant(options, callback) // when using MagellanThe following attributes are supported:            Attribute      Description      Required                  options      JSON object with the attributes described in the table below      No              callback      callback function to be called after setMockVariant()      Yes      where options has the following attributes:            Attribute      Description      Required                  fixture      Id defined in route      Yes              variant      The variant defined in endpoint.js for the fixture you entered      Yes              portNumber      Port number where the mock server is running on      No              shifuSessionId      Shifu session id, if using parallel sessions      No      ExampleIf the routes are defined likevar shifu = require('shifu');shifu.route({  id: 'hello',  path: '/helloWorld',  handler: function(request, reply) {    reply('Hello World');  }}).variant({  id: 'universe',  handler: function(request, reply) {    reply('Hello Universe');  }});For the route and variant defined as above, you can set the variant to universe as follows:// when using Shifu libraryshifu.setMockVariant({    fixture: 'hello', // same as id in the .route() options    variant: 'universe' // same as id in the .variant() options}, function (err) {    if (err) {        console.log('Error in setting variant:' + err);    } else {        console.log('Successfully set variant');    }});or // When using Magellanbrowser.setMockVariant({ fixture: \"hello\", variant: \"universe\" });or Alternately, you can also use `curl` call to set a variant with this POST call to `{host}:{port}/shifu/api/route/{routeId}`curl -H \"Content-Type: application/json\" -X POST -d '{\"variant\":\"{universe}\"}' http://localhost:8080/shifu/api/route/hello?returnConfig=trueYou can confirm if this works by going to Admin panel and see that for helloWorld route, the variant universe will be highlighted. Also, hitting this url http://localhost:8080/helloWorld will reply with Hello Universe.If the variant does not exist on the route, mock server returns with an Internal Server error (HTTP 500).Add global variants - addGlobalVariant()You can also add global variants that will affect all routes. The attributes to the options are same as that of variant().shifu.route(routeOptions).addGlobalVariant(options)whereoptions - JSON object with the same attributes as of variant described in this sectionExamplevar shifu = require('shifu');shifu.addGlobalVariant({  id: '500',  label: '500 error',  handler: function(request, reply) {    reply({      statusCode: 500,      error: 'Internal Server Error'    }).code(500);  }})Respond With File - respondWithFile()This API allows to respond with static data stored in a file instead of hard coding the response data in the routes definition. Based on the path of the URL that is being mocked, the response file can be dropped in the directory location and the file will be automatically used by Shifu for sending the response. It also allows to specify the absolute path of the response files.shifu.util.respondWithFile(route, reply, options);The following attributes are supported:            Attribute      Description      Required                  route      Handle to the shifu route object      Yes              reply      Handle to the reply object      Yes              options      JSON object with additional options desribed below      No                  Attribute      Description      Required                  code      HTTP Status code to reply with      No              filePath      Static file path of the mocked data      No              delay      Delay response time by this value (in milliseconds)      No      To use this feature, you can call respondWithFile() from inside route configuration as follows:Examplevar shifu = require('shifu');// Automatic reply of the fileshifu.route({  id: 'Get Collection',  label: 'Get Collections',  path: '/product/grouping/api/collection/{collectionId}'  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }}).variant({  id: 'mixItem',  label: 'Mix Item'  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {code: 204, filePath: '../mocked-data/fileName.json', delay: 1000});  }})Note the Use of shifu.util to access the method respondWithFileRespond with mock variant - respondWithMockVariant()This API allows to respond with a variant on the main route handler. The ‘variant’ passed in MUST be the variant on existing route.shifu.util.respondWithMockVariant(route, variant, req, reply)The following attributes are supported:            Attribute      Description      Required                  route      The route object      Yes              variant      Variant on the route      Yes              request      Request object      Yes              reply      Reply object      Yes      Examplevar shifu = require('shifu');shifu.route({    id: 'respondWithVariant',    label: 'Respond With Variant',    path: '/respondWithVariant',    variantLabel: 'Respond With Main Route',    handler: function(req, reply) {        shifu.util.respondWithMockVariant(this, 'variant', req, reply); // make sure that the variant exist in the same route.    }}).variant({    id: 'variant',    label: 'Respond With Variant Route',    handler: function(req, reply) {        reply({            'message': 'I am an example of respond_with_mock_variant instead of response of main route '        });    }});Note the Use of shifu.util to access the method respondWithMockVariantSet Mock Id - setMockId()This API allows to set mock id for a given test case. If this is set, it overrides all the variants and mocked URLs responses to return mocked data from the given directory as mock-id, where mock-id is the directory name.shifu.setMockId(mockId, shifuSessionId) // with Shifu libraryor browser.setMockId(mocKId, shifuSessionId, callback); // when using MagellanThe following attributes are supported:            Attribute      Description      Required                  mockId      Mock id which is the directory name you want to respond data from      Yes              shifuSessionId      Shifu session id, if using parallel sessions      No              callback      callback function to be invoked after mock id is set (only when using Magellan)      No      The file name should be in the format url-methodName-urlCount.extension for the responses stored under file. For example, for the given route belowvar shifu = require('shifu');shifu.route({  id: 'my_route',  label: 'My Route',  path: '/api/foo',  method: 'GET',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }});the file name should be api-foo-GET-1.json for the first time the URL is hit. For second time the URL is hit, the file name returned would be api-foo-GET-2.json. If the specific file for the count is not present, Shifu will look for default file api-foo-GET.json, which is also helpful if you want to always return the same response irrespective of the number of times the URL is hit.Example:var shifu = require('shifu');shifu.setMockId('cart', 'abcdef'); // All responses should be under \"cart\" directory under your mocked data directoryor browser.setMockId('cart', 'abcdef' , callback);orcurl http://localhost:8000/shifu/api/setMockId/cart/abcdefTIP! For a dynamic url such as /app/{cartid}/getStatus the default file name should be app-cartid-getStatus-GET.json and the count specific file name should be like app-cartid-getStatus-GET-1.json.Get Mock Id - getMockId()This API is used to retrieve the currently set mock id.shifu.getMockId(shifuSessionId);The following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id, if using parallel sessions      No      Example:var shifu = require('shifu');var mockId = shifu.getMockId('abcdef');or curl http://localhost:8000/shifu/api/getMockId/cart/abcdefNote that abcdef is the session id in use for the current test (optional, if not using parallel sessions)Reset Mock Id - resetMockId()This API is used to reset currently set mock id.shifu.resetMockId(shifuSessionId) // with Shifu libraryor browser.resetMockId(shifuSessionId, callback); // when using MagellanThe following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id, if using parallel sessions      No              callback      callback function to be invoked after mock id is set (only when using Magellan)      No      Example:var shifu = require('shifu');shifu.resetMockId('abcdef');or browser.resetMockId('abcdef', callback);or curl http://localhost:8000/shifu/api/resetMockId/cart/abcdefNote that abcdef is the session id in use for the current test (optional, if not using parallel sessions)Reset url count - resetURLCount()This API is used to reset URL count to zero. This works in conjunction with setMockId function where you want to restart over for the URL count.shifu.resetURLCount(shifuSessionId)or browser.resetURLCount(shifuSessionId, callback)The following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id, if using parallel sessions      No              callback      callback function to be be invoked after the mock id is reset      No      Example:var shifu = require('shifu');shifu.resetURLCount('abcdef');or browser.resetCount('abcdef', callback); // 'abcdef' is a shifu session id in use for the testorcurl http://localhost:8000/shifu/api/resetURLCount/abcdefNote that abcdef is the session id in use for the current test (optional, if not using parallel sessions)Get url count - getURLCount()This API is used in conjunction with setMockId function where you want to get the URL count for all mocked calls.shifu.getURLCount(shifuSessionId)The following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id, if using parallel sessions      No      Example:var shifu = require('shifu');shifu.getURLCount('abcdef');or curl http://localhost:8000/shifu/api/getURLCount/abcdefNote that abcdef is the session id in use for the current test (optional, if not using parallel sessions)Register session - registerSession()This API is used to register a session with Shifu for a test case when using parallel sessions. Shifu needs to be started with sessions.shifu.registerSession(); // with Shifu libraryor browser.registerSession(callback); // with browser testsThe following attributes are supported:            Attribute      Description      Required                  callback      callback function to be be invoked after the session is registered. First argument to the callback is an error object, in case of error, null otherwise. The second argument is the registered session id (Only for browser tests)      Yes      You can use registerSession() to register a session with Shifu and can subsequently use that session id for the current test. Shifu returns a unique identifier when registering a session.If no session is available to use, Shifu returns with the message NOT_AVAILABLE.ExampleIf shifu server is started with sessions, for e.g 3 sessions as shown below,var shifu = require('shifu');shifu.start({    host: 'localhost',    port: 8080,    mockedDirectory: 'resources/mockedData',    sessions: 3});var shifuSessionId = shifu.registerSession();or browser.registerSession(function (err, sessId) {    if (err) {      return callback(new Error(\"Unable to get the sessionId\"));    }    self.shifuSessionId = sessId;    client.shifuSessionId = sessId;     return callback();});orcurl http://localhost:8000/shifu/api/registerSessionClose session - closeSession()This API is used to close a session after running a test so it can be made available for subsequent tests.shifu.closeSession(shifuSessionId);or browser.closeSession(shifuSessionId, callback);The following attributes are supported:            Attribute      Description      Required                  shifuSesssionId      Shifu session id to be closed      Yes              callback      callback function to be be invoked after the session is registered. First argument to the callback is an error object, in case of error, null otherwise (Only when using browser tests)      Yes      Examplevar shifu = require('shifu);shifu.closeSession('abcdef'); // abcdef is a previously registered session with Shifuor client.closeSession('abcdef', function (err) {  if (err) {    console.error(\"Error in closing session:\");  }});orcurl http://localhost:8000/shifu/api/closeSession/abcdefNote that abcdef is a previously registered session with Shifu.Check session - checkSession()This API is used to check status of a session id. It returns one of these states  AVAILABLE - If the session is available for use  IN_USE - If the session is in use  DOES_NOT_EXISTS - If the session id passed is invalid or does not existThe following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id      Yes      Examplevar shifu = require('shifu);var status = shifu.checkSession('abcdef');or curl http://localhost:8000/shifu/api/checkSession/abcdefGet sessions - getSessions()This API is used to get sessions informationshifu.getSessions();Examplevar shifu = require('shifu);var status = shifu.getSessions();or curl http://localhost:8000/shifu/api/getSessionsClear sessions - clearSessions()This API is used to clear the sessions information.shifu.clearSessions();Examplevar shifu = require('shifu);var status = shifu.clearSessions();Get project name - getProjectName()This API is used to get the project name passed in Shifu optionsshifu.getProjectName();Examplevar shifu = require('shifu);var projectName = shifu.getProjectName();Get port information - getPortInfo()This API is used to get the port information passed in Shifu optionsshifu.getPortInfo();Examplevar shifu = require('shifu);var portInfo = shifu.getPortInfo();Add state - addState()This API is used to add a value to the server state.shifu.addState(route, key, value);The following attributes are supported:            Attribute      Description      Required                  route      Route object      Yes              key      Key for the state variable      Yes              value      Value of the state variable      Yes      Examplevar shifu = require('shifu);shifu.route({  id: 'setState',  label: 'Add State',  path: '/login',  handler: function (req, reply) {    shifu.addState(this, 'loggedIn', true);    reply().code(204);  }});Get state - getState()This API is used to read a value from the server state.shifu.getState(route, key);The following attributes are supported:            Attribute      Description      Required                  route      Route object      Yes              key      Key for the state variable      Yes      Examplevar shifu = require('shifu);shifu.route({  id: 'getState',  label: 'Get State',  path: '/isLogin',  handler: function (req, reply) {    var isLoggedIn = shifu.getState(this, 'login');    reply(isLoggedIn);  }});Clear state - clearState()This API is used to clear a state for a given session id (Defaults to default session).shifu.clearState(shifuSessionId);The following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id      No      Examplevar shifu = require('shifu);shifu.clearState(); // Clears state for default sessionshifu.clearState('abcdef') // Clears state for session id `abcdef`Enable Metrics - enableMetrics()This API is used to enable gathering of usage metrics.shifu.enableMetrics(boolean);The following attributes are supported:            Attribute      Description      Required                  boolean      true to enable, false to disable      No      Examplevar shifu = require('shifu);shifu.enableMetrics(true); // Enables gathering of usage metricsshifu.enableMetrics(false); // Disables gathering of usage metricsCheck if metrics are enabled - isMetricsEnabled()This API is used to check if metrics gathering is enabled on Shifu. Returns true if metrics gathering is enabled, false otherwiseshifu.isMetricsEnabled();Examplevar shifu = require('shifu);shifu.isMetricsEnabled();Dynamic transposition of JSON data - transposeData()This API allows to dynamically transpose the JSON datashifu.util.transposeData(dataSet, dataToChange);The following attributes are supported:            Attribute      Description      Required                  dataSet      The data set which needs to change      Yes              dataToChange      The changes needed in the data set      Yes      To change the JSON data on fly (edit existing values or add values).// Base JSON file{  \"items\":  {    \"item\":    [      {        \"id\": \"0001\",        \"type\": \"donut\",        \"name\": \"Cake\",        \"ppu\": 0.55,        \"batters\":        {          \"type\" : 1,          \"batter\":          [            { \"id\": \"1001\", \"type\": \"Regular\" },          ]        },        \"topping\":        [          { \"id\": \"5001\", \"type\": \"None\" }        ]      }    ]  }}// Code examplevar dataToChange = { 'items.item[0].id': 1234, // substitue id 0001 to 1234 'items.item[0].val': \"value\", // Add 'val' to first array element of items.item 'items.item[1].id': 4567, // Add 'id' to second array element of items.item 'items.item[0].batters.batter[0].id': 5678 // substitue id 1001 to 5678}// when using utils classvar fileLocation = require(\"path\").join(__dirname, './resources/test-data/data-transposition-test.json');var dataSet = utils.readJsonFile(fileLocation);substitutedData = shifu.util.transposeData(dataSet, dataToChange);// When using with respondwithFile (This will read the file based on url path and transpose the data)shifu.util.respondWithFile(this, reply, {transpose: dataToChange});// Resulted JSON{  \"items\": {    \"item\": [      {        \"id\": 1234,        \"type\": \"donut\",        \"name\": \"Cake\",        \"ppu\": 0.55,        \"val\": \"value\"        \"batters\": {          \"type\": 1,          \"batter\": [            {\"id\": 5678, \"type\": \"Regular\"}          ]        },        \"topping\": [          {\"id\": \"5001\", \"type\": \"None\"}        ]      },      {        \"id\": 4567      }    ]  }}Note the Use of shifu.util to access the method transposeDataKill process - killProcess()This API allows to Kill a process with a pidshifu.util.killProcess(pid, signal, callback);The following attributes are supported:            Attribute      Description      Required                  pid      process id to kill      Yes              signal      Signal to send (defaults to SIGKILL if passed undefined)      Yes              callback      Callback function  after killprocess completes      No      Examplevar shifu = require('shifu);shifu.util.killProcess(18222, 'SIGKILL', function () {  console.log('Process killed);});Note the Use of shifu.util to access the method killProcessRead contents of a file - readFile()This API allows to read contents of a file asynchronouslyshifu.util.readFile(filePath, callback);The following attributes are supported:            Attribute      Description      Required                  file path      Absolute or relative location of file      Yes              callback      Callback function after file is read. If file is read successfully, the second argument is the file data. In case of error, the first argument is an error. Returns promise if callback is omitted      No      Examplevar shifu = require('shifu);shifu.util.readFile('data.json', function (err, fileData) {  if (err) {    console.log('Error in reading file ', err);  } else {    console.log(fileData);  }});Note the Use of shifu.util to access the method readFileRead contents of a file - readFileSynchronously()This API allows to read contents of a file synchronouslyshifu.util.readFileSynchronously(filePath);The following attributes are supported:            Attribute      Description      Required                  file path      Absolute or relative location of file      Yes      Examplevar shifu = require('shifu);shifu.util.readFileSynchronously('data.json');Note the Use of shifu.util to access the method readFileSynchronouslyRead contents of JSON file - readJsonFile()This API allows to read contents of a JSON file synchronouslyshifu.util.readJsonFile(filePath);The following attributes are supported:            Attribute      Description      Required                  file path      Absolute or relative location of JSON file      Yes      Examplevar shifu = require('shifu);shifu.util.readJsonFile('data.json');Note the Use of shifu.util to access the method readJsonFileWrite to file - writeFile()This API allows to write file contents to a fileshifu.util.writeFile(filePath, file data, callback);The following attributes are supported:            Attribute      Description      Required                  file path      Absolute or relative location of file      Yes              file data      contents to write      Yes              callback      Callback function after writeFile completes      Yes      Examplevar shifu = require('shifu);shifu.util.writeFile('hello.txt', 'hello world blah blah', function () {  console.log('Wrote to file successfully');});Note the Use of shifu.util to access the method writeFileDelete file - deleteFile()This API allows to write file contents to a fileshifu.util.deleteFile(filePath, callback);The following attributes are supported:            Attribute      Description      Required                  file location      Absolute or relative location of file to delete      Yes              callback      Callback function after deleteFile completes      Yes      Examplevar shifu = require('shifu);shifu.util.deleteFile('filetoDelete.txt', function (err) {  if (err) {    console.log('Error in deleting file');  }});Note the Use of shifu.util to access the method deleteFileCheck if directory exists - checkDirectoryExists()This API allows to check if a directory exists. Returns true if directory exists, false otherwise.shifu.util.checkDirectoryExists(directoryPath);The following attributes are supported:            Attribute      Description      Required                  directory path      Location of directory to check      Yes      Examplevar shifu = require('shifu);shifu.util.checkDirectoryExists('/home/data');Note the Use of shifu.util to access the method checkDirectoryExistsCheck if file exists - checkFileExists()This API allows to check if a file exists. Returns true if file exists, false otherwise.shifu.util.checkFileExists(filePath);The following attributes are supported:            Attribute      Description      Required                  file path      Location of file to check      Yes      Examplevar shifu = require('shifu);shifu.util.checkFileExists('/home/data');Note the Use of shifu.util to access the method checkFileExistsSet Log level - setLogLevel()This API allows to set log level on Shifushifu.log.setLogLevel(logLevel); // when using ShifuorLogger.setLogLevel(logLevel); // when using Shifu-LoggerThe following attributes are supported:            Attribute      Description      Required                  logLevel      Log level you want to set .Valid values (warn/info/debug/error)      Yes      Examplevar shifu = require('shifu);shifu.log.setLogLevel('debug');orcurl -X GET http://localhost:8080/shifu/api/setloglevel/debugGet Log level - getLogLevel()This API allows to get the current log level on Shifushifu.log.getLogLevel(); // when using Shifuor Logger.getLogLevel(); // when using Shifu-LoggerExamplevar shifu = require('shifu);shifu.log.getLogLevel();orvar Logger = require('shifu-logger');Logger.getLogLevel();orcurl -X GET http://localhost:8080/shifu/api/getloglevelReset Log level - resetLogLevel()This API allows to reset the log level of Shifu to info (Default log level)shifu.log.resetLogLevel();or Logger.resetLogLevel();Examplevar shifu = require('shifu);shifu.log.resetLogLevel();orvar Logger = require('shifu-logger');Logger.resetLogLevel();or curl -X GET http://localhost:8080/shifu/api/resetloglevel",
        "url": "/documentation/Mocking/Services/JAVASCRIPT/API Guide"
      },
    
      "mocking-native-ios-javascript-training-guide": {
        "title": "Training Guide",
        "content": "120 minMocking 101Covered topicsUnderstand of mocking solution and it's featuresHow to set up and start mock serverBasic usage of mocking solution's functionalitiesStart120 minMocking 201Covered topicsLearn creating dynamic URLsRead various REST call request informationCustomize mocked responseStart120 minMocking 301Covered topicsReturning responseSetMockId and APIs for itParallel SessionsStart120 minMocking 401Covered topicsMaintain states in mock serverMocking utility methodsSupported Rest APIs for mock serverStart",
        "url": "/Mocking/Native iOS/JAVASCRIPT/Training Guide"
      },
    
      "documentation-mocking-native-ios-javascript-introduction": {
        "title": "Introduction",
        "content": "Why Use Mock Server?Most of the applications rely on one or many back end services. For successful test execution and fast development, all the dependent backend services should be reliable 100% of the time. However that is not possible as the backend services may be down from time to time for various reasons or may have data inconsistency issues which makes testing/development against live services inefficient and time consuming.To overcome above mentioned limitations, our mocking solution can be used to quickly stub the API responses that are used by your application.We provide a mocking solution which can be leveraged to quickly stub the REST API responses that are used by your application during development or testing. The application points to the mock service host address instead of the live service. Pre-recorded responses are then returned for various endpoints from the mock service. Since there is minimal logic when writing mock service, maintenance and development cost for mock service is minimal. Some of the major development pain-points addressed by the mocking solution are:  Unstable services - Teams have saved upto 12 hours/week of development as well as testing time due to downtime / instability of external services.  Inconsistent Data - Teams have reduced the test data setup time by about 27 hours/week by eliminating the dependency on external teams for test data setup.  Test flakiness - Teams have reduced test flakiness by about 25%  Test against negative or unreal scenarios - Teams have reported to have increase test coverage for negative scenarios from no tests before to upto 15 test cases now by simulating service faults deterministicallySome of the key features of the mocking solution are:  Ease of setup - Very easy to setup mocked data and use it while development or testing your application  Drop and Respond - Respond with a JSON file based on the url route path automatically by dropping JSON response file in folder mapping to url path  Test Reuse - ability to execute test cases against mock or live serviceThe mocking solution helps the teams develop and test their web and mobile applications in local as well as CI environments.Feature list  Ease of setup - Very easy to setup mocked data and use it while development or testing your application  Test Reuse: Execute same test cases against mock or live service.  Drop-And-Respond: Respond with a JSON file based on the url route path automatically by dropping json response file in folder mapping to url path.  Test De-coupling: No coupling with test cases - Test cases are independent of mock implementation except that setting the desired response for the mock service (which has no impact if the test case is run against a live service).  Respond with mocked data from a directory: Mocked data response from specific directory irrespective of Rest APIs  Common Utilities: Common utility methods are provided as part of the mocking service which allows quicker test development.  UI Interface: Mock service UI for manual testing/debugging.  HTTPS Support: HTTPS support for all the urls.  Parallel Sessions: Support for single instance mock server for parallel processes  Shared Mock data: Allows fetching of mocked data and routes from multiple Git repositories  Magellan/Nightwatch integration: Ability to use mocking service with Magellan tests  Dynamic Transposition of Mock Data (JSON): Ability to modify response on the fly  Support for all file types: Auto evaluation of response file extension and mime type  Swagger integration: Automatic mock creator for web-services with swagger definition  Platform independent mocks: Mock any service irrespective of the language it is written in  Server states: Ability to mock server state  Support for Mobile applications: Ability to mock services for mobile applications  Manual tests against mock service: Ability to run tests manually against mock servicePlanned features  Ability to specify various data storage for mock data  Auto-refresh of data  Network and Test APIs to support instrumentation  Debugging tool to help development by supporting auto-replay of data  Support to auto-generate endpoint URLs for mocking  Support for changing mocked data via UI",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Introduction"
      },
    
      "documentation-mocking-native-ios-javascript-getting-started": {
        "title": "Getting Started",
        "content": "Pre-Requisite  Please install the latest Node.jsSetting Mock ServerTo set up mock server, you need only three things:  Install mock-server module.  Routes for mock-server.  Script to start mock-server.Follow the steps below to set-up mock server:  Create a new directory mock-server.  Create a new file package.json under mock-server directory.      Add Mock Server module dependency in package.json as shown below.     \"name\": \"&lt;name-for-your-project&gt;\", \"dependencies\": {   \"shifu\": \"^1.0.0\",   \"shifu-magellan-nightwatch\": \"^1.0.0\" // needed only for magellan/nightwatch }, \"scripts\": {     \"start-mock\": \"node mocks/run-mock-server-console.js\" }        Create another directory mocks under the mock-server directory.      Under the directory mocks, create a file endpoints.js with the following code - This file will contain the routes that you want to mock         var shifu = require('shifu'); // Required     shifu.id('example'); // Required     // add a route that returns a message \"hello world\"     shifu.route({         id: 'message',         label: 'hello message',         path: '/message',         method: 'GET',         variantLabel: 'hello world',         handler: function(req, reply) {           reply({message: 'hello world'});         }     });            Under the directory mocks, create a file run-mock-server-console.jswith the following code - This file will contain the start-up script for mock server         // load mocked endpoint     require('./endpoints');      var shifu = require('shifu');     shifu.start({       host: 'localhost',       mockedDirectory: './mocks', // this can be provided as an absolute path as well.       port: 8080,       project: 'HelloShifu', //Replace HelloShifu with your project name (without dashes).     });            Now open terminal/cmd prompt and navigate to the directory mock-server and run the following command to install Mock Server and dependencies:     npm install          Starting Mock Server      To start mock-server use the following command and than go to http://localhost:8080/shifu for mock-server admin-ui.     npm run start-mock      Common Use Cases      Starting mock server on HTTPS port -  To enable https, add httpsPort with the desired port number in server start script as shown below:      shifu.start({    port: 8080,    httpsPort: 4444,    host: 'localhost',    mockedDirectory: './test/resources/mocked-data',    project: 'HelloShifu'  });        Mocking different REST methods - To mock different rest methods, change the method value in the shifu.route() object to any one of the following desired values:          POST      GET      PUT      DELETE      OPTIONS      PATCH            Returning different data set for the same mocked route (Variants) - Variants allows to return a different set of data for the same mocked route. To add one or more variants, attach the variant object to shifu.route() as shown below:     shifu.route({   id: 'message',   label: 'Hello message',   path: '/message',   method: 'GET',   variantLabel: 'hello world',   handler: function (req, reply) {     reply({message:'Hello World'})   } }) .variant({    id: 'universe',    label: 'hello universe',    handler: function (req, reply) {      reply({message:'hello universe'})    }  })  .variant({    id: 'universe',    label: 'hello galaxy',    handler: function (req, reply) {      reply({message:'Hello Galaxy'})    }  });        To get a different set of response, go to admin-ui and select a different variant for the above route and hit http://localhost:8080/message on your favorite browser.        Storing mocked response in a file - This feature allows you to respond with a static data stored in a file instead of hard coding the response data in the routes definition.     // Automatic reply of the file shifu.route({   id: 'Get Collection',   label: 'Get Collections',   path: '/product/grouping/api/collection/test',   method: 'GET',   variantLabel: 'test-1',   handler: function(req, reply) {     shifu.util.respondWithFile(this, reply);   } }) .variant({    id: 'universe',    label: 'test-2',    handler: function (req, reply) {      shifu.util.respondWithFile(this, reply);    }  });        In the above setup, file needed for default route handler (test-1) should be located at (file location/name is based on mockedDirectory/route/method/[default|variant_name].{ext})     ./mocks/product/grouping/api/collection/GET/default.{ext}        If this would be a POST call than the file should have been at     ./mocks/product/grouping/api/collection/POST/default.{ext}        The file name for variants should change from default.{ext} to universe.{ext} in above example that is the file name should be the variant name.  Directing Traffic To Mock ServerTo mock live services, your application should allow to configure it to be directed to a mock service instead of live services as shown below:Please update your app server or application by changing the host name of your live service with the host name for your mock server.Mock Server Set-up Flow  Identify REST endpoints that needs to be mocked.  Gather mocked data for those REST endpoints.  Create Mocked Routes by adding them in endpoints.js file.  Start Mock Server.  Start Your Application server that points to the Mock Server host name instead of live-service.  Run your application and the mocked data will be returned for mocked routes.",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Getting Started"
      },
    
      "documentation-mocking-native-ios-javascript-faq": {
        "title": "FAQ",
        "content": "What Can Be Mocked?Any Restful service API can be mocked such as:  GET  POST  PUT  DELETE  OPTIONS  and so on..Can AJAX Calls Be Mocked?Yes - It is same as for any other backend service. For AJAX call, point it to the mocked server instance instead of the actual back end service and add a mocked route in the file containing mocked routes for mock server.What Are The Pre-Requisites?  node.js 4+ (npm is included in the package)How Can I Add Mock Server Dependency To My Node Project?\"dependencies\": {  \"shifu\": \"1.0.0\" // add the latest version}How To Add A Mocked Route?Add the following code in your routes file, typically endpoints.jsshifu.route({  id: 'helloWorld',                 // required  label: 'Hello World',             // Used for Mock Server UI  path: '/helloWorld',              // the path you want to mock  method: 'GET',                    // The Rest Method you want to mock for this API  handler: function (req, reply) {  // Add Logic to massage data before returning back to the request.    reply('Hello World');  }});How To Create Dynamic URLs?By adding the URL part in curly brackets that you would liek to by dynamic such as /get/customerInfo/{customerid}/{zipcode}For example:shifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}/{zipcode}', // both customerid and zipcode will be dynamic  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    reply('How to read the customer id :(');  }});How To Read Dynamic URLs In Request?var shifu = require('shifu');shifu.route({  path: '/get/customerInfo/{customerid}/{zipcode}'  handler: function(request, reply) {     var params = request.params;    var customerid = params.customerid; // customerid is 123 if request is \"/get/customerInfo/123/92127\"    var zipcode = params.zipcode;       // zipcode is 92127 if request is \"/get/customerInfo/123/92127\"  }}); How To Read Header Parameters In Request?var shifu = require('shifu');shifu.route({  path: '/api/getCart'  handler: function(request, reply) {    var headers = request.raw.req.headers;    var authorization = headers.authorization;  }}); How To Read Payload In Request?var shifu = require('shifu');shifu.route({  path: '/api/getCart'  handler: function(request, reply) {    var payload = request.payload;    // foo would be \"bar\" if the posted body content (as JSON) is {\"foo\": \"bar\"}    var foo = payload.foo;  }}); How To Read Query Parameters In Request?var shifu = require('shifu');shifu.route({  path: '/api/getCart'  handler: function(request, reply) {    var queryParams = request.query;    // foo would be \"bar\" if incoming request is \"/api/getCart?foo=bar\"    var foo = queryParams.foo;  }}); How To Set Custom Headers In Mocked Response?Preferred Wayshifu.route({  id: 'header',  label: 'Test Headers',  path: '/api/testHeaders',  handler: function (req, reply) {    var myHeaders = {      header1: 'test1',      header2: 'test2',      header3: true    };    shifu.util.respondWithFile(this, reply, {headers: myHeaders});  }});Alternate Wayshifu.route({  id: 'Get Collection',  label: 'Get Collections',  path: '/product/grouping/api/collection/{collectionId}',  handler: function(req, reply) {  reply({message: 'test'})    .header('X-Res-Header', 'I\\'m a custom response header')  }});How To Set Custom Cookies In Mocked Response?Preferred Wayshifu.route({  id: 'cookie',  label: 'Test Cookies',  path: '/api/testCookies',  handler: function (req, reply) {    var cookies = [      {name: 'com.wm.customer', value: 'vz7.0b5c56'},      {name: 'CID', value: 'SmockedCID', options: {domain: 'domain', path: '/'}},      {name: 'anotherCookie', value: 'cookieValue'}    ];        shifu.util.respondWithFile(this, reply, {cookies: cookies});  }});Alternate Wayshifu.route({  id: 'Get Collection',  label: 'Get Collections',  path: '/product/grouping/api/collection/{collectionId}',  handler: function(req, reply) {      reply({message: 'test'})       .state('test-cookie', 'I\\'m a custom response cookie')  }});  How To Set CORS Headers?var corsHeaders = {  origin: ['*'],  headers: [\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\"],  credentials: true,}// Itemsshifu.route({  id: 'tempo',  label: 'Tempo',  path: '/tempo1',      config: {    cors: corsHeaders  },  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }});What Is respondWithFile Utility?This feature allows you to respond with a data stored in a file instead of hard coding the response data in the routes definition. This way user does not have to hard-code/change the response in handler and rather can just swap the file with different data without even bringing the server down.  shifu.route({      id: 'ResponseFromFile',      label: 'Response From File',      path: '/get/fromFile',      handler: function(req, reply) {        shifu.util.respondWithFile(this, reply);      }  });In the above example, mock server will automatically look for a file default.{some_extension}  at ./mocked-data/get/fromFile/GET/default.{some_extension}How File Path Is Calculated For respondWithFile Utility?The path to the mocked data file is auto-calculated based on the route path. For example if the route path is /get/cart than for the default variant, mock server will look for the default.{some_extension} file at ./mocked-data/get/fromFile/GET/default.{some_extension}. For variants, the name of the file should be changed from default to the variant name as shown below:shifu.route({  id: 'ResponseFromFile',  label: 'Response From File',  path: '/get/fromFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }}).variant({  id: 'textData',  label: 'Text Data',  handler: function (req, reply) {    shifu.util.respondWithFile(this, reply);  }});In above example mock server will look for ./resources/mocked-data/get/fromFile/GET/textData.{some_extension} file for the variant textDataCan I Provide A Custom File Location respondWithFile Utility?Yes. By adding filePath parameter as shown in below example:shifu.route({  id: 'CustomResponseFile',  label: 'Response From Custom Path',  path: '/get/customFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {filePath: './custom.json'});  }});In above example mock server will look for the file under MockedDirectory only but at ./mocked-data/custom.jsonHow To Respond Only With Code?shifu.route({  id: 'message',  label: 'hello message',  path: '/message',  handler: function(req, reply) {    reply().code(400);  }});Can I Return A Response Code With respondWithFile Utility?Yes - by adding code parameter as shown in below example:shifu.route({  id: 'message',  label: 'hello message',  path: '/message',   handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {code: 400});  }});What Is MockedDirectory Path?Mocked directory path is the location to the base directory where all your mocked response file will be stored. This parameter is defined in run-mock-server-console.js file. It is defined at the start of mock server as shown in the code below:require('./endpoints');require('shifu').start({  host: \"localhost\",  mockedDirectory: \"./resources/mocked-data\",  port: 8000,  project: 'HelloShifu'});Location For Response File For RespondWithFile?If you have set your default folder to be mocked-data, then based on your URL path:For default variant, mock server will look for ./mocked-data/product/grouping/api/collection/GET/default.json and for mixItem variant mock server will look for ./mocked-data/product/grouping/api/collection/GET/mixItem.jsonWhat Are Variants?Variants allows to return a different data set for a given mocked route. Variants can be selected either in the admin UI or through automation APIs to determine what type of response a route should have. Routes are defined using the variant method on the Route object (returned by calling the route method). An object parameter is provided with the following attributes  id: the variant id - used for the RESTful admin API and profile settings  label: (optional) the variant label - used for display on the admin panel  handler: (optional) the HAPI route handler which provides the route responseVariants are useful because they allow you to test multiple scenarios that can happen with your route. Say, for example, you have a route exposing the ability to update a password. You might have several exceptional scenarios that you would want to test out (each could be a variant that you simply select to tell the route handler to use the appropriate response)  the password was reset successfully  the password didn’t pass validation  the old password wasn’t entered correctly  the username doesn’t exist  and so on…How To Add A Variant To A Route?To add a one or more variants do the following:shifu.route({  id: 'message',  label: 'Message',  path: '/get/message',  method: 'GET',  variantLabel: 'Hello',  handler: function (req, reply) {    reply('Hello');  }}) .variant({    id: 'hello',    label: 'Hello World',    handler: function (req, reply) {      reply('Hello World');    }  }).variant({    id: 'hello',    label: 'Hello Universe',    handler: function (req, reply) {      reply('Hello Universe');    }  });  How To Switch Variants In Test Case?browser.setMockVariant({ fixture: \"fixture id\", variant: \"variant id\" }); How To Switch Variants With HTTP Call?You can also switch the variants via HTTP call (Recommended only when not using Shifu as a library). As an example, if you want to set variant to helloUniverse for the route below:  shifu.route({    id: 'helloWorld',    label: 'Hello World',    path: '/helloWorld',    method: 'GET',    handler: function (req, reply) {      reply('Hello World');    }  })  .variant({    id: 'helloUniverse',    label: 'Hello Universe',    handler: function (req, reply) {      reply('Hello Universe');    }  });curl  -H \"Content-type: application/json\" -X POST -d '{\"variant\":\"&lt;variant&gt;\"}' &lt;host&gt;:&lt;port&gt;/shifu/api/route/&lt;routeId&gt;So for the above route, you can switch the variant to helloUniverse like this:curl  -H \"Content-type: application/json\" -X POST -d '{\"variant\":\"helloUniverse\"}' http://localhost:8000/shifu/api/route/helloWorldWhen using parallel sessions, if you want to switch a variant for a route for a particular session, register the session with mock server like this:curl &lt;host&gt;:&lt;port&gt;/shifu/api/registerSession// e.g curl http://localhost:8000/shifu/api/registerSessionIf sessions are available, mock server will return a response like: {\"session\":\"33b08d\"}Extract the session id from response and append it to the route id you want to switch variant for e.g:curl -H \"Content-type: application/json\" -X POST -d \"variant\":\"helloUniverse\"}' http://localhost:8000/shifu/api/route/helloWorld-33b08dWhat Is Mock Server UI Used For?UI can be used to view and test mocked routes as well as for manual switching of variants when running tests manually.What Is Parallel Sessions?Parallel sessions allows you to run multiple instance of server virtually while running only one server. This is helpful when you are running multiple test cases which access the same routes but different variants as parallel sessions allow you to set different variants on same routes without conflicting. This saves CPU and RAM both as only one server is running instead of multiple. Please see the call flow explaination without and with Parallel Sessions Below:Call Flow Without Parallel SessionsCall Flow With Parallel SessionsHow Can I Enable Parallel Sessions On Mock Server?Add sessions parameter with number of virtual services you want as shown in below example while startung mock Server.require('./endpoints');var shifu = require('shifu');shifu.start({  host: \"localhost\",  mockedDirectory: \"./resources/mocked-data\",  port: 8000,  sessions: 2,  project: 'HelloShifu'});How Can I Register a Session For Parallel Sessions?var sessionId = shifu.registerSession();How Can I Close A Session For Parallel Sessions?var closeSession = shifu.closeSession(sessionId);Does Mock Server Has Any Utility To Modify JSON Data Stored In Files?Yes - Mock Server exposes transpose option that cna be passed in respondWithFile method to modify the JSON files dynamically.How Does transposeData Work To Modify JSON Data Stored In Files?If you have many variants for a Rest end point and the mocked data for all variants can use the same JSON response with few changes to the values, than this feature is what you need. This feature allows you to dynamically change a JSON file before sending the response back from the mock server for the request. It removes the need of having one to one mapping of static JSON files with each variants.// Static Response JSON File{ id: \"1234\", name: \"toothpaste\" details: [   {    flavor: \"Mint 1\",    Size: \"10\",    Size_Type: ounce    },   {    flavor: \"Mint\",    Size: \"10\",    Size_Type: ounce   } ]}// Sample code for substituting id from 1234 to 7777 and flavor from Mint to Mint 2 for second array element in routesshifu.route({    id: 'Get Collection',    label: 'Get Collections',    path: '/product/grouping/api/collection/{collectionId}',     handler: function(req, reply) {      var dataToChange = {        'id': '7777',        'details[1].flavor': 'Mint 2'      }      shifu.util.respondWithFile(this, reply, {transpose: dataToChange});     }});// Dynamic Response JSON File returned from Mock service{ id: \"7777\", name: \"toothpaste\" details: [   {    flavor: \"Mint 1\",    Size: \"10\",    Size_Type: ounce    },   {    flavor: \"Mint 2\",    Size: \"10\",    Size_Type: ounce   } ]}Can I Use transposeData Functionality Outside Of respondWithFile?Yes - You can use it by Shifu Utils.var fileLocation = require(\"path\").join(__dirname, './resources/test-data/data-transposition-test.json');var dataSet = utils.readJsonFile(fileLocation);var dataToChange = { 'items.item[0].id': 1234, // substitue id 0001 to 1234 'items.item[0].val': \"value\", // Add 'val' to first array element of items.item 'items.item[1].id': 4567, // Add 'id' to second array element of items.item 'items.item[0].batters.batter[0].id': 5678 // substitue id 1001 to 5678}substitutedData = shifu.util.transposeData(dataSet, dataToChange);// Base JSON file - data-transposition-test.json{  \"items\":  {    \"item\":    [      {        \"id\": \"0001\",        \"type\": \"donut\",        \"name\": \"Cake\",        \"ppu\": 0.55,        \"batters\":        {          \"type\" : 1,          \"batter\":          [            { \"id\": \"1001\", \"type\": \"Regular\" },          ]        },        \"topping\":        [          { \"id\": \"5001\", \"type\": \"None\" }        ]      }    ]  }};// Resulted JSON{  \"items\": {    \"item\": [      {        \"id\": 1234,        \"type\": \"donut\",        \"name\": \"Cake\",        \"ppu\": 0.55,        \"val\": \"value\"        \"batters\": {          \"type\": 1,          \"batter\": [            {\"id\": 5678, \"type\": \"Regular\"}          ]        },        \"topping\": [          {\"id\": \"5001\", \"type\": \"None\"}        ]      },      {        \"id\": 4567      }    ]  }};Why Mock Server Returns Error 415 Unsupported Media Type?If you’re using content type like application/graphql, follow this example  shifu.route({    id: 'id',    label: 'id',    path: '/graphql',    method: ['POST', 'PUT'],    config : {      payload: {        parse: false,        allow: 'application/graphql'      }    },    handler: function (req, reply) {      shifu.util.respondWithFile(this, reply, {code: 200});    }  });For more details, read this",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/FAQ"
      },
    
      "documentation-mocking-native-ios-javascript-contribution-guide": {
        "title": "Contribution Guide",
        "content": "ArchitectureThese are the very high level components of mocking eco-system.The below diagram shows the mocking components in detail.The mocking service uses shifu-smocks which provides the stateful HTTP mocking service built on top of HAPI. It allows to add routes and different scenarios for each route.In addition, the mocking service provides certain utilities via shifu-util. It also provides logging facility with shifu-loggerMock Server Start flowThe mocking service exposes its features via API’s and HTTP end points. Lets take a look at the sequence of events when the mock server is started.In the above diagram, the actor can be the test code which starts mock server or a developer using the mock service for local development / testing.      Users can specify what routes to mock by specifying them in endpoints.js        Shifu’s start() is invoked with options to start the Shifu server        Shifu creates an instance of Hapi server        Shifu adds the routes for the system API’s it supports        Shifu gets the plugin from shifu-smocks        Shifu registers the plugin it obtained from the above step        Shifu starts the server        Once the Shifu server is started, you can use the Shifu API’s via HTTP Calls or libraries [Read API Guide for examples]  Parallel vs non-parallel sessionsWithout Parallel sessionsIf we want to run two test cases in parallel, mocking the same route and returning different data, it won’t be possible with running one  mock server and sharing across the whole test suite. So we needed to run one mock server and one application server per test case.With Parallel sessionsWith parallel sessions, we can share one application server and mock server for the whole test suite. It allows to mock the same route but different data for different test cases.To use parallel sessions, the mock server is started with pre-defined number of sessions. For each test, the test case needs to register a session with the mock server. The mock server returns a unique session id which is then sent as part of the request to the application server. If the request gets routed to the mock server for a mocked route, the request handler in mock server extracts the session id from the request, and prepends it to the route. For e.g, if the session id is “123”, it is prepended to the route “/api/getCart” and the route becomes “/123/api/getCart”. For another test using session id “456” , the route will become “/456/api/getCart”. This enables the mock server to be able to return two different responses for the same mocked route.Tech stackLanguage : NodejsNode Version: 4+Unit Tests: MochaCode formatting: EslintCode Coverage Report: IstanbulDeployment informationMocking components are released as npm librariesGit repository informationThe source code for all mocking components reside in Github.  Shifu  Shifu Util  Shifu Magellan Nightwatch  Shifu Logger  Shifu Smocks  Shifu SwaggerDevelopment processTo contribute to the mocking fleet, please follow these steps:      Fork the repository https://github.com/TestArmada/shifu. If your Github username is “abc” for e.g, your forked repository will be https://github.com/abc/shifu.        Clone this forked repository using git clone https://github.com/&lt;username&gt;/shifu.git and make “shifu” your working directory.        Create a branch on local with git checkout -b &lt;your branch name&gt;. Note The default branch for all projects is development so any branch you create will be off the development branch.        Install dependencies using npm install.        Make the code changes in the branch you created in step (3) and write / update the unit tests to verify your changes. Run unit tests using npm test. We use eslint to ensure code formatting. This step runs both unit tests as well as verifies code formatting. We use istanbul for code coverage reporting. 95% is the minimum code coverage we expect for all our components.        Once you’re ready, submit your pull request from your branch against the development branch of Shifu (https://github.com/TestArmada/shifu/tree/development). The PR triggers a Travis build which runs the tests in CI environment (same steps as in (5) above).        Once the PR is reviewed, a team member merges the PR into the development branch.        When the development branch is merged to master, a team member will push a tag to master, a Travis build is triggered and publishes a new version of the package to npm registry.  Note: The same steps above are applicable for contributing to any of the mocking components.",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/Contribution Guide"
      },
    
      "documentation-mocking-native-ios-javascript-api-guide": {
        "title": "API Guide",
        "content": "  Mocking API’s          Start Mock Server - start()      Stop Mock Server - stop()      Create Mocked Route - route()      Create Variant - variant()      Set variant - setMockVariant()      Add global variants - addGlobalVariant()      Respond With File - respondWithFile()      Respond with mock variant - respondWithMockVariant()      Set Mock Id - setMockId()      Get Mock Id - getMockId()      Reset Mock Id - resetMockId()      Reset url count - resetURLCount()      Get url count - getURLCount()      Register session - registerSession()      Close session - closeSession()      Check session - checkSession()      Get sessions - getSessions()      Clear sessions - clearSessions()      Get project name - getProjectName()      Get port information - getPortInfo()      Add state - addState()      Get state - getState()      Clear state - clearState()      Enable Metrics - enableMetrics()      Check if metrics are enabled - isMetricsEnabled()      Dynamic transposition of JSON data - transposeData()      Kill process - killProcess()      Read contents of a file - readFile()      Read contents of a file - readFileSynchronously()      Read contents of JSON file - readJsonFile()      Write to file - writeFile()      Delete file - deleteFile()      Check if directory exists - checkDirectoryExists()      Check if file exists - checkFileExists()      Set Log level - setLogLevel()      Get Log level - getLogLevel()      Reset Log level - resetLogLevel()      Mocking API’sStart Mock Server - start()This API allows to start the mock server.shifu.start(options, callback);The following attributes are supported:            Attribute      Description      Required                  options      JSON object with the attributes described in the table below      No              callback      The first argument to callback function is the server instance if the start is successful, else it is an error.      No      where options has the following attributes:            Attribute      Description      Required                  host      Hostname for mock server (default: localhost)      No              port      Port for mock server (default: 8080)      No              httpsPort      Https port for mock server      No              mockedDirectory      Path to the mocked data directory (default: resources/mocked-data w.r.t working directory).      No              sessions      Number of parallel sessions to start the mock server with (default: 0)      No              collectMetrics      Enable mock server to collect usage metrics (default: true)      No              project      Name for your project (default: default)      No      Examplevar shifu = require('shifu');shifu.start({  host: 'localhost',  port: 12000,  httpsPort: 12001,  mockedDirectory: '/resources/mockedData',  sessions: 3,  project: 'My Project'});Stop Mock Server - stop()This API allows to stop the mock server.shifu.stop(server, callback);The following attributes are supported:            Attribute      Description      Required                  server      server instance returned by start() method      Yes              callback      The first argument to callback function is an error if an error is encountered in stopping the server, null otherwise      No      Examplevar shifu = require('shifu');var server = shifu.start(options, callback);// do something with mock servershifu.stop(server, function (error) {  if (error) {      console.log('Unable to stop mock server');  } else {      console.log('Mock Server stopped');  }});Create Mocked Route - route()This API allows to create/add required mocked REST endpoints.shifu.route(options);The following attributes are supported:            Attribute      Description      Required                  options      JSON object with the attributes described in the table below      Yes      where options has the following attributes:            Attribute      Description      Required                  id      The unique route id for the mock server      Yes              label      The route label used for display on the Shifu Admin Panel      No              path      The route path      Yes              method      The HTTP route method (defaults to GET)      No              handler      The HAPI route handler which provides the route response. This is optional because you could use multiple variants to handle the response (See Variants)      No      Examplevar shifu = require('shifu');shifu.route({  id: 'my_route',  label: 'My Route',  path: '/api/foo',  method: 'GET',  handler: function(request, reply) {    // Add logic for handler    reply('Hello');  }});Create Variant - variant()This API allows to create/add variants. Variants are route handlers that you can select manually (via Shifu Admin panel) or Rest call or through Node API to select a different dataset for the response for a given route. Variants are defined using the variant() method on the Route object (returned by calling the route method).shifu.route(routeOptions).variant(options)The following attributes are supported:            Attribute      Description      Required                  options      JSON object with the attributes described in the table below      Yes      where options has the following attributes:            Attribute      Description      Required                  id      The unique variant id for a given route      Yes              label      The route label used for display on the Admin Panel      No              handler      The HAPI route handler which provides the variant response for the route      No      Examplevar shifu = require('shifu');shifu.route({  id: 'my_route',  path: '/api/foo',  handler: function(request, reply) {    // this is essentially the same as the \"default\" variant    reply({firstName: 'John'});  }}).variant({  id: 'Billy',  handler: function(request, reply) {    reply({firstName: 'Billy'});  }}).variant({  id: 'Clark',  handler: function(request, reply) {    reply({firstName: 'Billy'});  }});Set variant - setMockVariant()setMockVariant can be used to set a variant to an existing API path.shifu.setMockVariant(options, callback) // with Shifu libraryor browser.setMockVariant(options, callback) // when using MagellanThe following attributes are supported:            Attribute      Description      Required                  options      JSON object with the attributes described in the table below      No              callback      callback function to be called after setMockVariant()      Yes      where options has the following attributes:            Attribute      Description      Required                  fixture      Id defined in route      Yes              variant      The variant defined in endpoint.js for the fixture you entered      Yes              portNumber      Port number where the mock server is running on      No              shifuSessionId      Shifu session id, if using parallel sessions      No      ExampleIf the routes are defined likevar shifu = require('shifu');shifu.route({  id: 'hello',  path: '/helloWorld',  handler: function(request, reply) {    reply('Hello World');  }}).variant({  id: 'universe',  handler: function(request, reply) {    reply('Hello Universe');  }});For the route and variant defined as above, you can set the variant to universe as follows:// when using Shifu libraryshifu.setMockVariant({    fixture: 'hello', // same as id in the .route() options    variant: 'universe' // same as id in the .variant() options}, function (err) {    if (err) {        console.log('Error in setting variant:' + err);    } else {        console.log('Successfully set variant');    }});or // When using Magellanbrowser.setMockVariant({ fixture: \"hello\", variant: \"universe\" });or Alternately, you can also use `curl` call to set a variant with this POST call to `{host}:{port}/shifu/api/route/{routeId}`curl -H \"Content-Type: application/json\" -X POST -d '{\"variant\":\"{universe}\"}' http://localhost:8080/shifu/api/route/hello?returnConfig=trueYou can confirm if this works by going to Admin panel and see that for helloWorld route, the variant universe will be highlighted. Also, hitting this url http://localhost:8080/helloWorld will reply with Hello Universe.If the variant does not exist on the route, mock server returns with an Internal Server error (HTTP 500).Add global variants - addGlobalVariant()You can also add global variants that will affect all routes. The attributes to the options are same as that of variant().shifu.route(routeOptions).addGlobalVariant(options)whereoptions - JSON object with the same attributes as of variant described in this sectionExamplevar shifu = require('shifu');shifu.addGlobalVariant({  id: '500',  label: '500 error',  handler: function(request, reply) {    reply({      statusCode: 500,      error: 'Internal Server Error'    }).code(500);  }})Respond With File - respondWithFile()This API allows to respond with static data stored in a file instead of hard coding the response data in the routes definition. Based on the path of the URL that is being mocked, the response file can be dropped in the directory location and the file will be automatically used by Shifu for sending the response. It also allows to specify the absolute path of the response files.shifu.util.respondWithFile(route, reply, options);The following attributes are supported:            Attribute      Description      Required                  route      Handle to the shifu route object      Yes              reply      Handle to the reply object      Yes              options      JSON object with additional options desribed below      No                  Attribute      Description      Required                  code      HTTP Status code to reply with      No              filePath      Static file path of the mocked data      No              delay      Delay response time by this value (in milliseconds)      No      To use this feature, you can call respondWithFile() from inside route configuration as follows:Examplevar shifu = require('shifu');// Automatic reply of the fileshifu.route({  id: 'Get Collection',  label: 'Get Collections',  path: '/product/grouping/api/collection/{collectionId}'  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }}).variant({  id: 'mixItem',  label: 'Mix Item'  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {code: 204, filePath: '../mocked-data/fileName.json', delay: 1000});  }})Note the Use of shifu.util to access the method respondWithFileRespond with mock variant - respondWithMockVariant()This API allows to respond with a variant on the main route handler. The ‘variant’ passed in MUST be the variant on existing route.shifu.util.respondWithMockVariant(route, variant, req, reply)The following attributes are supported:            Attribute      Description      Required                  route      The route object      Yes              variant      Variant on the route      Yes              request      Request object      Yes              reply      Reply object      Yes      Examplevar shifu = require('shifu');shifu.route({    id: 'respondWithVariant',    label: 'Respond With Variant',    path: '/respondWithVariant',    variantLabel: 'Respond With Main Route',    handler: function(req, reply) {        shifu.util.respondWithMockVariant(this, 'variant', req, reply); // make sure that the variant exist in the same route.    }}).variant({    id: 'variant',    label: 'Respond With Variant Route',    handler: function(req, reply) {        reply({            'message': 'I am an example of respond_with_mock_variant instead of response of main route '        });    }});Note the Use of shifu.util to access the method respondWithMockVariantSet Mock Id - setMockId()This API allows to set mock id for a given test case. If this is set, it overrides all the variants and mocked URLs responses to return mocked data from the given directory as mock-id, where mock-id is the directory name.shifu.setMockId(mockId, shifuSessionId) // with Shifu libraryor browser.setMockId(mocKId, shifuSessionId, callback); // when using MagellanThe following attributes are supported:            Attribute      Description      Required                  mockId      Mock id which is the directory name you want to respond data from      Yes              shifuSessionId      Shifu session id, if using parallel sessions      No              callback      callback function to be invoked after mock id is set (only when using Magellan)      No      The file name should be in the format url-methodName-urlCount.extension for the responses stored under file. For example, for the given route belowvar shifu = require('shifu');shifu.route({  id: 'my_route',  label: 'My Route',  path: '/api/foo',  method: 'GET',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }});the file name should be api-foo-GET-1.json for the first time the URL is hit. For second time the URL is hit, the file name returned would be api-foo-GET-2.json. If the specific file for the count is not present, Shifu will look for default file api-foo-GET.json, which is also helpful if you want to always return the same response irrespective of the number of times the URL is hit.Example:var shifu = require('shifu');shifu.setMockId('cart', 'abcdef'); // All responses should be under \"cart\" directory under your mocked data directoryor browser.setMockId('cart', 'abcdef' , callback);orcurl http://localhost:8000/shifu/api/setMockId/cart/abcdefTIP! For a dynamic url such as /app/{cartid}/getStatus the default file name should be app-cartid-getStatus-GET.json and the count specific file name should be like app-cartid-getStatus-GET-1.json.Get Mock Id - getMockId()This API is used to retrieve the currently set mock id.shifu.getMockId(shifuSessionId);The following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id, if using parallel sessions      No      Example:var shifu = require('shifu');var mockId = shifu.getMockId('abcdef');or curl http://localhost:8000/shifu/api/getMockId/cart/abcdefNote that abcdef is the session id in use for the current test (optional, if not using parallel sessions)Reset Mock Id - resetMockId()This API is used to reset currently set mock id.shifu.resetMockId(shifuSessionId) // with Shifu libraryor browser.resetMockId(shifuSessionId, callback); // when using MagellanThe following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id, if using parallel sessions      No              callback      callback function to be invoked after mock id is set (only when using Magellan)      No      Example:var shifu = require('shifu');shifu.resetMockId('abcdef');or browser.resetMockId('abcdef', callback);or curl http://localhost:8000/shifu/api/resetMockId/cart/abcdefNote that abcdef is the session id in use for the current test (optional, if not using parallel sessions)Reset url count - resetURLCount()This API is used to reset URL count to zero. This works in conjunction with setMockId function where you want to restart over for the URL count.shifu.resetURLCount(shifuSessionId)or browser.resetURLCount(shifuSessionId, callback)The following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id, if using parallel sessions      No              callback      callback function to be be invoked after the mock id is reset      No      Example:var shifu = require('shifu');shifu.resetURLCount('abcdef');or browser.resetCount('abcdef', callback); // 'abcdef' is a shifu session id in use for the testorcurl http://localhost:8000/shifu/api/resetURLCount/abcdefNote that abcdef is the session id in use for the current test (optional, if not using parallel sessions)Get url count - getURLCount()This API is used in conjunction with setMockId function where you want to get the URL count for all mocked calls.shifu.getURLCount(shifuSessionId)The following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id, if using parallel sessions      No      Example:var shifu = require('shifu');shifu.getURLCount('abcdef');or curl http://localhost:8000/shifu/api/getURLCount/abcdefNote that abcdef is the session id in use for the current test (optional, if not using parallel sessions)Register session - registerSession()This API is used to register a session with Shifu for a test case when using parallel sessions. Shifu needs to be started with sessions.shifu.registerSession(); // with Shifu libraryor browser.registerSession(callback); // with browser testsThe following attributes are supported:            Attribute      Description      Required                  callback      callback function to be be invoked after the session is registered. First argument to the callback is an error object, in case of error, null otherwise. The second argument is the registered session id (Only for browser tests)      Yes      You can use registerSession() to register a session with Shifu and can subsequently use that session id for the current test. Shifu returns a unique identifier when registering a session.If no session is available to use, Shifu returns with the message NOT_AVAILABLE.ExampleIf shifu server is started with sessions, for e.g 3 sessions as shown below,var shifu = require('shifu');shifu.start({    host: 'localhost',    port: 8080,    mockedDirectory: 'resources/mockedData',    sessions: 3});var shifuSessionId = shifu.registerSession();or browser.registerSession(function (err, sessId) {    if (err) {      return callback(new Error(\"Unable to get the sessionId\"));    }    self.shifuSessionId = sessId;    client.shifuSessionId = sessId;     return callback();});orcurl http://localhost:8000/shifu/api/registerSessionClose session - closeSession()This API is used to close a session after running a test so it can be made available for subsequent tests.shifu.closeSession(shifuSessionId);or browser.closeSession(shifuSessionId, callback);The following attributes are supported:            Attribute      Description      Required                  shifuSesssionId      Shifu session id to be closed      Yes              callback      callback function to be be invoked after the session is registered. First argument to the callback is an error object, in case of error, null otherwise (Only when using browser tests)      Yes      Examplevar shifu = require('shifu);shifu.closeSession('abcdef'); // abcdef is a previously registered session with Shifuor client.closeSession('abcdef', function (err) {  if (err) {    console.error(\"Error in closing session:\");  }});orcurl http://localhost:8000/shifu/api/closeSession/abcdefNote that abcdef is a previously registered session with Shifu.Check session - checkSession()This API is used to check status of a session id. It returns one of these states  AVAILABLE - If the session is available for use  IN_USE - If the session is in use  DOES_NOT_EXISTS - If the session id passed is invalid or does not existThe following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id      Yes      Examplevar shifu = require('shifu);var status = shifu.checkSession('abcdef');or curl http://localhost:8000/shifu/api/checkSession/abcdefGet sessions - getSessions()This API is used to get sessions informationshifu.getSessions();Examplevar shifu = require('shifu);var status = shifu.getSessions();or curl http://localhost:8000/shifu/api/getSessionsClear sessions - clearSessions()This API is used to clear the sessions information.shifu.clearSessions();Examplevar shifu = require('shifu);var status = shifu.clearSessions();Get project name - getProjectName()This API is used to get the project name passed in Shifu optionsshifu.getProjectName();Examplevar shifu = require('shifu);var projectName = shifu.getProjectName();Get port information - getPortInfo()This API is used to get the port information passed in Shifu optionsshifu.getPortInfo();Examplevar shifu = require('shifu);var portInfo = shifu.getPortInfo();Add state - addState()This API is used to add a value to the server state.shifu.addState(route, key, value);The following attributes are supported:            Attribute      Description      Required                  route      Route object      Yes              key      Key for the state variable      Yes              value      Value of the state variable      Yes      Examplevar shifu = require('shifu);shifu.route({  id: 'setState',  label: 'Add State',  path: '/login',  handler: function (req, reply) {    shifu.addState(this, 'loggedIn', true);    reply().code(204);  }});Get state - getState()This API is used to read a value from the server state.shifu.getState(route, key);The following attributes are supported:            Attribute      Description      Required                  route      Route object      Yes              key      Key for the state variable      Yes      Examplevar shifu = require('shifu);shifu.route({  id: 'getState',  label: 'Get State',  path: '/isLogin',  handler: function (req, reply) {    var isLoggedIn = shifu.getState(this, 'login');    reply(isLoggedIn);  }});Clear state - clearState()This API is used to clear a state for a given session id (Defaults to default session).shifu.clearState(shifuSessionId);The following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id      No      Examplevar shifu = require('shifu);shifu.clearState(); // Clears state for default sessionshifu.clearState('abcdef') // Clears state for session id `abcdef`Enable Metrics - enableMetrics()This API is used to enable gathering of usage metrics.shifu.enableMetrics(boolean);The following attributes are supported:            Attribute      Description      Required                  boolean      true to enable, false to disable      No      Examplevar shifu = require('shifu);shifu.enableMetrics(true); // Enables gathering of usage metricsshifu.enableMetrics(false); // Disables gathering of usage metricsCheck if metrics are enabled - isMetricsEnabled()This API is used to check if metrics gathering is enabled on Shifu. Returns true if metrics gathering is enabled, false otherwiseshifu.isMetricsEnabled();Examplevar shifu = require('shifu);shifu.isMetricsEnabled();Dynamic transposition of JSON data - transposeData()This API allows to dynamically transpose the JSON datashifu.util.transposeData(dataSet, dataToChange);The following attributes are supported:            Attribute      Description      Required                  dataSet      The data set which needs to change      Yes              dataToChange      The changes needed in the data set      Yes      To change the JSON data on fly (edit existing values or add values).// Base JSON file{  \"items\":  {    \"item\":    [      {        \"id\": \"0001\",        \"type\": \"donut\",        \"name\": \"Cake\",        \"ppu\": 0.55,        \"batters\":        {          \"type\" : 1,          \"batter\":          [            { \"id\": \"1001\", \"type\": \"Regular\" },          ]        },        \"topping\":        [          { \"id\": \"5001\", \"type\": \"None\" }        ]      }    ]  }}// Code examplevar dataToChange = { 'items.item[0].id': 1234, // substitue id 0001 to 1234 'items.item[0].val': \"value\", // Add 'val' to first array element of items.item 'items.item[1].id': 4567, // Add 'id' to second array element of items.item 'items.item[0].batters.batter[0].id': 5678 // substitue id 1001 to 5678}// when using utils classvar fileLocation = require(\"path\").join(__dirname, './resources/test-data/data-transposition-test.json');var dataSet = utils.readJsonFile(fileLocation);substitutedData = shifu.util.transposeData(dataSet, dataToChange);// When using with respondwithFile (This will read the file based on url path and transpose the data)shifu.util.respondWithFile(this, reply, {transpose: dataToChange});// Resulted JSON{  \"items\": {    \"item\": [      {        \"id\": 1234,        \"type\": \"donut\",        \"name\": \"Cake\",        \"ppu\": 0.55,        \"val\": \"value\"        \"batters\": {          \"type\": 1,          \"batter\": [            {\"id\": 5678, \"type\": \"Regular\"}          ]        },        \"topping\": [          {\"id\": \"5001\", \"type\": \"None\"}        ]      },      {        \"id\": 4567      }    ]  }}Note the Use of shifu.util to access the method transposeDataKill process - killProcess()This API allows to Kill a process with a pidshifu.util.killProcess(pid, signal, callback);The following attributes are supported:            Attribute      Description      Required                  pid      process id to kill      Yes              signal      Signal to send (defaults to SIGKILL if passed undefined)      Yes              callback      Callback function  after killprocess completes      No      Examplevar shifu = require('shifu);shifu.util.killProcess(18222, 'SIGKILL', function () {  console.log('Process killed);});Note the Use of shifu.util to access the method killProcessRead contents of a file - readFile()This API allows to read contents of a file asynchronouslyshifu.util.readFile(filePath, callback);The following attributes are supported:            Attribute      Description      Required                  file path      Absolute or relative location of file      Yes              callback      Callback function after file is read. If file is read successfully, the second argument is the file data. In case of error, the first argument is an error. Returns promise if callback is omitted      No      Examplevar shifu = require('shifu);shifu.util.readFile('data.json', function (err, fileData) {  if (err) {    console.log('Error in reading file ', err);  } else {    console.log(fileData);  }});Note the Use of shifu.util to access the method readFileRead contents of a file - readFileSynchronously()This API allows to read contents of a file synchronouslyshifu.util.readFileSynchronously(filePath);The following attributes are supported:            Attribute      Description      Required                  file path      Absolute or relative location of file      Yes      Examplevar shifu = require('shifu);shifu.util.readFileSynchronously('data.json');Note the Use of shifu.util to access the method readFileSynchronouslyRead contents of JSON file - readJsonFile()This API allows to read contents of a JSON file synchronouslyshifu.util.readJsonFile(filePath);The following attributes are supported:            Attribute      Description      Required                  file path      Absolute or relative location of JSON file      Yes      Examplevar shifu = require('shifu);shifu.util.readJsonFile('data.json');Note the Use of shifu.util to access the method readJsonFileWrite to file - writeFile()This API allows to write file contents to a fileshifu.util.writeFile(filePath, file data, callback);The following attributes are supported:            Attribute      Description      Required                  file path      Absolute or relative location of file      Yes              file data      contents to write      Yes              callback      Callback function after writeFile completes      Yes      Examplevar shifu = require('shifu);shifu.util.writeFile('hello.txt', 'hello world blah blah', function () {  console.log('Wrote to file successfully');});Note the Use of shifu.util to access the method writeFileDelete file - deleteFile()This API allows to write file contents to a fileshifu.util.deleteFile(filePath, callback);The following attributes are supported:            Attribute      Description      Required                  file location      Absolute or relative location of file to delete      Yes              callback      Callback function after deleteFile completes      Yes      Examplevar shifu = require('shifu);shifu.util.deleteFile('filetoDelete.txt', function (err) {  if (err) {    console.log('Error in deleting file');  }});Note the Use of shifu.util to access the method deleteFileCheck if directory exists - checkDirectoryExists()This API allows to check if a directory exists. Returns true if directory exists, false otherwise.shifu.util.checkDirectoryExists(directoryPath);The following attributes are supported:            Attribute      Description      Required                  directory path      Location of directory to check      Yes      Examplevar shifu = require('shifu);shifu.util.checkDirectoryExists('/home/data');Note the Use of shifu.util to access the method checkDirectoryExistsCheck if file exists - checkFileExists()This API allows to check if a file exists. Returns true if file exists, false otherwise.shifu.util.checkFileExists(filePath);The following attributes are supported:            Attribute      Description      Required                  file path      Location of file to check      Yes      Examplevar shifu = require('shifu);shifu.util.checkFileExists('/home/data');Note the Use of shifu.util to access the method checkFileExistsSet Log level - setLogLevel()This API allows to set log level on Shifushifu.log.setLogLevel(logLevel); // when using ShifuorLogger.setLogLevel(logLevel); // when using Shifu-LoggerThe following attributes are supported:            Attribute      Description      Required                  logLevel      Log level you want to set .Valid values (warn/info/debug/error)      Yes      Examplevar shifu = require('shifu);shifu.log.setLogLevel('debug');orcurl -X GET http://localhost:8080/shifu/api/setloglevel/debugGet Log level - getLogLevel()This API allows to get the current log level on Shifushifu.log.getLogLevel(); // when using Shifuor Logger.getLogLevel(); // when using Shifu-LoggerExamplevar shifu = require('shifu);shifu.log.getLogLevel();orvar Logger = require('shifu-logger');Logger.getLogLevel();orcurl -X GET http://localhost:8080/shifu/api/getloglevelReset Log level - resetLogLevel()This API allows to reset the log level of Shifu to info (Default log level)shifu.log.resetLogLevel();or Logger.resetLogLevel();Examplevar shifu = require('shifu);shifu.log.resetLogLevel();orvar Logger = require('shifu-logger');Logger.resetLogLevel();or curl -X GET http://localhost:8080/shifu/api/resetloglevel",
        "url": "/documentation/Mocking/Native iOS/JAVASCRIPT/API Guide"
      },
    
      "mocking-native-android-javascript-training-guide": {
        "title": "Training Guide",
        "content": "120 minMocking 101Covered topicsUnderstand of mocking solution and it's featuresHow to set up and start mock serverBasic usage of mocking solution's functionalitiesStart120 minMocking 201Covered topicsLearn creating dynamic URLsRead various REST call request informationCustomize mocked responseStart120 minMocking 301Covered topicsReturning responseSetMockId and APIs for itParallel SessionsStart120 minMocking 401Covered topicsMaintain states in mock serverMocking utility methodsSupported Rest APIs for mock serverStart",
        "url": "/Mocking/Native Android/JAVASCRIPT/Training Guide"
      },
    
      "documentation-mocking-native-android-javascript-introduction": {
        "title": "Introduction",
        "content": "Why Use Mock Server?Most of the applications rely on one or many back end services. For successful test execution and fast development, all the dependent backend services should be reliable 100% of the time. However that is not possible as the backend services may be down from time to time for various reasons or may have data inconsistency issues which makes testing/development against live services inefficient and time consuming.To overcome above mentioned limitations, our mocking solution can be used to quickly stub the API responses that are used by your application.We provide a mocking solution which can be leveraged to quickly stub the REST API responses that are used by your application during development or testing. The application points to the mock service host address instead of the live service. Pre-recorded responses are then returned for various endpoints from the mock service. Since there is minimal logic when writing mock service, maintenance and development cost for mock service is minimal. Some of the major development pain-points addressed by the mocking solution are:  Unstable services - Teams have saved upto 12 hours/week of development as well as testing time due to downtime / instability of external services.  Inconsistent Data - Teams have reduced the test data setup time by about 27 hours/week by eliminating the dependency on external teams for test data setup.  Test flakiness - Teams have reduced test flakiness by about 25%  Test against negative or unreal scenarios - Teams have reported to have increase test coverage for negative scenarios from no tests before to upto 15 test cases now by simulating service faults deterministicallySome of the key features of the mocking solution are:  Ease of setup - Very easy to setup mocked data and use it while development or testing your application  Drop and Respond - Respond with a JSON file based on the url route path automatically by dropping JSON response file in folder mapping to url path  Test Reuse - ability to execute test cases against mock or live serviceThe mocking solution helps the teams develop and test their web and mobile applications in local as well as CI environments.Feature list  Ease of setup - Very easy to setup mocked data and use it while development or testing your application  Test Reuse: Execute same test cases against mock or live service.  Drop-And-Respond: Respond with a JSON file based on the url route path automatically by dropping json response file in folder mapping to url path.  Test De-coupling: No coupling with test cases - Test cases are independent of mock implementation except that setting the desired response for the mock service (which has no impact if the test case is run against a live service).  Respond with mocked data from a directory: Mocked data response from specific directory irrespective of Rest APIs  Common Utilities: Common utility methods are provided as part of the mocking service which allows quicker test development.  UI Interface: Mock service UI for manual testing/debugging.  HTTPS Support: HTTPS support for all the urls.  Parallel Sessions: Support for single instance mock server for parallel processes  Shared Mock data: Allows fetching of mocked data and routes from multiple Git repositories  Magellan/Nightwatch integration: Ability to use mocking service with Magellan tests  Dynamic Transposition of Mock Data (JSON): Ability to modify response on the fly  Support for all file types: Auto evaluation of response file extension and mime type  Swagger integration: Automatic mock creator for web-services with swagger definition  Platform independent mocks: Mock any service irrespective of the language it is written in  Server states: Ability to mock server state  Support for Mobile applications: Ability to mock services for mobile applications  Manual tests against mock service: Ability to run tests manually against mock servicePlanned features  Ability to specify various data storage for mock data  Auto-refresh of data  Network and Test APIs to support instrumentation  Debugging tool to help development by supporting auto-replay of data  Support to auto-generate endpoint URLs for mocking  Support for changing mocked data via UI",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Introduction"
      },
    
      "documentation-mocking-native-android-javascript-getting-started": {
        "title": "Getting Started",
        "content": "Pre-Requisite  Please install the latest Node.jsSetting Mock ServerTo set up mock server, you need only three things:  Install mock-server module.  Routes for mock-server.  Script to start mock-server.Follow the steps below to set-up mock server:  Create a new directory mock-server.  Create a new file package.json under mock-server directory.      Add Mock Server module dependency in package.json as shown below.     \"name\": \"&lt;name-for-your-project&gt;\", \"dependencies\": {   \"shifu\": \"^1.0.0\",   \"shifu-magellan-nightwatch\": \"^1.0.0\" // needed only for magellan/nightwatch }, \"scripts\": {     \"start-mock\": \"node mocks/run-mock-server-console.js\" }        Create another directory mocks under the mock-server directory.      Under the directory mocks, create a file endpoints.js with the following code - This file will contain the routes that you want to mock         var shifu = require('shifu'); // Required     shifu.id('example'); // Required     // add a route that returns a message \"hello world\"     shifu.route({         id: 'message',         label: 'hello message',         path: '/message',         method: 'GET',         variantLabel: 'hello world',         handler: function(req, reply) {           reply({message: 'hello world'});         }     });            Under the directory mocks, create a file run-mock-server-console.jswith the following code - This file will contain the start-up script for mock server         // load mocked endpoint     require('./endpoints');      var shifu = require('shifu');     shifu.start({       host: 'localhost',       mockedDirectory: './mocks', // this can be provided as an absolute path as well.       port: 8080,       project: 'HelloShifu', //Replace HelloShifu with your project name (without dashes).     });            Now open terminal/cmd prompt and navigate to the directory mock-server and run the following command to install Mock Server and dependencies:     npm install          Starting Mock Server      To start mock-server use the following command and than go to http://localhost:8080/shifu for mock-server admin-ui.     npm run start-mock      Common Use Cases      Starting mock server on HTTPS port -  To enable https, add httpsPort with the desired port number in server start script as shown below:      shifu.start({    port: 8080,    httpsPort: 4444,    host: 'localhost',    mockedDirectory: './test/resources/mocked-data',    project: 'HelloShifu'  });        Mocking different REST methods - To mock different rest methods, change the method value in the shifu.route() object to any one of the following desired values:          POST      GET      PUT      DELETE      OPTIONS      PATCH            Returning different data set for the same mocked route (Variants) - Variants allows to return a different set of data for the same mocked route. To add one or more variants, attach the variant object to shifu.route() as shown below:     shifu.route({   id: 'message',   label: 'Hello message',   path: '/message',   method: 'GET',   variantLabel: 'hello world',   handler: function (req, reply) {     reply({message:'Hello World'})   } }) .variant({    id: 'universe',    label: 'hello universe',    handler: function (req, reply) {      reply({message:'hello universe'})    }  })  .variant({    id: 'universe',    label: 'hello galaxy',    handler: function (req, reply) {      reply({message:'Hello Galaxy'})    }  });        To get a different set of response, go to admin-ui and select a different variant for the above route and hit http://localhost:8080/message on your favorite browser.        Storing mocked response in a file - This feature allows you to respond with a static data stored in a file instead of hard coding the response data in the routes definition.     // Automatic reply of the file shifu.route({   id: 'Get Collection',   label: 'Get Collections',   path: '/product/grouping/api/collection/test',   method: 'GET',   variantLabel: 'test-1',   handler: function(req, reply) {     shifu.util.respondWithFile(this, reply);   } }) .variant({    id: 'universe',    label: 'test-2',    handler: function (req, reply) {      shifu.util.respondWithFile(this, reply);    }  });        In the above setup, file needed for default route handler (test-1) should be located at (file location/name is based on mockedDirectory/route/method/[default|variant_name].{ext})     ./mocks/product/grouping/api/collection/GET/default.{ext}        If this would be a POST call than the file should have been at     ./mocks/product/grouping/api/collection/POST/default.{ext}        The file name for variants should change from default.{ext} to universe.{ext} in above example that is the file name should be the variant name.  Directing Traffic To Mock ServerTo mock live services, your application should allow to configure it to be directed to a mock service instead of live services as shown below:Please update your app server or application by changing the host name of your live service with the host name for your mock server.Mock Server Set-up Flow  Identify REST endpoints that needs to be mocked.  Gather mocked data for those REST endpoints.  Create Mocked Routes by adding them in endpoints.js file.  Start Mock Server.  Start Your Application server that points to the Mock Server host name instead of live-service.  Run your application and the mocked data will be returned for mocked routes.",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Getting Started"
      },
    
      "documentation-mocking-native-android-javascript-faq": {
        "title": "FAQ",
        "content": "What Can Be Mocked?Any Restful service API can be mocked such as:  GET  POST  PUT  DELETE  OPTIONS  and so on..Can AJAX Calls Be Mocked?Yes - It is same as for any other backend service. For AJAX call, point it to the mocked server instance instead of the actual back end service and add a mocked route in the file containing mocked routes for mock server.What Are The Pre-Requisites?  node.js 4+ (npm is included in the package)How Can I Add Mock Server Dependency To My Node Project?\"dependencies\": {  \"shifu\": \"1.0.0\" // add the latest version}How To Add A Mocked Route?Add the following code in your routes file, typically endpoints.jsshifu.route({  id: 'helloWorld',                 // required  label: 'Hello World',             // Used for Mock Server UI  path: '/helloWorld',              // the path you want to mock  method: 'GET',                    // The Rest Method you want to mock for this API  handler: function (req, reply) {  // Add Logic to massage data before returning back to the request.    reply('Hello World');  }});How To Create Dynamic URLs?By adding the URL part in curly brackets that you would liek to by dynamic such as /get/customerInfo/{customerid}/{zipcode}For example:shifu.route({  id: 'customerInfo',  label: 'Customer Info',  path: '/get/customerInfo/{customerid}/{zipcode}', // both customerid and zipcode will be dynamic  method: 'GET',  variantLabel: 'Get Customer Info',  handler: function (req, reply) {    reply('How to read the customer id :(');  }});How To Read Dynamic URLs In Request?var shifu = require('shifu');shifu.route({  path: '/get/customerInfo/{customerid}/{zipcode}'  handler: function(request, reply) {     var params = request.params;    var customerid = params.customerid; // customerid is 123 if request is \"/get/customerInfo/123/92127\"    var zipcode = params.zipcode;       // zipcode is 92127 if request is \"/get/customerInfo/123/92127\"  }}); How To Read Header Parameters In Request?var shifu = require('shifu');shifu.route({  path: '/api/getCart'  handler: function(request, reply) {    var headers = request.raw.req.headers;    var authorization = headers.authorization;  }}); How To Read Payload In Request?var shifu = require('shifu');shifu.route({  path: '/api/getCart'  handler: function(request, reply) {    var payload = request.payload;    // foo would be \"bar\" if the posted body content (as JSON) is {\"foo\": \"bar\"}    var foo = payload.foo;  }}); How To Read Query Parameters In Request?var shifu = require('shifu');shifu.route({  path: '/api/getCart'  handler: function(request, reply) {    var queryParams = request.query;    // foo would be \"bar\" if incoming request is \"/api/getCart?foo=bar\"    var foo = queryParams.foo;  }}); How To Set Custom Headers In Mocked Response?Preferred Wayshifu.route({  id: 'header',  label: 'Test Headers',  path: '/api/testHeaders',  handler: function (req, reply) {    var myHeaders = {      header1: 'test1',      header2: 'test2',      header3: true    };    shifu.util.respondWithFile(this, reply, {headers: myHeaders});  }});Alternate Wayshifu.route({  id: 'Get Collection',  label: 'Get Collections',  path: '/product/grouping/api/collection/{collectionId}',  handler: function(req, reply) {  reply({message: 'test'})    .header('X-Res-Header', 'I\\'m a custom response header')  }});How To Set Custom Cookies In Mocked Response?Preferred Wayshifu.route({  id: 'cookie',  label: 'Test Cookies',  path: '/api/testCookies',  handler: function (req, reply) {    var cookies = [      {name: 'com.wm.customer', value: 'vz7.0b5c56'},      {name: 'CID', value: 'SmockedCID', options: {domain: 'domain', path: '/'}},      {name: 'anotherCookie', value: 'cookieValue'}    ];        shifu.util.respondWithFile(this, reply, {cookies: cookies});  }});Alternate Wayshifu.route({  id: 'Get Collection',  label: 'Get Collections',  path: '/product/grouping/api/collection/{collectionId}',  handler: function(req, reply) {      reply({message: 'test'})       .state('test-cookie', 'I\\'m a custom response cookie')  }});  How To Set CORS Headers?var corsHeaders = {  origin: ['*'],  headers: [\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\"],  credentials: true,}// Itemsshifu.route({  id: 'tempo',  label: 'Tempo',  path: '/tempo1',      config: {    cors: corsHeaders  },  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }});What Is respondWithFile Utility?This feature allows you to respond with a data stored in a file instead of hard coding the response data in the routes definition. This way user does not have to hard-code/change the response in handler and rather can just swap the file with different data without even bringing the server down.  shifu.route({      id: 'ResponseFromFile',      label: 'Response From File',      path: '/get/fromFile',      handler: function(req, reply) {        shifu.util.respondWithFile(this, reply);      }  });In the above example, mock server will automatically look for a file default.{some_extension}  at ./mocked-data/get/fromFile/GET/default.{some_extension}How File Path Is Calculated For respondWithFile Utility?The path to the mocked data file is auto-calculated based on the route path. For example if the route path is /get/cart than for the default variant, mock server will look for the default.{some_extension} file at ./mocked-data/get/fromFile/GET/default.{some_extension}. For variants, the name of the file should be changed from default to the variant name as shown below:shifu.route({  id: 'ResponseFromFile',  label: 'Response From File',  path: '/get/fromFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }}).variant({  id: 'textData',  label: 'Text Data',  handler: function (req, reply) {    shifu.util.respondWithFile(this, reply);  }});In above example mock server will look for ./resources/mocked-data/get/fromFile/GET/textData.{some_extension} file for the variant textDataCan I Provide A Custom File Location respondWithFile Utility?Yes. By adding filePath parameter as shown in below example:shifu.route({  id: 'CustomResponseFile',  label: 'Response From Custom Path',  path: '/get/customFile',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {filePath: './custom.json'});  }});In above example mock server will look for the file under MockedDirectory only but at ./mocked-data/custom.jsonHow To Respond Only With Code?shifu.route({  id: 'message',  label: 'hello message',  path: '/message',  handler: function(req, reply) {    reply().code(400);  }});Can I Return A Response Code With respondWithFile Utility?Yes - by adding code parameter as shown in below example:shifu.route({  id: 'message',  label: 'hello message',  path: '/message',   handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {code: 400});  }});What Is MockedDirectory Path?Mocked directory path is the location to the base directory where all your mocked response file will be stored. This parameter is defined in run-mock-server-console.js file. It is defined at the start of mock server as shown in the code below:require('./endpoints');require('shifu').start({  host: \"localhost\",  mockedDirectory: \"./resources/mocked-data\",  port: 8000,  project: 'HelloShifu'});Location For Response File For RespondWithFile?If you have set your default folder to be mocked-data, then based on your URL path:For default variant, mock server will look for ./mocked-data/product/grouping/api/collection/GET/default.json and for mixItem variant mock server will look for ./mocked-data/product/grouping/api/collection/GET/mixItem.jsonWhat Are Variants?Variants allows to return a different data set for a given mocked route. Variants can be selected either in the admin UI or through automation APIs to determine what type of response a route should have. Routes are defined using the variant method on the Route object (returned by calling the route method). An object parameter is provided with the following attributes  id: the variant id - used for the RESTful admin API and profile settings  label: (optional) the variant label - used for display on the admin panel  handler: (optional) the HAPI route handler which provides the route responseVariants are useful because they allow you to test multiple scenarios that can happen with your route. Say, for example, you have a route exposing the ability to update a password. You might have several exceptional scenarios that you would want to test out (each could be a variant that you simply select to tell the route handler to use the appropriate response)  the password was reset successfully  the password didn’t pass validation  the old password wasn’t entered correctly  the username doesn’t exist  and so on…How To Add A Variant To A Route?To add a one or more variants do the following:shifu.route({  id: 'message',  label: 'Message',  path: '/get/message',  method: 'GET',  variantLabel: 'Hello',  handler: function (req, reply) {    reply('Hello');  }}) .variant({    id: 'hello',    label: 'Hello World',    handler: function (req, reply) {      reply('Hello World');    }  }).variant({    id: 'hello',    label: 'Hello Universe',    handler: function (req, reply) {      reply('Hello Universe');    }  });  How To Switch Variants In Test Case?browser.setMockVariant({ fixture: \"fixture id\", variant: \"variant id\" }); How To Switch Variants With HTTP Call?You can also switch the variants via HTTP call (Recommended only when not using Shifu as a library). As an example, if you want to set variant to helloUniverse for the route below:  shifu.route({    id: 'helloWorld',    label: 'Hello World',    path: '/helloWorld',    method: 'GET',    handler: function (req, reply) {      reply('Hello World');    }  })  .variant({    id: 'helloUniverse',    label: 'Hello Universe',    handler: function (req, reply) {      reply('Hello Universe');    }  });curl  -H \"Content-type: application/json\" -X POST -d '{\"variant\":\"&lt;variant&gt;\"}' &lt;host&gt;:&lt;port&gt;/shifu/api/route/&lt;routeId&gt;So for the above route, you can switch the variant to helloUniverse like this:curl  -H \"Content-type: application/json\" -X POST -d '{\"variant\":\"helloUniverse\"}' http://localhost:8000/shifu/api/route/helloWorldWhen using parallel sessions, if you want to switch a variant for a route for a particular session, register the session with mock server like this:curl &lt;host&gt;:&lt;port&gt;/shifu/api/registerSession// e.g curl http://localhost:8000/shifu/api/registerSessionIf sessions are available, mock server will return a response like: {\"session\":\"33b08d\"}Extract the session id from response and append it to the route id you want to switch variant for e.g:curl -H \"Content-type: application/json\" -X POST -d \"variant\":\"helloUniverse\"}' http://localhost:8000/shifu/api/route/helloWorld-33b08dWhat Is Mock Server UI Used For?UI can be used to view and test mocked routes as well as for manual switching of variants when running tests manually.What Is Parallel Sessions?Parallel sessions allows you to run multiple instance of server virtually while running only one server. This is helpful when you are running multiple test cases which access the same routes but different variants as parallel sessions allow you to set different variants on same routes without conflicting. This saves CPU and RAM both as only one server is running instead of multiple. Please see the call flow explaination without and with Parallel Sessions Below:Call Flow Without Parallel SessionsCall Flow With Parallel SessionsHow Can I Enable Parallel Sessions On Mock Server?Add sessions parameter with number of virtual services you want as shown in below example while startung mock Server.require('./endpoints');var shifu = require('shifu');shifu.start({  host: \"localhost\",  mockedDirectory: \"./resources/mocked-data\",  port: 8000,  sessions: 2,  project: 'HelloShifu'});How Can I Register a Session For Parallel Sessions?var sessionId = shifu.registerSession();How Can I Close A Session For Parallel Sessions?var closeSession = shifu.closeSession(sessionId);Does Mock Server Has Any Utility To Modify JSON Data Stored In Files?Yes - Mock Server exposes transpose option that cna be passed in respondWithFile method to modify the JSON files dynamically.How Does transposeData Work To Modify JSON Data Stored In Files?If you have many variants for a Rest end point and the mocked data for all variants can use the same JSON response with few changes to the values, than this feature is what you need. This feature allows you to dynamically change a JSON file before sending the response back from the mock server for the request. It removes the need of having one to one mapping of static JSON files with each variants.// Static Response JSON File{ id: \"1234\", name: \"toothpaste\" details: [   {    flavor: \"Mint 1\",    Size: \"10\",    Size_Type: ounce    },   {    flavor: \"Mint\",    Size: \"10\",    Size_Type: ounce   } ]}// Sample code for substituting id from 1234 to 7777 and flavor from Mint to Mint 2 for second array element in routesshifu.route({    id: 'Get Collection',    label: 'Get Collections',    path: '/product/grouping/api/collection/{collectionId}',     handler: function(req, reply) {      var dataToChange = {        'id': '7777',        'details[1].flavor': 'Mint 2'      }      shifu.util.respondWithFile(this, reply, {transpose: dataToChange});     }});// Dynamic Response JSON File returned from Mock service{ id: \"7777\", name: \"toothpaste\" details: [   {    flavor: \"Mint 1\",    Size: \"10\",    Size_Type: ounce    },   {    flavor: \"Mint 2\",    Size: \"10\",    Size_Type: ounce   } ]}Can I Use transposeData Functionality Outside Of respondWithFile?Yes - You can use it by Shifu Utils.var fileLocation = require(\"path\").join(__dirname, './resources/test-data/data-transposition-test.json');var dataSet = utils.readJsonFile(fileLocation);var dataToChange = { 'items.item[0].id': 1234, // substitue id 0001 to 1234 'items.item[0].val': \"value\", // Add 'val' to first array element of items.item 'items.item[1].id': 4567, // Add 'id' to second array element of items.item 'items.item[0].batters.batter[0].id': 5678 // substitue id 1001 to 5678}substitutedData = shifu.util.transposeData(dataSet, dataToChange);// Base JSON file - data-transposition-test.json{  \"items\":  {    \"item\":    [      {        \"id\": \"0001\",        \"type\": \"donut\",        \"name\": \"Cake\",        \"ppu\": 0.55,        \"batters\":        {          \"type\" : 1,          \"batter\":          [            { \"id\": \"1001\", \"type\": \"Regular\" },          ]        },        \"topping\":        [          { \"id\": \"5001\", \"type\": \"None\" }        ]      }    ]  }};// Resulted JSON{  \"items\": {    \"item\": [      {        \"id\": 1234,        \"type\": \"donut\",        \"name\": \"Cake\",        \"ppu\": 0.55,        \"val\": \"value\"        \"batters\": {          \"type\": 1,          \"batter\": [            {\"id\": 5678, \"type\": \"Regular\"}          ]        },        \"topping\": [          {\"id\": \"5001\", \"type\": \"None\"}        ]      },      {        \"id\": 4567      }    ]  }};Why Mock Server Returns Error 415 Unsupported Media Type?If you’re using content type like application/graphql, follow this example  shifu.route({    id: 'id',    label: 'id',    path: '/graphql',    method: ['POST', 'PUT'],    config : {      payload: {        parse: false,        allow: 'application/graphql'      }    },    handler: function (req, reply) {      shifu.util.respondWithFile(this, reply, {code: 200});    }  });For more details, read this",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/FAQ"
      },
    
      "documentation-mocking-native-android-javascript-contribution-guide": {
        "title": "Contribution Guide",
        "content": "ArchitectureThese are the very high level components of mocking eco-system.The below diagram shows the mocking components in detail.The mocking service uses shifu-smocks which provides the stateful HTTP mocking service built on top of HAPI. It allows to add routes and different scenarios for each route.In addition, the mocking service provides certain utilities via shifu-util. It also provides logging facility with shifu-loggerMock Server Start flowThe mocking service exposes its features via API’s and HTTP end points. Lets take a look at the sequence of events when the mock server is started.In the above diagram, the actor can be the test code which starts mock server or a developer using the mock service for local development / testing.      Users can specify what routes to mock by specifying them in endpoints.js        Shifu’s start() is invoked with options to start the Shifu server        Shifu creates an instance of Hapi server        Shifu adds the routes for the system API’s it supports        Shifu gets the plugin from shifu-smocks        Shifu registers the plugin it obtained from the above step        Shifu starts the server        Once the Shifu server is started, you can use the Shifu API’s via HTTP Calls or libraries [Read API Guide for examples]  Parallel vs non-parallel sessionsWithout Parallel sessionsIf we want to run two test cases in parallel, mocking the same route and returning different data, it won’t be possible with running one  mock server and sharing across the whole test suite. So we needed to run one mock server and one application server per test case.With Parallel sessionsWith parallel sessions, we can share one application server and mock server for the whole test suite. It allows to mock the same route but different data for different test cases.To use parallel sessions, the mock server is started with pre-defined number of sessions. For each test, the test case needs to register a session with the mock server. The mock server returns a unique session id which is then sent as part of the request to the application server. If the request gets routed to the mock server for a mocked route, the request handler in mock server extracts the session id from the request, and prepends it to the route. For e.g, if the session id is “123”, it is prepended to the route “/api/getCart” and the route becomes “/123/api/getCart”. For another test using session id “456” , the route will become “/456/api/getCart”. This enables the mock server to be able to return two different responses for the same mocked route.Tech stackLanguage : NodejsNode Version: 4+Unit Tests: MochaCode formatting: EslintCode Coverage Report: IstanbulDeployment informationMocking components are released as npm librariesGit repository informationThe source code for all mocking components reside in Github.  Shifu  Shifu Util  Shifu Magellan Nightwatch  Shifu Logger  Shifu Smocks  Shifu SwaggerDevelopment processTo contribute to the mocking fleet, please follow these steps:      Fork the repository https://github.com/TestArmada/shifu. If your Github username is “abc” for e.g, your forked repository will be https://github.com/abc/shifu.        Clone this forked repository using git clone https://github.com/&lt;username&gt;/shifu.git and make “shifu” your working directory.        Create a branch on local with git checkout -b &lt;your branch name&gt;. Note The default branch for all projects is development so any branch you create will be off the development branch.        Install dependencies using npm install.        Make the code changes in the branch you created in step (3) and write / update the unit tests to verify your changes. Run unit tests using npm test. We use eslint to ensure code formatting. This step runs both unit tests as well as verifies code formatting. We use istanbul for code coverage reporting. 95% is the minimum code coverage we expect for all our components.        Once you’re ready, submit your pull request from your branch against the development branch of Shifu (https://github.com/TestArmada/shifu/tree/development). The PR triggers a Travis build which runs the tests in CI environment (same steps as in (5) above).        Once the PR is reviewed, a team member merges the PR into the development branch.        When the development branch is merged to master, a team member will push a tag to master, a Travis build is triggered and publishes a new version of the package to npm registry.  Note: The same steps above are applicable for contributing to any of the mocking components.",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/Contribution Guide"
      },
    
      "documentation-mocking-native-android-javascript-api-guide": {
        "title": "API Guide",
        "content": "  Mocking API’s          Start Mock Server - start()      Stop Mock Server - stop()      Create Mocked Route - route()      Create Variant - variant()      Set variant - setMockVariant()      Add global variants - addGlobalVariant()      Respond With File - respondWithFile()      Respond with mock variant - respondWithMockVariant()      Set Mock Id - setMockId()      Get Mock Id - getMockId()      Reset Mock Id - resetMockId()      Reset url count - resetURLCount()      Get url count - getURLCount()      Register session - registerSession()      Close session - closeSession()      Check session - checkSession()      Get sessions - getSessions()      Clear sessions - clearSessions()      Get project name - getProjectName()      Get port information - getPortInfo()      Add state - addState()      Get state - getState()      Clear state - clearState()      Enable Metrics - enableMetrics()      Check if metrics are enabled - isMetricsEnabled()      Dynamic transposition of JSON data - transposeData()      Kill process - killProcess()      Read contents of a file - readFile()      Read contents of a file - readFileSynchronously()      Read contents of JSON file - readJsonFile()      Write to file - writeFile()      Delete file - deleteFile()      Check if directory exists - checkDirectoryExists()      Check if file exists - checkFileExists()      Set Log level - setLogLevel()      Get Log level - getLogLevel()      Reset Log level - resetLogLevel()      Mocking API’sStart Mock Server - start()This API allows to start the mock server.shifu.start(options, callback);The following attributes are supported:            Attribute      Description      Required                  options      JSON object with the attributes described in the table below      No              callback      The first argument to callback function is the server instance if the start is successful, else it is an error.      No      where options has the following attributes:            Attribute      Description      Required                  host      Hostname for mock server (default: localhost)      No              port      Port for mock server (default: 8080)      No              httpsPort      Https port for mock server      No              mockedDirectory      Path to the mocked data directory (default: resources/mocked-data w.r.t working directory).      No              sessions      Number of parallel sessions to start the mock server with (default: 0)      No              collectMetrics      Enable mock server to collect usage metrics (default: true)      No              project      Name for your project (default: default)      No      Examplevar shifu = require('shifu');shifu.start({  host: 'localhost',  port: 12000,  httpsPort: 12001,  mockedDirectory: '/resources/mockedData',  sessions: 3,  project: 'My Project'});Stop Mock Server - stop()This API allows to stop the mock server.shifu.stop(server, callback);The following attributes are supported:            Attribute      Description      Required                  server      server instance returned by start() method      Yes              callback      The first argument to callback function is an error if an error is encountered in stopping the server, null otherwise      No      Examplevar shifu = require('shifu');var server = shifu.start(options, callback);// do something with mock servershifu.stop(server, function (error) {  if (error) {      console.log('Unable to stop mock server');  } else {      console.log('Mock Server stopped');  }});Create Mocked Route - route()This API allows to create/add required mocked REST endpoints.shifu.route(options);The following attributes are supported:            Attribute      Description      Required                  options      JSON object with the attributes described in the table below      Yes      where options has the following attributes:            Attribute      Description      Required                  id      The unique route id for the mock server      Yes              label      The route label used for display on the Shifu Admin Panel      No              path      The route path      Yes              method      The HTTP route method (defaults to GET)      No              handler      The HAPI route handler which provides the route response. This is optional because you could use multiple variants to handle the response (See Variants)      No      Examplevar shifu = require('shifu');shifu.route({  id: 'my_route',  label: 'My Route',  path: '/api/foo',  method: 'GET',  handler: function(request, reply) {    // Add logic for handler    reply('Hello');  }});Create Variant - variant()This API allows to create/add variants. Variants are route handlers that you can select manually (via Shifu Admin panel) or Rest call or through Node API to select a different dataset for the response for a given route. Variants are defined using the variant() method on the Route object (returned by calling the route method).shifu.route(routeOptions).variant(options)The following attributes are supported:            Attribute      Description      Required                  options      JSON object with the attributes described in the table below      Yes      where options has the following attributes:            Attribute      Description      Required                  id      The unique variant id for a given route      Yes              label      The route label used for display on the Admin Panel      No              handler      The HAPI route handler which provides the variant response for the route      No      Examplevar shifu = require('shifu');shifu.route({  id: 'my_route',  path: '/api/foo',  handler: function(request, reply) {    // this is essentially the same as the \"default\" variant    reply({firstName: 'John'});  }}).variant({  id: 'Billy',  handler: function(request, reply) {    reply({firstName: 'Billy'});  }}).variant({  id: 'Clark',  handler: function(request, reply) {    reply({firstName: 'Billy'});  }});Set variant - setMockVariant()setMockVariant can be used to set a variant to an existing API path.shifu.setMockVariant(options, callback) // with Shifu libraryor browser.setMockVariant(options, callback) // when using MagellanThe following attributes are supported:            Attribute      Description      Required                  options      JSON object with the attributes described in the table below      No              callback      callback function to be called after setMockVariant()      Yes      where options has the following attributes:            Attribute      Description      Required                  fixture      Id defined in route      Yes              variant      The variant defined in endpoint.js for the fixture you entered      Yes              portNumber      Port number where the mock server is running on      No              shifuSessionId      Shifu session id, if using parallel sessions      No      ExampleIf the routes are defined likevar shifu = require('shifu');shifu.route({  id: 'hello',  path: '/helloWorld',  handler: function(request, reply) {    reply('Hello World');  }}).variant({  id: 'universe',  handler: function(request, reply) {    reply('Hello Universe');  }});For the route and variant defined as above, you can set the variant to universe as follows:// when using Shifu libraryshifu.setMockVariant({    fixture: 'hello', // same as id in the .route() options    variant: 'universe' // same as id in the .variant() options}, function (err) {    if (err) {        console.log('Error in setting variant:' + err);    } else {        console.log('Successfully set variant');    }});or // When using Magellanbrowser.setMockVariant({ fixture: \"hello\", variant: \"universe\" });or Alternately, you can also use `curl` call to set a variant with this POST call to `{host}:{port}/shifu/api/route/{routeId}`curl -H \"Content-Type: application/json\" -X POST -d '{\"variant\":\"{universe}\"}' http://localhost:8080/shifu/api/route/hello?returnConfig=trueYou can confirm if this works by going to Admin panel and see that for helloWorld route, the variant universe will be highlighted. Also, hitting this url http://localhost:8080/helloWorld will reply with Hello Universe.If the variant does not exist on the route, mock server returns with an Internal Server error (HTTP 500).Add global variants - addGlobalVariant()You can also add global variants that will affect all routes. The attributes to the options are same as that of variant().shifu.route(routeOptions).addGlobalVariant(options)whereoptions - JSON object with the same attributes as of variant described in this sectionExamplevar shifu = require('shifu');shifu.addGlobalVariant({  id: '500',  label: '500 error',  handler: function(request, reply) {    reply({      statusCode: 500,      error: 'Internal Server Error'    }).code(500);  }})Respond With File - respondWithFile()This API allows to respond with static data stored in a file instead of hard coding the response data in the routes definition. Based on the path of the URL that is being mocked, the response file can be dropped in the directory location and the file will be automatically used by Shifu for sending the response. It also allows to specify the absolute path of the response files.shifu.util.respondWithFile(route, reply, options);The following attributes are supported:            Attribute      Description      Required                  route      Handle to the shifu route object      Yes              reply      Handle to the reply object      Yes              options      JSON object with additional options desribed below      No                  Attribute      Description      Required                  code      HTTP Status code to reply with      No              filePath      Static file path of the mocked data      No              delay      Delay response time by this value (in milliseconds)      No      To use this feature, you can call respondWithFile() from inside route configuration as follows:Examplevar shifu = require('shifu');// Automatic reply of the fileshifu.route({  id: 'Get Collection',  label: 'Get Collections',  path: '/product/grouping/api/collection/{collectionId}'  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }}).variant({  id: 'mixItem',  label: 'Mix Item'  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply, {code: 204, filePath: '../mocked-data/fileName.json', delay: 1000});  }})Note the Use of shifu.util to access the method respondWithFileRespond with mock variant - respondWithMockVariant()This API allows to respond with a variant on the main route handler. The ‘variant’ passed in MUST be the variant on existing route.shifu.util.respondWithMockVariant(route, variant, req, reply)The following attributes are supported:            Attribute      Description      Required                  route      The route object      Yes              variant      Variant on the route      Yes              request      Request object      Yes              reply      Reply object      Yes      Examplevar shifu = require('shifu');shifu.route({    id: 'respondWithVariant',    label: 'Respond With Variant',    path: '/respondWithVariant',    variantLabel: 'Respond With Main Route',    handler: function(req, reply) {        shifu.util.respondWithMockVariant(this, 'variant', req, reply); // make sure that the variant exist in the same route.    }}).variant({    id: 'variant',    label: 'Respond With Variant Route',    handler: function(req, reply) {        reply({            'message': 'I am an example of respond_with_mock_variant instead of response of main route '        });    }});Note the Use of shifu.util to access the method respondWithMockVariantSet Mock Id - setMockId()This API allows to set mock id for a given test case. If this is set, it overrides all the variants and mocked URLs responses to return mocked data from the given directory as mock-id, where mock-id is the directory name.shifu.setMockId(mockId, shifuSessionId) // with Shifu libraryor browser.setMockId(mocKId, shifuSessionId, callback); // when using MagellanThe following attributes are supported:            Attribute      Description      Required                  mockId      Mock id which is the directory name you want to respond data from      Yes              shifuSessionId      Shifu session id, if using parallel sessions      No              callback      callback function to be invoked after mock id is set (only when using Magellan)      No      The file name should be in the format url-methodName-urlCount.extension for the responses stored under file. For example, for the given route belowvar shifu = require('shifu');shifu.route({  id: 'my_route',  label: 'My Route',  path: '/api/foo',  method: 'GET',  handler: function(req, reply) {    shifu.util.respondWithFile(this, reply);  }});the file name should be api-foo-GET-1.json for the first time the URL is hit. For second time the URL is hit, the file name returned would be api-foo-GET-2.json. If the specific file for the count is not present, Shifu will look for default file api-foo-GET.json, which is also helpful if you want to always return the same response irrespective of the number of times the URL is hit.Example:var shifu = require('shifu');shifu.setMockId('cart', 'abcdef'); // All responses should be under \"cart\" directory under your mocked data directoryor browser.setMockId('cart', 'abcdef' , callback);orcurl http://localhost:8000/shifu/api/setMockId/cart/abcdefTIP! For a dynamic url such as /app/{cartid}/getStatus the default file name should be app-cartid-getStatus-GET.json and the count specific file name should be like app-cartid-getStatus-GET-1.json.Get Mock Id - getMockId()This API is used to retrieve the currently set mock id.shifu.getMockId(shifuSessionId);The following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id, if using parallel sessions      No      Example:var shifu = require('shifu');var mockId = shifu.getMockId('abcdef');or curl http://localhost:8000/shifu/api/getMockId/cart/abcdefNote that abcdef is the session id in use for the current test (optional, if not using parallel sessions)Reset Mock Id - resetMockId()This API is used to reset currently set mock id.shifu.resetMockId(shifuSessionId) // with Shifu libraryor browser.resetMockId(shifuSessionId, callback); // when using MagellanThe following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id, if using parallel sessions      No              callback      callback function to be invoked after mock id is set (only when using Magellan)      No      Example:var shifu = require('shifu');shifu.resetMockId('abcdef');or browser.resetMockId('abcdef', callback);or curl http://localhost:8000/shifu/api/resetMockId/cart/abcdefNote that abcdef is the session id in use for the current test (optional, if not using parallel sessions)Reset url count - resetURLCount()This API is used to reset URL count to zero. This works in conjunction with setMockId function where you want to restart over for the URL count.shifu.resetURLCount(shifuSessionId)or browser.resetURLCount(shifuSessionId, callback)The following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id, if using parallel sessions      No              callback      callback function to be be invoked after the mock id is reset      No      Example:var shifu = require('shifu');shifu.resetURLCount('abcdef');or browser.resetCount('abcdef', callback); // 'abcdef' is a shifu session id in use for the testorcurl http://localhost:8000/shifu/api/resetURLCount/abcdefNote that abcdef is the session id in use for the current test (optional, if not using parallel sessions)Get url count - getURLCount()This API is used in conjunction with setMockId function where you want to get the URL count for all mocked calls.shifu.getURLCount(shifuSessionId)The following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id, if using parallel sessions      No      Example:var shifu = require('shifu');shifu.getURLCount('abcdef');or curl http://localhost:8000/shifu/api/getURLCount/abcdefNote that abcdef is the session id in use for the current test (optional, if not using parallel sessions)Register session - registerSession()This API is used to register a session with Shifu for a test case when using parallel sessions. Shifu needs to be started with sessions.shifu.registerSession(); // with Shifu libraryor browser.registerSession(callback); // with browser testsThe following attributes are supported:            Attribute      Description      Required                  callback      callback function to be be invoked after the session is registered. First argument to the callback is an error object, in case of error, null otherwise. The second argument is the registered session id (Only for browser tests)      Yes      You can use registerSession() to register a session with Shifu and can subsequently use that session id for the current test. Shifu returns a unique identifier when registering a session.If no session is available to use, Shifu returns with the message NOT_AVAILABLE.ExampleIf shifu server is started with sessions, for e.g 3 sessions as shown below,var shifu = require('shifu');shifu.start({    host: 'localhost',    port: 8080,    mockedDirectory: 'resources/mockedData',    sessions: 3});var shifuSessionId = shifu.registerSession();or browser.registerSession(function (err, sessId) {    if (err) {      return callback(new Error(\"Unable to get the sessionId\"));    }    self.shifuSessionId = sessId;    client.shifuSessionId = sessId;     return callback();});orcurl http://localhost:8000/shifu/api/registerSessionClose session - closeSession()This API is used to close a session after running a test so it can be made available for subsequent tests.shifu.closeSession(shifuSessionId);or browser.closeSession(shifuSessionId, callback);The following attributes are supported:            Attribute      Description      Required                  shifuSesssionId      Shifu session id to be closed      Yes              callback      callback function to be be invoked after the session is registered. First argument to the callback is an error object, in case of error, null otherwise (Only when using browser tests)      Yes      Examplevar shifu = require('shifu);shifu.closeSession('abcdef'); // abcdef is a previously registered session with Shifuor client.closeSession('abcdef', function (err) {  if (err) {    console.error(\"Error in closing session:\");  }});orcurl http://localhost:8000/shifu/api/closeSession/abcdefNote that abcdef is a previously registered session with Shifu.Check session - checkSession()This API is used to check status of a session id. It returns one of these states  AVAILABLE - If the session is available for use  IN_USE - If the session is in use  DOES_NOT_EXISTS - If the session id passed is invalid or does not existThe following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id      Yes      Examplevar shifu = require('shifu);var status = shifu.checkSession('abcdef');or curl http://localhost:8000/shifu/api/checkSession/abcdefGet sessions - getSessions()This API is used to get sessions informationshifu.getSessions();Examplevar shifu = require('shifu);var status = shifu.getSessions();or curl http://localhost:8000/shifu/api/getSessionsClear sessions - clearSessions()This API is used to clear the sessions information.shifu.clearSessions();Examplevar shifu = require('shifu);var status = shifu.clearSessions();Get project name - getProjectName()This API is used to get the project name passed in Shifu optionsshifu.getProjectName();Examplevar shifu = require('shifu);var projectName = shifu.getProjectName();Get port information - getPortInfo()This API is used to get the port information passed in Shifu optionsshifu.getPortInfo();Examplevar shifu = require('shifu);var portInfo = shifu.getPortInfo();Add state - addState()This API is used to add a value to the server state.shifu.addState(route, key, value);The following attributes are supported:            Attribute      Description      Required                  route      Route object      Yes              key      Key for the state variable      Yes              value      Value of the state variable      Yes      Examplevar shifu = require('shifu);shifu.route({  id: 'setState',  label: 'Add State',  path: '/login',  handler: function (req, reply) {    shifu.addState(this, 'loggedIn', true);    reply().code(204);  }});Get state - getState()This API is used to read a value from the server state.shifu.getState(route, key);The following attributes are supported:            Attribute      Description      Required                  route      Route object      Yes              key      Key for the state variable      Yes      Examplevar shifu = require('shifu);shifu.route({  id: 'getState',  label: 'Get State',  path: '/isLogin',  handler: function (req, reply) {    var isLoggedIn = shifu.getState(this, 'login');    reply(isLoggedIn);  }});Clear state - clearState()This API is used to clear a state for a given session id (Defaults to default session).shifu.clearState(shifuSessionId);The following attributes are supported:            Attribute      Description      Required                  shifuSessionId      Shifu session id      No      Examplevar shifu = require('shifu);shifu.clearState(); // Clears state for default sessionshifu.clearState('abcdef') // Clears state for session id `abcdef`Enable Metrics - enableMetrics()This API is used to enable gathering of usage metrics.shifu.enableMetrics(boolean);The following attributes are supported:            Attribute      Description      Required                  boolean      true to enable, false to disable      No      Examplevar shifu = require('shifu);shifu.enableMetrics(true); // Enables gathering of usage metricsshifu.enableMetrics(false); // Disables gathering of usage metricsCheck if metrics are enabled - isMetricsEnabled()This API is used to check if metrics gathering is enabled on Shifu. Returns true if metrics gathering is enabled, false otherwiseshifu.isMetricsEnabled();Examplevar shifu = require('shifu);shifu.isMetricsEnabled();Dynamic transposition of JSON data - transposeData()This API allows to dynamically transpose the JSON datashifu.util.transposeData(dataSet, dataToChange);The following attributes are supported:            Attribute      Description      Required                  dataSet      The data set which needs to change      Yes              dataToChange      The changes needed in the data set      Yes      To change the JSON data on fly (edit existing values or add values).// Base JSON file{  \"items\":  {    \"item\":    [      {        \"id\": \"0001\",        \"type\": \"donut\",        \"name\": \"Cake\",        \"ppu\": 0.55,        \"batters\":        {          \"type\" : 1,          \"batter\":          [            { \"id\": \"1001\", \"type\": \"Regular\" },          ]        },        \"topping\":        [          { \"id\": \"5001\", \"type\": \"None\" }        ]      }    ]  }}// Code examplevar dataToChange = { 'items.item[0].id': 1234, // substitue id 0001 to 1234 'items.item[0].val': \"value\", // Add 'val' to first array element of items.item 'items.item[1].id': 4567, // Add 'id' to second array element of items.item 'items.item[0].batters.batter[0].id': 5678 // substitue id 1001 to 5678}// when using utils classvar fileLocation = require(\"path\").join(__dirname, './resources/test-data/data-transposition-test.json');var dataSet = utils.readJsonFile(fileLocation);substitutedData = shifu.util.transposeData(dataSet, dataToChange);// When using with respondwithFile (This will read the file based on url path and transpose the data)shifu.util.respondWithFile(this, reply, {transpose: dataToChange});// Resulted JSON{  \"items\": {    \"item\": [      {        \"id\": 1234,        \"type\": \"donut\",        \"name\": \"Cake\",        \"ppu\": 0.55,        \"val\": \"value\"        \"batters\": {          \"type\": 1,          \"batter\": [            {\"id\": 5678, \"type\": \"Regular\"}          ]        },        \"topping\": [          {\"id\": \"5001\", \"type\": \"None\"}        ]      },      {        \"id\": 4567      }    ]  }}Note the Use of shifu.util to access the method transposeDataKill process - killProcess()This API allows to Kill a process with a pidshifu.util.killProcess(pid, signal, callback);The following attributes are supported:            Attribute      Description      Required                  pid      process id to kill      Yes              signal      Signal to send (defaults to SIGKILL if passed undefined)      Yes              callback      Callback function  after killprocess completes      No      Examplevar shifu = require('shifu);shifu.util.killProcess(18222, 'SIGKILL', function () {  console.log('Process killed);});Note the Use of shifu.util to access the method killProcessRead contents of a file - readFile()This API allows to read contents of a file asynchronouslyshifu.util.readFile(filePath, callback);The following attributes are supported:            Attribute      Description      Required                  file path      Absolute or relative location of file      Yes              callback      Callback function after file is read. If file is read successfully, the second argument is the file data. In case of error, the first argument is an error. Returns promise if callback is omitted      No      Examplevar shifu = require('shifu);shifu.util.readFile('data.json', function (err, fileData) {  if (err) {    console.log('Error in reading file ', err);  } else {    console.log(fileData);  }});Note the Use of shifu.util to access the method readFileRead contents of a file - readFileSynchronously()This API allows to read contents of a file synchronouslyshifu.util.readFileSynchronously(filePath);The following attributes are supported:            Attribute      Description      Required                  file path      Absolute or relative location of file      Yes      Examplevar shifu = require('shifu);shifu.util.readFileSynchronously('data.json');Note the Use of shifu.util to access the method readFileSynchronouslyRead contents of JSON file - readJsonFile()This API allows to read contents of a JSON file synchronouslyshifu.util.readJsonFile(filePath);The following attributes are supported:            Attribute      Description      Required                  file path      Absolute or relative location of JSON file      Yes      Examplevar shifu = require('shifu);shifu.util.readJsonFile('data.json');Note the Use of shifu.util to access the method readJsonFileWrite to file - writeFile()This API allows to write file contents to a fileshifu.util.writeFile(filePath, file data, callback);The following attributes are supported:            Attribute      Description      Required                  file path      Absolute or relative location of file      Yes              file data      contents to write      Yes              callback      Callback function after writeFile completes      Yes      Examplevar shifu = require('shifu);shifu.util.writeFile('hello.txt', 'hello world blah blah', function () {  console.log('Wrote to file successfully');});Note the Use of shifu.util to access the method writeFileDelete file - deleteFile()This API allows to write file contents to a fileshifu.util.deleteFile(filePath, callback);The following attributes are supported:            Attribute      Description      Required                  file location      Absolute or relative location of file to delete      Yes              callback      Callback function after deleteFile completes      Yes      Examplevar shifu = require('shifu);shifu.util.deleteFile('filetoDelete.txt', function (err) {  if (err) {    console.log('Error in deleting file');  }});Note the Use of shifu.util to access the method deleteFileCheck if directory exists - checkDirectoryExists()This API allows to check if a directory exists. Returns true if directory exists, false otherwise.shifu.util.checkDirectoryExists(directoryPath);The following attributes are supported:            Attribute      Description      Required                  directory path      Location of directory to check      Yes      Examplevar shifu = require('shifu);shifu.util.checkDirectoryExists('/home/data');Note the Use of shifu.util to access the method checkDirectoryExistsCheck if file exists - checkFileExists()This API allows to check if a file exists. Returns true if file exists, false otherwise.shifu.util.checkFileExists(filePath);The following attributes are supported:            Attribute      Description      Required                  file path      Location of file to check      Yes      Examplevar shifu = require('shifu);shifu.util.checkFileExists('/home/data');Note the Use of shifu.util to access the method checkFileExistsSet Log level - setLogLevel()This API allows to set log level on Shifushifu.log.setLogLevel(logLevel); // when using ShifuorLogger.setLogLevel(logLevel); // when using Shifu-LoggerThe following attributes are supported:            Attribute      Description      Required                  logLevel      Log level you want to set .Valid values (warn/info/debug/error)      Yes      Examplevar shifu = require('shifu);shifu.log.setLogLevel('debug');orcurl -X GET http://localhost:8080/shifu/api/setloglevel/debugGet Log level - getLogLevel()This API allows to get the current log level on Shifushifu.log.getLogLevel(); // when using Shifuor Logger.getLogLevel(); // when using Shifu-LoggerExamplevar shifu = require('shifu);shifu.log.getLogLevel();orvar Logger = require('shifu-logger');Logger.getLogLevel();orcurl -X GET http://localhost:8080/shifu/api/getloglevelReset Log level - resetLogLevel()This API allows to reset the log level of Shifu to info (Default log level)shifu.log.resetLogLevel();or Logger.resetLogLevel();Examplevar shifu = require('shifu);shifu.log.resetLogLevel();orvar Logger = require('shifu-logger');Logger.resetLogLevel();or curl -X GET http://localhost:8080/shifu/api/resetloglevel",
        "url": "/documentation/Mocking/Native Android/JAVASCRIPT/API Guide"
      },
    
      "functional-testing-rweb-javascript-training-guide": {
        "title": "Training Guide",
        "content": "30 minSetupCovered topicsPrerequisitesSetupRun demo tests locallyStart50 minrWeb TestingCovered topicsPrerequisitesBuilt-in browser testingRemote browser testingStart50 minMagellanCovered topicsMagellan introductionMagellan usageConfigure test profilesStart50 minTests FrameworkCovered topicsTests framework structurePage Object propertiesStart",
        "url": "/Functional Testing/rWeb/JAVASCRIPT/Training Guide"
      },
    
      "documentation-functional-testing-rweb-javascript-introduction": {
        "title": "Introduction",
        "content": "SummaryThe functional JS Test Development Kit (TDK) is a set of tools for making cross-browser end-to-end testing fast, user-friendly, and valuable at scale, across large teams, without those annoying false positives.The following tools are part of the functional JS TDK:      Magellan - Magellan is a massively parallel test runner. By distributing tests across available CPU cores, Magellan blazes through long test suites in a fraction of the time, aggregating results in one friendly report.        Nightwatch-Extra - Nightwatch is a friendly NodeJS-based wrapper for Selenium, allowing developers to author tests in a way that’s easy to learn and quick to iterate on. The Nightwatch-Extra adapter is the first of many adapters to come for bringing other webdriver wrappers into the TestArmada ecosystem.        Executor - Executor acts as a middle layer between magellan and test framework to drive test run (via framework) based on a specific need (differentiated by executing environments).        Reporter - Magellan can give you various test reports if configured with a proper reporter. There are already several reporters available in Testarmada to grab, however the simple API Testarmada exposes also allows to create a customized reporter in an easy way.        Admiral - Like a tree falling in the woods, a test report that nobody reads doesn’t make a sound. Admiral is a beautiful dashboard that makes it easy to check the latest cross-browser test results, and to spot trends and sources of failures.  Use CaseBuilt for Walmart ScaleBuilt at WalmartLabs to drive quality for the world’s largest retailer, TestArmada is battle-tested, enterprise-grade, and ready to take on end-to-end testing for your site.Results You Can TrustTestArmada won’t waste your team’s time or erode its trust with annoying false-positives. When failures occur, TestArmada intelligently retries the tests to smooth over common sources of “test flake”.More Signal, Less NoiseThe functional JS TDK tells you everything you need to know, and nothing you don’t. Notifications occur in real-time when tests fail, and a beautiful dashboard always shows the latest status for each suite.ImpactWith the functional JS TDK, WalmartLabs has made end-to-end testing part of the shared culture between dev &amp; QA. Both organizations collaborate to ensure quality at all levels development, staging, and production.Feature ListThe functional JS TDK supports:      Frameworks - Nightwatch &amp; Mocha        Reporters - xunit, json &amp; mongo db        Clouds - Saucelabs &amp; Testobject  ",
        "url": "/documentation/Functional Testing/rWeb/JAVASCRIPT/Introduction"
      },
    
      "documentation-functional-testing-rweb-javascript-getting-started": {
        "title": "Getting Started",
        "content": "Pre RequisiteThe functional JS TDK requires minimum node@4 and npm@2.Getting started with the functional JS TDKRun the following commands in your favorite terminal to see the functional JS TDK in action:git clone git@github.com:TestArmada/boilerplate-nightwatch.gitnpm installnpm run test:desktopYou should have seen the test runner magellan open up Chrome and run one test through it.Next, try the following command. It demonstrates TestArmada’s ability to drive multiple browsers in parallel, and aggregate the results:npm run testYou should have seen 2 Chrome windows open at once (probably stacked on top of each other) and the results of all two tests aggregated on the console.Via Command Line ArgumentsMagellan which is part of the functional JS TDK is designed for running tests in massive scale, which means you’ve been granted the full control of the scalability. There are two ways to tell magellan how you want to scale your tests.All command line arguments of magellan and its components (executors, reporters and plugins) that are enabled can be listed out by running following command in your favorite bash./node_modules/.bin/magellan --helpFollowing is an example telling magellan to run tests with 30 workers, 5 retry attempts per failed test and bail whole suite if any failure is met../node_modules/.bin/magellan --max_workers 30 --max_test_attempts 5 --bail_fastConfigure test profileMagellan passes down test profile information, like which browser or test environment your test runs in, to its executor(s). Usually this is done by setting up a specific argument in magellan command, such as./node_modules/.bin/magellan --local_browser chromeVia –profile command line argumentMagellan can retrieve test profile information from an URL. This gives you the convenience of managing your test environments and sharing your configuration management in a more standard way. Furthermore, by putting test profiles in to a file, you can add more information into your test profile, such as screen resolution, orientation or device information for you app test.The hosted test profile file needs to follow the format of{  \"profiles\": {    \"microsoftedge\": [{      \"browser\": \"microsoftedge_14_Windows_10_Desktop\",      \"resolution\": \"1280x1024\",      \"executor\": \"sauce\"    }],}Magellan can read and resolve the hosted profile by following command../node_modules/.bin/magellan --profile http://some.host#microsoftedgeYou can add as many test profiles as your need in the hosted file. Magellan is able to read more test profiles via./node_modules/.bin/magellan --profile http://some.host#microsoftedge,googlechrome59,firefox57Or, as a better way to handle multiple test profiles as a batch, you can put multiple test profiles into one collection, such as{  \"profiles\": {    \"tier-one-browsers\": [{        \"browser\": \"microsoftedge_14_Windows_10_Desktop\",        \"resolution\": \"1280x1024\",        \"executor\": \"sauce\"      },      {        \"browser\": \"chrome_latest_Windows_10_Desktop\",        \"resolution\": \"1280x1024\",        \"executor\": \"sauce\"      },      {        \"browser\": \"iphone_10_0_iOS_iPhone_7_Simulator\",        \"orientation\": \"portrait\",        \"appium\": {          \"app\": \"sauce-storage:my_app.zip\",          \"appiumVersion\": \"1.6.4\",          \"automationName\": \"xcuitest\",          \"sendKeyStrategy\": \"setValue\",          \"waitForAppScript\": \"true\"        }      }    ]  }}Then simply call magellan with./node_modules/.bin/magellan --profile http://some.host#tier-one-browsersVia magellan.json fileMagellan.json supports the same test profile format as the hosted test profile file. Put the above js code snippet in magellan.json and it is ready to use via./node_modules/.bin/magellan --profile tier-one-browsersEnable executorYou need to tell magellan which executor it should use for a test profile. By default, if no executor is specified in profile, magellan is going to run it with magellan-saucelabs-executor if it is configured in magellan.json or magellan will error out.At least one executor has to be enabled in magellan.json. Please follow these steps to enable executor:  Install necessary executor via npm install    npm install testarmada-magellan-saucelabs-executor --save        Add following code in your magellan.json      \"executors\": [ \"magellan-saucelabs-executor\",  ],      Run test with executor(s)Magellan allows to run tests with one or more executors at the same time. Typically this is done by passing a specific command line argument to magellan. For example, to enable magellan-local-executor for all the tests, this command line argument is required# to run in Chrome--local_browser chrome or# to run in both Chrome and Firefox--local_browsers chrome, firefox Here is another example to enable both magellan-local-executor and magellan-saucelabs-executor for your test:# to run in local Chrome and Safari 10 on Saucelabs--local_browser chrome --sauce_browser safari_10_OS_X_10_11_Desktop Using ReporterReporter extends magellan’s reporting mechanism and increases the report format that magellan supports. With reporters magellan can now create test report in various formats for different audiences.Enable reporter(s)To enable multiple reporters, simply add them in magellan.json  \"reporters\": [    \"testarmada-magellan-xunit-reporter\",    \"testarmada-magellan-dev-reporter\"  ]Please note: By default, magellan prints logs to terminal console while running. This default behavior won’t change and cannot be changed no matter how many other reporters are enabled.Create tests with Nightwatch-extraNightwatch-extra supports everything that nightwatchjs supports. Please refer to nightwatchjs’ developer guide for the basic usage of nightwatchjs.Extend the base-test-class.jsNightwatch-extra’s base-test-class.js passes certain information, such as selenium session information and test result, back to magellan. We highly recommend all your tests extend it.const Test = require(\"testarmada-nightwatch-extra/lib/base-test-class\");module.exports = new Test({  \"Load goole page\": function (client) {    client.url(\"http://www.google.com\");  }});Enable nightwatch-extra commandTo use nightwatch-extra’s command API, you need to add its path to nightwatch.json  \"custom_commands_path\": [    \"./node_modules/testarmada-nightwatch-extra/lib/commands\"  ],A typical flow of how nightwatch-extra’s command works is  Get all information, like selector, values, callback, from command() method’s arguments.  Check element’s apparence. If element isn’t present or isn’t visible within given time, fail the command.  Invoke customized code to get element information (via injectedJsCommand() for browser test command).  Expose element handler to user to do extra things to the element via do().All commands of nightwatch-extra won’t proceed if either of the following conditions isn’t met.  The element you want to operate is in the DOM.  The element you want to operate is visible in the view port.Enable nightwatch-extra assertionTo use nightwatch-extra’s assertion API, you need to add its path to nightwatch.json  \"custom_assertions_path\": [    \"./node_modules/testarmada-nightwatch-extra/lib/assertions\"  ],A typical flow of how nightwatch-extra’s assertion works is  Get all information, like selector, expectedValue, callback, from command() method’s arguments.  Check element’s apparence. If element isn’t present or isn’t visible within given time, fail the command.  Invoke customized code to get element information (via injectedJsCommand() for browser test command).  Expose element handler to user to do extra things to the element and assert via assert().All assertions of nightwatch-extra won’t proceed if either of the following conditions isn’t met.  The element you want to operate is in the DOM.  The element you want to operate is visible in the view port.Page ObjectNightwatch-extra is fully compatible with nightwatchjs’ page object pattern. You can access nightwatch-extra’s API or your customized API in page object command via  createNewCreditCard: function() {    const selectors = this.elements;    return this      .clickEl(selectors.addCreditCardButton.selector)      .setElValue(selectors.firstName.selector, \"testarmada\");  },All nightwatchjs’ APIs are accessible and chainable with nightwatch-extra’s API or your customized API via  selectPayByCash: function() {    this      .clickMobileEl(\"accessibility id\", selectors.morePaymentOptions.selector)      .swipeMobileElTo(\"xpath\", selectors.visaCheckout.selector, 0, -50)      .api.pause(3000)      .clickMobileEl(\"xpath\", selectors.payWithCash.selector);    return this;  }",
        "url": "/documentation/Functional Testing/rWeb/JAVASCRIPT/Getting Started"
      },
    
      "documentation-functional-testing-rweb-javascript-faq": {
        "title": "FAQ",
        "content": "I’m having npm install failure, what should I do?Please make sure that you’re using compatible node and npm. Check versions by node -v and npm -vWhich magellan command should I use to launch my test?Please read magellan help by ./node_modules/.bin/magellan –help first. If you cannot find what you want there, or if you’re still not sure, please reach out to us.How should I run my test in different browsers?If you want to test locally, Firefox and Chrome would be supported by default no matter which OS you’re using. To run test in Safari, you need to follow this article. To run in IE serie, you need a Windows. Or, just simply invoke your test on saucelabs.How should I run my test in mobile browser?Please use Saucelabs.How should I debug my test?Right now we don’t have fancy feature like block current execution –&gt; do some variable watch –&gt; resume your test. However, you can add a .pause() command before the command you want to debug, run your test and check selector from either developer tool or firebug from browser. Another option is adding tons of console.log() in your test.Why my test passes in one browser but fails in another one?There are couple of things can impact the test results. Page rendering speed, css selector compatibility, viewport size or even the way element’s being rendered. However in most cases the descrepancy is because we’re not really simulating user behaviors in the test. For instance, please make sure your code is not clicking on an element that is not in the viewport.Can I have this feature?If you are asking for a customized command, please check if similar command exists in our API Guide and nightwatch first. Or, if you are asking for a feature like data tools, or any other stuff that you think is useful, please reach out to us.",
        "url": "/documentation/Functional Testing/rWeb/JAVASCRIPT/FAQ"
      },
    
      "documentation-functional-testing-rweb-javascript-contribution-guide": {
        "title": "Contribution Guide",
        "content": "Code baseAll contributions will be done on Github, including PR, review process etc.      Magellan code base        Nightwatch-Extra code base  Bugs reportingPlease file the issue in the github projects above. Please ensure your issue has not been reported earlier.VersioningThe functional TDK follows semantic versioning, patch versions for bug fixes, minor versions for new features, major versions for non-backwards compatible updates.Customize commandWe provide a base-command.js for inheritance to implement your own command for browser test. To implement a command for browser usage, you need to  Inherit your command from the base-command.js.  Implement method do() and command()            Method      Purpose      Arguments                  do(magellanSelector)      Called by base test if element exists and is visible, you can do you own things in this method.      magellanSelector is the selector you should use which is generated by nightwatch-extra              command(…, callback)      The command signature which user will use in their test      Parameter amount can be arbitary with an optional callback which will be called when the command successfully finishes.        Add the path of your new command to nightwatch.json  \"custom_commands_path\": [    \"./node_modules/testarmada-nightwatch-extra/lib/commands\",    \"./node_modules/testarmada-nightwatch-extra/lib/commands/mobile\",    \"./lib/custom_commands\"  ],Customize assertionWe provide a base-assertion.js for inheritance to implement your own assertion for browser test. To implement an assertion for browser test, you need to  Inherit your assertion from the base-assertion.js.  Implement method do(), assert() and command().            Method      Purpose      Arguments                  do(magellanSelector)      Called by base test if element exists and is visible, you can do you own things in this method.      magellanSelector is the selector you should use which is generated by nightwatch-extra              assert(actual, expected)      Called by base assertion if element exists and is visible, you can do you own assertion in this method.      actual is the actual value returned by injectedJsCommand() method, expected is the expected value passed in command() method              command(selector, expected, …, callback)      The command signature which user will use in their test      Parameter amount can be arbitary with a selector, an expected value and an optional callback which will be called when the assertion successfully finishes.        Add the path to your new assertion to nightwatch.json  \"custom_assertions_path\": [    \"./node_modules/testarmada-nightwatch-extra/lib/assertions\",    \"./node_modules/testarmada-nightwatch-extra/lib/assertions/mobile\",    \"./lib/custom_assertions\"  ],Contribute to reporterCreate a reporterA reporter must implement following methods.            Method      Purpose                  initialize()      initialize current reporter instance              listenTo(testRun, test, source)      listen to magellan’s test run              _handleMessage(testRun, test, msg)      will be called when magellan emits certain events              flush()      will be called when magellan finishes      Please note: _handleMessage() will be called per test. Please handle the error properly if it happens in one of the _handleMessage() so all your following _handleMessage() and flush() don’t error out.Enable your reporterTo enable multiple reporters, simply add them in magellan.json\"reporters\": [    \"testarmada-magellan-xunit-reporter\",    \"testarmada-magellan-dev-reporter\"  ],",
        "url": "/documentation/Functional Testing/rWeb/JAVASCRIPT/Contribution Guide"
      },
    
      "documentation-functional-testing-rweb-javascript-boilerplates": {
        "title": "Boilerplates",
        "content": "Nightwatch archetypeThe easiest way to try out the functional JS TDK is to use the below archetype project. It will help you setup the necessary file structure in your project and generate a mocked test for you to execute. Please go here for more information.",
        "url": "/documentation/Functional Testing/rWeb/JAVASCRIPT/Boilerplates"
      },
    
      "documentation-functional-testing-rweb-javascript-api-guide": {
        "title": "API Guide",
        "content": "Nightwatch-Extra API:sCommands.getEl()description:Returns a html elementSyntax:.getEl(selector, callback/*optional*/);Parameters:selector : css selector to identify the html element.callback : callback which includes the element information.Usage:.getEl(\".dropdown-link .user-name\", function(element){  console.log(element); // will print out {'ELEMENT': 1}});.getEls()description:Returns html elementsSyntax:.getEls(selector, callback/*optional*/);Parameters:selector : css selector to identify the html elements.callback : callback which includes the elements information.Usage:.getEls(\".dropdown-link .user-name\", function(element){  console.log(element);  // will print out [{'ELEMENT': 1}, .....]});.clickEl()description:Click a html elementSyntax:.clickEl(selector, callback/*optional*/);Parameters:selector : css selector to the html element.callback : optional callback to be called when the command finishes.Usage:.clickEl(\"#submit\");.clickAutomationEl()description:Click an html element which has html attribute [data-automation-id].Syntax:.clickAutomationEl(id, callback/*optional*/);Parameters:id : value of data-automation-id attribute.callback : optional callback to be called when the command finishes.Usage:.clickAutomationEl(\"placeOrder\"); // equals to .clickEl('[data-automation-id=\"placeOrder\"]');.getElValue()description:Returns the textual value of a html element.Syntax:.getElValue(selector, callback/*optional*/);Parameters:selector : css selector to the html element.callback : callback which includes the value of the element.Usage:.getElValue(\".user-profile\", function(profile){ });.setElValue()description:Sets value to a html element.Syntax:.setElValue(selector, value, callback/*optional*/);Parameters:selector : css selector to the html element.value : value to be set to the html element.callback : optional callback to be called when the command finishes.Usage:.setElValue(\"#username\", \"fake@login.com\");.setMaskedElValue()description:Sets value to a masked html element like credit card number or phone number.Syntax:.setMaskedElValue(selector, value, callback/*optional*/);Parameters:selector : css selector to the html element.value : value to be set to the html element.callback : optional callback to be called when the command finishes.Usage:.setMaskedElValue(\".phone-number\", \"123456789\");.moveToEl()description:Moves cursor to a html elementSyntax:.moveToEl(selector, xoffset, yoffset, callback/*optional*/);Parameters:selector : css selector to the html element.xoffset : x offset to move to, relative to the top-left corner of the element.yoffset : y offset to move to, relative to the top-left corner of the element.callback : optional callback to be called when the command finishes.Usage:.moveToEl(\".checkout\", 10, 10);.takeElScreenshot()description:Takes screenshot for a html element and save it to fileSyntax:.takeElScreenshot(selector, filename, callback/*optional*/);Parameters:selector : css selector to the html element.filename : file name where the screen shot will be saved to (.png will be appended as prefix).callback : optional callback to be called when the command finishes.Usage:.takeElScreenshot(\".phone-number\", \"phone-number\");.takeScreenhot()description:Takes screenshot for the page.Syntax:.takeScreenhot(filename, callback/*optional*/);Parameters:filename : file name where the screen shot will be saved to (.png will be appended as prefix).callback : optional callback to be called when the command finishes.Usage:.takeScreenhot(\"home-page\");.assert.elContainsText()description:Asserts if current element contains a given textSyntax:.assert.elContainsText(selector, value);Parameters:selector : css selector to the html element.value : textual value or regular expression to assert.Usage:.assert.elContainsText(\".username\", \"testarmada\");.assert.elNotContainsText()description:Asserts if current element doesn’t contain a given textSyntax:.assert.elNotContainsText(selector, value);Parameters:selector : css selector to the html element.value : textual value or regular expression to assert.Usage:.assert.elNotContainsText(\".username\", \"testarmada\");.assert.selectorHasLength()description:Asserts if current selector returns given amount of elementsSyntax:.assert.selectorHasLength(selector, value);Parameters:selector : css selector to the html element.value : numeric value to assert.Usage:.assert.selectorHasLength(\".username\", 1);.assert.elValueContains()description:Asserts if current element contains the given valueSyntax:.assert.elValueContains(selector, value);Parameters:selector : css selector to the html element.value : textual value to assert.Usage:.assert.elValueContains(\".username\", \"Leo\");.assert.elLengthGreaterThan()description:Asserts if the length of an element’s attribute is greater than a numberSyntax:.assert.elLengthGreaterThan(selector, using, value);Parameters:selector : css selector to the html element.using : element attribute, can be chosen from [“value”, “text”, “html”, “length”].value : numeric value to assert.Usage:.assert.elLengthGreaterThan(\".username\", \"text\", 1);Nightwatch API:sFor Nightwatch API:s please go here",
        "url": "/documentation/Functional Testing/rWeb/JAVASCRIPT/API Guide"
      },
    
      "functional-testing-native-ios-javascript-training-guide": {
        "title": "Training Guide",
        "content": "30 minSetupCovered topicsSetup iOS app test on local machineSetup iOS app test on Sauce LabsStart50 minTests FrameworkCovered topicsExecution commandsUnderstand tests framework structureStart50 miniOS AutomationCovered topicsDesired CapabilitiesNative app locatorsStart20 minTrouble ShootingCovered topicsTrouble shooting tipsStart",
        "url": "/Functional Testing/Native iOS/JAVASCRIPT/Training Guide"
      },
    
      "documentation-functional-testing-native-ios-javascript-introduction": {
        "title": "Introduction",
        "content": "SummaryThe functional JS Test Development Kit (TDK) is a set of tools for making iOS apps written in Objective-C, Swift &amp; React Native apps end-to-end testing fast, user-friendly, and valuable at scale, across large teams, without those annoying false positives. Both simulators and real devices are supported.The following tools are part of the functional JS TDK:      Magellan - Magellan is a massively parallel test runner. By distributing tests across available CPU cores, Magellan blazes through long test suites in a fraction of the time, aggregating results in one friendly report.        Nightwatch-Extra - Nightwatch is a friendly NodeJS-based wrapper for Selenium, allowing developers to author tests in a way that’s easy to learn and quick to iterate on. The Nightwatch-Extra adapter is the first of many adapters to come for bringing other webdriver wrappers into the TestArmada ecosystem.        Executor - Executor acts as a middle layer between magellan and test framework to drive test run (via framework) based on a specific need (differentiated by executing environments).        Reporter - Magellan can give you various test reports if configured with a proper reporter. There are already several reporters available in Testarmada to grab, however the simple API Testarmada exposes also allows to create a customized reporter in an easy way.        Admiral - Like a tree falling in the woods, a test report that nobody reads doesn’t make a sound. Admiral is a beautiful dashboard that makes it easy to check the latest cross-browser test results, and to spot trends and sources of failures.  Use CaseBuilt for Walmart ScaleBuilt at WalmartLabs to drive quality for the world’s largest retailer, TestArmada is battle-tested, enterprise-grade, and ready to take on end-to-end testing for your site.Results You Can TrustTestArmada won’t waste your team’s time or erode its trust with annoying false-positives. When failures occur, TestArmada intelligently retries the tests to smooth over common sources of “test flake”.More Signal, Less NoiseThe functional JS TDK tells you everything you need to know, and nothing you don’t. Notifications occur in real-time when tests fail, and a beautiful dashboard always shows the latest status for each suite.ImpactWith the functional JS TDK, WalmartLabs has made end-to-end testing part of the shared culture between dev &amp; QA. Both organizations collaborate to ensure quality at all levels development, staging, and production.Feature ListThe functional JS TDK supports:      Frameworks - Nightwatch &amp; Mocha        Reporters - xunit, json &amp; mongo db        Clouds - Saucelabs &amp; Testobject  CustomersThe following teams are using the functional iOS JS TDK:      Checkout RN        Store        Account Mobile        Omnichannel Mobile  ",
        "url": "/documentation/Functional Testing/Native iOS/JAVASCRIPT/Introduction"
      },
    
      "documentation-functional-testing-native-ios-javascript-getting-started": {
        "title": "Getting Started",
        "content": "Pre RequisiteThe functional JS TDK requires minimum node@4 and npm@3 for device testing.Getting started with the functional JS TDKTo proceed with native iOS app test, you also need latest Xcode and it’s command line tools. When you have Xcode setup, please make sure your desired iOS simulator is installed as well.SetupPlease follow the archetype project otto-archetype-app to have your first native app test automation project run in your local.Then please follow the boilerplate project boilerplate-nightwatch-mobile for more examples and advanced usage.Via Command Line ArgumentsMagellan which is part of the functional JS TDK is designed for running tests in massive scale, which means you’ve been granted the full control of the scalability. There are two ways to tell magellan how you want to scale your tests.All command line arguments of magellan and its components (executors, reporters and plugins) that are enabled can be listed out by running following command in your favorite bash./node_modules/.bin/magellan --helpFollowing is an example telling magellan to run tests with 30 workers, 5 retry attempts per failed test and bail whole suite if any failure is met../node_modules/.bin/magellan --max_workers 30 --max_test_attempts 5 --bail_fastConfigure test profileMagellan passes down test profile information, like which browser or test environment your test runs in, to its executor(s). Usually this is done by setting up a specific argument in magellan command, such as./node_modules/.bin/magellan --local_browser chromeVia –profile command line argumentMagellan can retrieve test profile information from an URL. This gives you the convenience of managing your test environments and sharing your configuration management in a more standard way. Furthermore, by putting test profiles in to a file, you can add more information into your test profile, such as screen resolution, orientation or device information for you app test.The hosted test profile file needs to follow the format of{  \"profiles\": {    \"microsoftedge\": [{      \"browser\": \"microsoftedge_14_Windows_10_Desktop\",      \"resolution\": \"1280x1024\",      \"executor\": \"sauce\"    }],}Magellan can read and resolve the hosted profile by following command../node_modules/.bin/magellan --profile http://some.host#microsoftedgeYou can add as many test profiles as your need in the hosted file. Magellan is able to read more test profiles via./node_modules/.bin/magellan --profile http://some.host#microsoftedge,googlechrome59,firefox57Or, as a better way to handle multiple test profiles as a batch, you can put multiple test profiles into one collection, such as{  \"profiles\": {    \"tier-one-browsers\": [{        \"browser\": \"microsoftedge_14_Windows_10_Desktop\",        \"resolution\": \"1280x1024\",        \"executor\": \"sauce\"      },      {        \"browser\": \"chrome_latest_Windows_10_Desktop\",        \"resolution\": \"1280x1024\",        \"executor\": \"sauce\"      },      {        \"browser\": \"iphone_10_0_iOS_iPhone_7_Simulator\",        \"orientation\": \"portrait\",        \"appium\": {          \"app\": \"sauce-storage:my_app.zip\",          \"appiumVersion\": \"1.6.4\",          \"automationName\": \"xcuitest\",          \"sendKeyStrategy\": \"setValue\",          \"waitForAppScript\": \"true\"        }      }    ]  }}Then simply call magellan with./node_modules/.bin/magellan --profile http://some.host#tier-one-browsersVia magellan.json fileMagellan.json supports the same test profile format as the hosted test profile file. Put the above js code snippet in magellan.json and it is ready to use via./node_modules/.bin/magellan --profile tier-one-browsersEnable executorYou need to tell magellan which executor it should use for a test profile. By default, if no executor is specified in profile, magellan is going to run it with magellan-saucelabs-executor if it is configured in magellan.json or magellan will error out.At least one executor has to be enabled in magellan.json. Please follow these steps to enable executor:  Install necessary executor via npm install    npm install testarmada-magellan-saucelabs-executor --save        Add following code in your magellan.json      \"executors\": [ \"magellan-saucelabs-executor\",  ],      Run test with executor(s)Magellan allows to run tests with one or more executors at the same time. Typically this is done by passing a specific command line argument to magellan. For example, to enable magellan-local-executor for all the tests, this command line argument is required# to run in Chrome--local_browser chrome or# to run in both Chrome and Firefox--local_browsers chrome, firefox Here is another example to enable both magellan-local-executor and magellan-saucelabs-executor for your test:# to run in local Chrome and Safari 10 on Saucelabs--local_browser chrome --sauce_browser safari_10_OS_X_10_11_Desktop Using ReporterReporter extends magellan’s reporting mechanism and increases the report format that magellan supports. With reporters magellan can now create test report in various formats for different audiences.Enable reporter(s)To enable multiple reporters, simply add them in magellan.json  \"reporters\": [    \"testarmada-magellan-xunit-reporter\",    \"testarmada-magellan-dev-reporter\"  ]Please note: By default, magellan prints logs to terminal console while running. This default behavior won’t change and cannot be changed no matter how many other reporters are enabled.Create test with Nightwatch-extraNightwatch-extra supports everything that nightwatchjs supports. Please refer to nightwatchjs’ developer guide for the basic usage of nightwatchjs.Extend the base-test-class.jsNightwatch-extra’s base-test-class.js passes certain information, such as selenium session information and test result, back to magellan. We highly recommend all your tests extend it.const Test = require(\"testarmada-nightwatch-extra/lib/base-test-class\");module.exports = new Test({  \"Load goole page\": function (client) {    client.url(\"http://www.google.com\");  }});Enable nightwatch-extra commandTo use nightwatch-extra’s command API, you need to add its path to nightwatch.json  \"custom_commands_path\": [    \"./node_modules/testarmada-nightwatch-extra/lib/commands\"  ],A typical flow of how nightwatch-extra’s command works is  Get all information, like selector, values, callback, from command() method’s arguments.  Check element’s apparence. If element isn’t present or isn’t visible within given time, fail the command.  Invoke customized code to get element information (via injectedJsCommand() for browser test command).  Expose element handler to user to do extra things to the element via do().All commands of nightwatch-extra won’t proceed if either of the following conditions isn’t met.  The element you want to operate is in the DOM.  The element you want to operate is visible in the view port.Enable nightwatch-extra assertionTo use nightwatch-extra’s assertion API, you need to add its path to nightwatch.json  \"custom_assertions_path\": [    \"./node_modules/testarmada-nightwatch-extra/lib/assertions\"  ],A typical flow of how nightwatch-extra’s assertion works is  Get all information, like selector, expectedValue, callback, from command() method’s arguments.  Check element’s apparence. If element isn’t present or isn’t visible within given time, fail the command.  Invoke customized code to get element information (via injectedJsCommand() for browser test command).  Expose element handler to user to do extra things to the element and assert via assert().All assertions of nightwatch-extra won’t proceed if either of the following conditions isn’t met.  The element you want to operate is in the DOM.  The element you want to operate is visible in the view port.Page ObjectNightwatch-extra is fully compatible with nightwatchjs’ page object pattern. You can access nightwatch-extra’s API or your customized API in page object command via  createNewCreditCard: function() {    const selectors = this.elements;    return this      .clickEl(selectors.addCreditCardButton.selector)      .setElValue(selectors.firstName.selector, \"testarmada\");  },All nightwatchjs’ APIs are accessible and chainable with nightwatch-extra’s API or your customized API via  selectPayByCash: function() {    this      .clickMobileEl(\"accessibility id\", selectors.morePaymentOptions.selector)      .swipeMobileElTo(\"xpath\", selectors.visaCheckout.selector, 0, -50)      .api.pause(3000)      .clickMobileEl(\"xpath\", selectors.payWithCash.selector);    return this;  }",
        "url": "/documentation/Functional Testing/Native iOS/JAVASCRIPT/Getting Started"
      },
    
      "documentation-functional-testing-native-ios-javascript-faq": {
        "title": "FAQ",
        "content": "I’m having npm install failure, what should I do?Please make sure that you’re using compatible node and npm. Check versions by node -v and npm -vWhich magellan command should I use to launch my test?Please read magellan help by ./node_modules/.bin/magellan –help first. If you cannot find what you want there, or if you’re still not sure, please reach out to us.How should I run my test in different devices?If you want to test locally, please make sure corresponding dev tools are installed correctly. Also for android please make sure a proper AVD is set.How should I debug my test?Please use appium desktop app to get your element or coordinates.Can I have this feature?If you are asking for a customized command, please check if similar command exists in our API Guide and nightwatch first. Or, if you are asking for a feature like data tools, or any other stuff that you think is useful, please reach out to us.",
        "url": "/documentation/Functional Testing/Native iOS/JAVASCRIPT/FAQ"
      },
    
      "documentation-functional-testing-native-ios-javascript-contribution-guide": {
        "title": "Contribution Guide",
        "content": "Code baseAll contributions will be done on Github, including PR, review process etc.      Magellan code base        Nightwatch-Extra code base  Bugs reportingPlease file the issue in the github projects above. Please ensure your issue has not been reported earlier.VersioningThe functional TDK follows semantic versioning, patch versions for bug fixes, minor versions for new features, major versions for non-backwards compatible updates.Customize commandWe provide a base-command.js for inheritance to implement your own command for browser test. To implement a command for browser usage, you need to  Inherit your command from the base-command.js.  Implement method do() and command()            Method      Purpose      Arguments                  do(magellanSelector)      Called by base test if element exists and is visible, you can do you own things in this method.      magellanSelector is the selector you should use which is generated by nightwatch-extra              command(…, callback)      The command signature which user will use in their test      Parameter amount can be arbitary with an optional callback which will be called when the command successfully finishes.        Add the path of your new command to nightwatch.json  \"custom_commands_path\": [    \"./node_modules/testarmada-nightwatch-extra/lib/commands\",    \"./node_modules/testarmada-nightwatch-extra/lib/commands/mobile\",    \"./lib/custom_commands\"  ],Customize assertionWe provide a base-assertion.js for inheritance to implement your own assertion for browser test. To implement an assertion for browser test, you need to  Inherit your assertion from the base-assertion.js.  Implement method do(), assert() and command().            Method      Purpose      Arguments                  do(magellanSelector)      Called by base test if element exists and is visible, you can do you own things in this method.      magellanSelector is the selector you should use which is generated by nightwatch-extra              assert(actual, expected)      Called by base assertion if element exists and is visible, you can do you own assertion in this method.      actual is the actual value returned by injectedJsCommand() method, expected is the expected value passed in command() method              command(selector, expected, …, callback)      The command signature which user will use in their test      Parameter amount can be arbitary with a selector, an expected value and an optional callback which will be called when the assertion successfully finishes.        Add the path to your new assertion to nightwatch.json  \"custom_assertions_path\": [    \"./node_modules/testarmada-nightwatch-extra/lib/assertions\",    \"./node_modules/testarmada-nightwatch-extra/lib/assertions/mobile\",    \"./lib/custom_assertions\"  ],Contribute to reporterCreate a reporterA reporter must implement following methods.            Method      Purpose                  initialize()      initialize current reporter instance              listenTo(testRun, test, source)      listen to magellan’s test run              _handleMessage(testRun, test, msg)      will be called when magellan emits certain events              flush()      will be called when magellan finishes      Please note: _handleMessage() will be called per test. Please handle the error properly if it happens in one of the _handleMessage() so all your following _handleMessage() and flush() don’t error out.Enable your reporterTo enable multiple reporters, simply add them in magellan.json\"reporters\": [    \"testarmada-magellan-xunit-reporter\",    \"testarmada-magellan-dev-reporter\"  ],",
        "url": "/documentation/Functional Testing/Native iOS/JAVASCRIPT/Contribution Guide"
      },
    
      "documentation-functional-testing-native-ios-javascript-boilerplates": {
        "title": "Boilerplates",
        "content": "Nightwatch Mobile boilerplateTo learn more about the functional JS TDK and to see an example project of how it can be used please go here",
        "url": "/documentation/Functional Testing/Native iOS/JAVASCRIPT/Boilerplates"
      },
    
      "documentation-functional-testing-native-ios-javascript-api-guide": {
        "title": "API Guide",
        "content": "Nightwatch-Extra API:sCommands.getEl()description:Returns a html elementSyntax:.getEl(selector, callback/*optional*/);Parameters:selector : css selector to identify the html element.callback : callback which includes the element information.Usage:.getEl(\".dropdown-link .user-name\", function(element){  console.log(element); // will print out {'ELEMENT': 1}});.getEls()description:Returns html elementsSyntax:.getEls(selector, callback/*optional*/);Parameters:selector : css selector to identify the html elements.callback : callback which includes the elements information.Usage:.getEls(\".dropdown-link .user-name\", function(element){  console.log(element);  // will print out [{'ELEMENT': 1}, .....]});.clickEl()description:Click a html elementSyntax:.clickEl(selector, callback/*optional*/);Parameters:selector : css selector to the html element.callback : optional callback to be called when the command finishes.Usage:.clickEl(\"#submit\");.clickAutomationEl()description:Click an html element which has html attribute [data-automation-id].Syntax:.clickAutomationEl(id, callback/*optional*/);Parameters:id : value of data-automation-id attribute.callback : optional callback to be called when the command finishes.Usage:.clickAutomationEl(\"placeOrder\"); // equals to .clickEl('[data-automation-id=\"placeOrder\"]');.getElValue()description:Returns the textual value of a html element.Syntax:.getElValue(selector, callback/*optional*/);Parameters:selector : css selector to the html element.callback : callback which includes the value of the element.Usage:.getElValue(\".user-profile\", function(profile){ });.setElValue()description:Sets value to a html element.Syntax:.setElValue(selector, value, callback/*optional*/);Parameters:selector : css selector to the html element.value : value to be set to the html element.callback : optional callback to be called when the command finishes.Usage:.setElValue(\"#username\", \"fake@login.com\");.setMaskedElValue()description:Sets value to a masked html element like credit card number or phone number.Syntax:.setMaskedElValue(selector, value, callback/*optional*/);Parameters:selector : css selector to the html element.value : value to be set to the html element.callback : optional callback to be called when the command finishes.Usage:.setMaskedElValue(\".phone-number\", \"123456789\");.moveToEl()description:Moves cursor to a html elementSyntax:.moveToEl(selector, xoffset, yoffset, callback/*optional*/);Parameters:selector : css selector to the html element.xoffset : x offset to move to, relative to the top-left corner of the element.yoffset : y offset to move to, relative to the top-left corner of the element.callback : optional callback to be called when the command finishes.Usage:.moveToEl(\".checkout\", 10, 10);.takeElScreenshot()description:Takes screenshot for a html element and save it to fileSyntax:.takeElScreenshot(selector, filename, callback/*optional*/);Parameters:selector : css selector to the html element.filename : file name where the screen shot will be saved to (.png will be appended as prefix).callback : optional callback to be called when the command finishes.Usage:.takeElScreenshot(\".phone-number\", \"phone-number\");.takeScreenhot()description:Takes screenshot for the page.Syntax:.takeScreenhot(filename, callback/*optional*/);Parameters:filename : file name where the screen shot will be saved to (.png will be appended as prefix).callback : optional callback to be called when the command finishes.Usage:.takeScreenhot(\"home-page\");.assert.elContainsText()description:Asserts if current element contains a given textSyntax:.assert.elContainsText(selector, value);Parameters:selector : css selector to the html element.value : textual value or regular expression to assert.Usage:.assert.elContainsText(\".username\", \"testarmada\");.assert.elNotContainsText()description:Asserts if current element doesn’t contain a given textSyntax:.assert.elNotContainsText(selector, value);Parameters:selector : css selector to the html element.value : textual value or regular expression to assert.Usage:.assert.elNotContainsText(\".username\", \"testarmada\");.assert.selectorHasLength()description:Asserts if current selector returns given amount of elementsSyntax:.assert.selectorHasLength(selector, value);Parameters:selector : css selector to the html element.value : numeric value to assert.Usage:.assert.selectorHasLength(\".username\", 1);.assert.elValueContains()description:Asserts if current element contains the given valueSyntax:.assert.elValueContains(selector, value);Parameters:selector : css selector to the html element.value : textual value to assert.Usage:.assert.elValueContains(\".username\", \"Leo\");.assert.elLengthGreaterThan()description:Asserts if the length of an element’s attribute is greater than a numberSyntax:.assert.elLengthGreaterThan(selector, using, value);Parameters:selector : css selector to the html element.using : element attribute, can be chosen from [“value”, “text”, “html”, “length”].value : numeric value to assert.Usage:.assert.elLengthGreaterThan(\".username\", \"text\", 1);Nightwatch API:sFor Nightwatch API:s please go here",
        "url": "/documentation/Functional Testing/Native iOS/JAVASCRIPT/API Guide"
      },
    
      "documentation-data-insights-performance-trending-introduction": {
        "title": "Introduction",
        "content": "Trending Performance Data Insights allow the developer to see how the performanceof their application has evolved over time.Use caseAs applications change over time with new code updates and added features, the performanceof the application can be both positively and negatively affected. Easily accessed trendingperformance data enables the development team to identify which change introduced an increaseor decrease in the performance of their application, giving crucial information in theeffort to continue improvements to performance, or fix degradations.ImpactPerformance is one the most impacting factors on the customer experience, and can be verydifficult to diagnose when problems arise. By providing reliable, simple access to the datafrom performance testing, the developer benefits from increased knowledge of potentialissues without friction and the customer gets an enhanced experience.DashboardThe Data Insights Platform will provide clear reporting views for your project - see thispreview of the visualization of your data:Architecture",
        "url": "/documentation/Data Insights/Performance/Trending/Introduction"
      },
    
      "documentation-data-insights-performance-real-time-introduction": {
        "title": "Introduction",
        "content": "Real-Time Performance Data Insights allow the developer to see results of their performancetesting as they are returned, reducing the time spent waiting for this information.Use caseWhen running performance tests, the sooner the data is available, the faster the developercan take action to correct issues.After configuring and running performance tests, the developer would access the real-timeperformance reports to assess the results as they are reported.ImpactThe less time developers waste waiting for test data to be available, the more productivethose developers are - and the better their workflow is. What results is an improvedexperience for developers in the organization, and - through improved application qualitythat comes from these insights - a greatly improved experience for the customer.DashboardThe Data Insights Platform will provide clear reporting views for your project - see thispreview of the visualization of your data:Architecture",
        "url": "/documentation/Data Insights/Performance/Real Time/Introduction"
      },
    
      "documentation-data-insights-functional-trending-introduction": {
        "title": "Introduction",
        "content": "Trending Functional Data Insights allow the developer to see how the health of theirfunctional test suite has evolved over time.Use caseAs applications change over time with new code updates and added features, there is thepotential for functionality and appearance to break or unexpectedly change. Easily accessedtrending functional data enables the development team to assess the impact of these changeson the health of their test suite.This helps identify repeated issues being introduced, highlight features that are consistentlyfailing on certain browsers/devices and pinpoint browsers/devices that need special attentionby the development team.ImpactHaving access to this trending data allows teams to make lasting changes to their developmentworkflows to avoid repeating the same mistakes. This saves many hours of engineering time overthe life of a project, and improves code quality across the organization.DashboardThe Data Insights Platform will provide clear reporting views for your project - see thispreview of the visualization of your data:Architecture",
        "url": "/documentation/Data Insights/Functional/Trending/Introduction"
      },
    
      "documentation-data-insights-functional-real-time-introduction": {
        "title": "Introduction",
        "content": "Real-Time Functional Testing Data Insights allow the developer to see results of theirfunctional testing as they are returned, reducing the time spent waiting for this information.Use caseWhen running functional tests on multiple browsers or devices, the sooner the data is available,the faster the developer can take action to correct issues.After configuring and running functional tests, the developer would access the real-timefunctional reports to assess the results as they are reported.ImpactThe less time developers waste waiting for test data to be available, the more productivethose developers are - and the better their workflow is. What results is an improvedexperience for developers in the organization, and - through improved application qualityand visual appearance that comes from these insights - a greatly improved experiencefor the customer.DashboardThe Data Insights Platform will provide clear reporting views for your project - see thispreview of the visualization of your data:Architecture",
        "url": "/documentation/Data Insights/Functional/Real Time/Introduction"
      }
    
  };
</script>
<script src="/js/lunr.min.js"></script>
<script src="/js/search.js"></script>

	</div>

	<footer>
		<img class="left-footer-logo" alt="Left Footer Logo"
			 src="/documentation/images/dxt-logo.png"
			 srcset="/documentation/images/dxt-logo@2x.png 2x,
					 /documentation/images/dxt-logo@3x.png 3x">
		
		<span class="copyright">&copy; None</span>
		
		<img class="right-footer-logo" alt="Right Footer Logo"
			 src="/documentation/images/walmartlabs-logo.png"
			 srcset="/documentation/images/walmartlabs-logo@2x.png 2x,
			 		 /documentation/images/walmartlabs-logo@3x.png 3x">
	</footer>

</body>
</html>
